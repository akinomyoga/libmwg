<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>mwg::string 実装</title>
  <meta name="Mwg-Kick-Type" content="text.color" />
  <link rel="stylesheet" type="text/css" charset="utf-8" href="http://padparadscha/mwg3/mwg.slide.css" />
  <link rel="stylesheet" type="text/css" charset="utf-8" href="http://padparadscha/mwg3/prog.std.css" />
  <script type="text/javascript" charset="utf-8" src="http://padparadscha/mwg3/mwg.kick.js"></script>
</head>
<body class="width72">
<h1>string.h</h1>
<h2>構成</h2>

<ul>
<li>mwg::string_impl1::stringbase&lt;XCH,Alloc&gt;
  <p>全ての文字列クラスの基底クラス。
  基本的な非破壊的操作関数を備える。
  </p>
</li>
<li>mwg::string_impl1::string&lt;XCH&gt;
  <p>固定文字列。データを他の文字列と共有しうる。</p>
</li>
<li>mwg::string_impl1::strsub&lt;XCH&gt;
  <p>他の文字列、データに対する部分文字列を表現するクラス。</p>
</li>
<li>mwg::string_impl1::stradp&lt;XCH&gt;
  アダプタ。実質的に strsub と等価。
  唯一違う点は様々なクラスインスタンスから implicit に構築できる事。
  文字列の類を受け取る関数の引数の型などに用いるのが目的。
</li>
<li>mwg::string_impl1::strbuff&lt;XCH&gt;
  編集用の文字列。参照の複製はされない。
</li>
<li>mwg::string_impl1::strsymb&lt;XCH&gt;
  <p>インスタンスの単一性を保証するクラス
  等値比較が、ポインタを比較するだけで済むので楽。
  比較的長い文字列で同じ物が沢山現れる場合にはメモリの節約にもなるかも。
  </p>
  <p>クラス名に関しては一考の余地有り。
  ruby では symbol と呼ばれている物である。
  </p>
</li>
<li>mwg::string_impl1::strsymb_dictionary&lt;XCH&gt;</li>
  <p>strsymb の親クラス。
  存在しているインスタンス全てをこの中に保持して管理する。
  デフォルトでグローバルに使用できるインスタンスを生成するが、
  ローカルに使いたいシンボル群を管理する為に、自分でインスタンスを生成する事も可能にする。
  </p>
  <p>内部構造は取り敢えず std::map (sorted list) で二分探索。
  将来的には trie を考えても OK
  </p>
<li>mwg::string_impl1::strpath&lt;XCH&gt;
  ファイル名を管理する為の文字列
</li>
</ul>

<h2>実装方法について</h2>
<h3>現在の試行実装について。</h3>
<p>以前に少しだけ試しに実装してみて放置してあるコードについて再度整理してみる。
先ず、この実装では各文字列クラスは基底クラス strbase から派生する。
strbase では c_str 関数及び length 関数を抽象関数とする。
そして c_str 及び length の戻り値に対して様々な操作を提供する。
これによって各派生クラスは c_str 及び length 関数の実装だけに注力すれば良い事になる。
様々な文字列に対する操作は基底クラスである strbase のレベルで提供されているからである。
</p>
<p>特に strbase に必要な c_str 及び length は、
仮想関数の仕組みではなくてテンプレートによる特殊化によって実装する。
strbase の第一テンプレート引数は単体の文字の型 (char や wchar_t など) であり、
strbase の第二テンプレート引数が各特殊化の詳細を決める traits
(c_str や length の実装を含む) となっている。
</p>

<h3>c_str 関数について</h3>
<p>c_str という関数名は std::string の時と同様に null 終端文字列を返す事を想定させる。
この関数の戻り値は const char* であり、それをそのまま C の通常の文字列処理の関数に渡す事ができるという事である。
しかし、クラスによっては const char* を構築するのが容易でない場合がある。
例えば部分文字列 strsub の場合には、既に存在している文字列の一部分を保持する物である。
その参照先は一般に null 終端であるとは限らない。
既に存在している文字列を勝手に書き換える事は出来ないから、
c_str の戻り値として適切な文字列を用意する為には、
新しく領域を確保してそこに参照先の内容をコピーして返す必要がある。
他にも concat_string など temporary object として用意する文字列クラスでも、
一々メモリを確保して連続メモリとして c_str の結果を用意する訳にはいかない。
元々、concat_string などの temporary object を生成するのは、
そういったメモリの確保を省略して、最終結果を構築する時までメモリの確保を遅延させる為である。
この目的を達成する為に必要なのは、文字列の任意の位置の文字を取得する事であり、
c_str 及び length 関数ではない。
</p>

<p>つまり必要なのは</p>
<pre class="mwg-prog-cpp">
interface{
  const char* c_str() const;
  std::size_t length() const;
}
</pre>
<p>ではなく、</p>
<pre class="mwg-prog-cpp">
interface{
  [必須]
  char get_ch(int index) const;
  std::size_t length() const;
}
</pre>
<p>である。API として c_str 等の関数が欲しいと思う事もあると思うが、
それを用意するのは各種特殊化されたクラスの中ではなく、
共通処理を提供する strbase の方である。
</p>
<p>以下特殊化の時のインターフェイスについて考察。</p>
<pre class="mwg-prog-cpp">
interface{
  [必須]
  char get_ch(int index) const;
  std::size_t length() const;

  // c_str
  [必須] static const bool has_c_str;
  [選択] const char* c_str() const;
  /* 既定では get_ch の返す文字を反映して新しい文字列を構築して返す。
   * 直接 C 言語で使う事の出来る文字列バッファを内部に持っている場合には
   * わざわざコピーをしなくてもそのバッファのポインタを返せばよい。
   */
  
  //---------------------------------------------------------------------------
  // 文字列比較?
  [選択]
  const_iterator begin(int index=0) const;
  /* これは順番に文字列を辿りながら処理をする時に必要である。
   * 例えば比較演算などの場合。
   * 例えば concat_string の場合、毎回 get_ch を用いて文字を読み出すと、
   * 毎回文字がどの部分文字列にいるかを判定する必要があるが、
   * 連続に文字を触る事が分かっていればそれらの判定を省略できる可能性がある。
   */

  //---------------------------------------------------------------------------
  // 文字列比較?
  [選択 (既定の実装を提供)]
  void read(char* buff,std::size_t startIndex,std::size_t readLength) const;
  /* この関数は効率的にデータをコピーする為に必要である。
   * 例えば、或る程度長い文字列をコピーする場合には、
   * for ループで位置を回しながら get_ch を使って文字を読み出すより、
   * CPU の string 命令でデータをコピーしてしまった方が良い。
   *
   * そう言った処理ができない文字列の場合には、
   * 単に内部で for()get_ch のループを回せばよい。
   * この既定の動作は既定で準備しておいて、必要に応じて override する形が良い。
   */
}
</pre>
<p>因みに。何故初めの実装で c_str/length というインターフェイスにしたか。
→これは、既存ライブラリの文字列クラスが多くの場合、連続した領域に文字列を持っているからである。
つまり c_str/length というインターフェイスを採用しておけば、
他の既存ライブラリの文字列と簡単に共存できると考えたからである。
しかし、concat_string 等を用いて文字列処理を高速化しようと考えたのにこれでは意味がなかった。
</p>

<h4>まとめ</h4>
<p>次の実装では特殊化で提供するのは基本的に
  get_ch と length, 
  必要に応じて iterator や read 関数を実装、
という形にする。
</p>

<h3>実装の形態についてより詳しく</h3>
<ul>
<li>strbase から各クラスに派生
  <ul>
  <li>strbase の機能を拡張する形で文字列クラスを作成</li>
  <li>一番自然に思い付く方法</li>
  <li>○特別なコンストラクタの定義が容易</li>
  </ul>
</li>
<li>strbase のテンプレート引数で詳細を指定。
  <ul>
  <li>strbase が実際の実装になる。</li>
  <li>実装する上でテンプレート引数に指定した情報を用いる。</li>
  <li>std::basic_stream と std::streambuf の関係に近い。</li>
  </ul>
</li>
<li>strbase の基底クラスとして使用
  <ul>
  <li>拡張の関数などは基底クラスから使う。</li>
  <li>×strbase と同じ関数名で overload を作ろうと思っても隠蔽されてしまう
    <ul>
    <li>strbase を書き換えて using を使えば良さそうな気もするが、</li>
    <li>一つ一つの派生クラスに応じて using を追加していくのはありえない。</li>
    </ul>
  </li>
  <li>×特別なコンストラクタの定義が難しい</li>
  </ul>
</li>
</ul>
<p>結局上記の物を組み合わせるのが一番現実的である様に思う。</p>

<h2>実装2</h2>
<p>namespace mwg::string_detail2 内に試験的に実装。</p>
<ul>
<li>&gt;stradp</li>
<li>&gt;比較
  <ul>
  <li>&gt; 関係演算子</li>
  <li>starts_with(str)</li>
  <li>ends_with(str)</li>
  <li>starts_with(pat)</li>
  <li>ends_with(pat)</li>
  <li>match(pat)</li>
  <li>match(pat)</li>
  </ul>
</li>
<li>文字置換
  <ul>
  <li>replace(char_type, char_type)</li>
  <li>tolower</li>
  <li>toupper</li>
  </ul>
</li>
<li></li>
</ul>

<h3>関数名</h3>
<p>重要なのは分かり易くて、面倒でない関数名である。
それぞれのライブラリで、どの機能にどの様な名前が与えられているかを調べる。
</p>
<ul>
<li>C++ 標準ライブラリ <a href="http://www.cppll.jp/cppreference/cppstring_details.html#find">C++文字列</a></li>
<li>Boost String Algorithm Library <a href="http://www.boost.org/doc/libs/1_52_0/doc/html/string_algo/quickref.html">Quick Reference - 1.52.0</a>
  <p>※ Boost では基本的に破壊的操作を行う関数であり、
  _copy がついている物が新しいインスタンスを生成する関数である。
  </p>
</li>
<li>CLR <a href="http://msdn.microsoft.com/ja-jp/library/7wtc81z6(v=vs.80).aspx">String メソッド (System)</a></li>
<li>Java <a href="http://docs.oracle.com/javase/jp/6/api/java/lang/String.html">String (Java Platform SE 6)</a></li>
<li>mwg-string <a href="../../dist/mwg-string/doc/document.htm">lib-string 更新履歴</a></li>
<li>JavaScript/ECMAScript <a href="https://developer.mozilla.org/ja/docs/JavaScript/Reference/Global_Objects/String/prototype#Methods">String.prototype - JavaScript | MDN</a></li>
<li>Perl <a href="http://www.perlplus.jp/func/string/">文字列に関する関数 - Perl関数のリファレンス</a></li>
<li>Ruby <a href="http://doc.ruby-lang.org/ja/1.9.2/class/String.html">class String</a></li>
<li>AWK (GAWK) <a href="http://www.kt.rim.or.jp/~kbk/gawk/gawk_13.html">The GAWK Manual - 組込み関数</a></li>
</ul>

<h4>連結・切り出し・挿入・削除</h4>
<dl>
<dt>operator+</dt>
<dd>
  <p>文字列を連結します。</p>
<pre class="mwg-prog-cpp">
s1+s2;
</pre>
</dd>
<dt>join</dt>
<dd>
  <p>文字列の集合を連結します。</p>
<pre class="mwg-prog-cpp">
- arr.join();
- arr.join(s1); // s1 分割文字列
</pre>
  <p>c.f. join/join_if (Boost),</p>
</dd>
<dt>repeat, operator*</dt>
<dd>
<pre class="">
- s.repeat(n); // n 繰り返し回数
- s*n;
</pre>
  <p>Repeat (mwg-string), operator* (Ruby)</p>
</dd>
<dt>c.f. slice, substr</dt>
<dd>
<pre class="mwg-prog-cpp">
s1.slice(i);
s1.slice(i,j);  
s1.slice(r);
s1.substr(i,len);
</pre>
  <p>c.f. substr (C++), Substring (CLR), subSequence/substring (Java),
    Slice/Substr (mwg-string), slice/substr/substring (JavaScript), substr (Perl), slice (Ruby), substr (awk)</p>
</dd>
<dt>head</dt>
<dd>
  <p>文字列の先頭 n 文字部分を取り出します。</p>
<pre class="mwg-prog-cpp">
s1.head();  // 最初の文字
s1.head(n); // 先頭文字列
</pre>
  <p>c.f. find_head (Boost), Head (mwg-string), chr/ord (Perl), chr/ord (Ruby)</p>
</dd>
<dt>tail</dt>
<dd>
  <p>文字列の先頭 n 文字部分を取り出します。</p>
<pre class="mwg-prog-cpp">
s1.tail();  // 最後の文字
s1.tail(n); // 末端文字列
</pre>
  <p>c.f. find_tail (Boost), Tail (mwg-string)</p>
</dd>
<dt>insert</dt>
<dd>
  <p>c.f. insert (C++), Insert (CLR), Insert (mwg-string), insert (Ruby)</p>
</dd>
<dt>remove</dt>
<dd>
<pre class="mwg-prog-cpp">
s.remove(i);
s.remove(i,j);
s.remove(r);
</pre>
  <p>c.f. erase (C++), Remove (CLR)</p>
</dd>
<dt>split, rsplit</dt>
<dd>
  <p>空白または指定された分割子で文字列を分割します。</p>
<pre class="mwg-prog-cpp">
- s.split(i=-1,opt=0);     // i 最大分割数; opt オプション trim/remove_empty_string
- s.split(s1,i=-1,opt=0);  // s1  分割文字列
- s.split(reg,i=-1,opt=0); // reg 分割子の正規表現
</pre>
  <p>c.f. split/iter_split (Boost), Split (CLR), split (Java), split (JavaScript), split/partition/rpartition (Ruby), split (awk)</p>
</dd>
</dl>

<h4>文字の変換</h4>
<dl>
<dt>tolower</dt>
<dd>
  <p>文字列内の英大文字を英小文字に変換します。</p>
<pre class="mwg-prog-cpp">
s.lower();
s.lower(i);
s.lower(i,j);
s.lower(r);
</pre>
  <p>c.f. tolower (C), to_lower (Boost), ToLower (CLR), toLowerCase (Java),
    ToLower (mwg-string), toLowerCase (JavaScript), lc (Perl), downcase (Ruby), tolower (awk)</p>
</dd>
<dt>toupper</dt>
<dd>
  <p>文字列内の英小文字を英大文字に変換します。</p>
<pre class="mwg-prog-cpp">
s.upper();
s.upper(i);
s.upper(i,j);
s.upper(r);
</pre>
  <p>c.f. toupper (C), to_upper (Boost), ToUpper (CLR), toUpperCase (Java),
    ToUpper (mwg-string), toUpperCase (JavaScript), uc (Perl), upcase (Ruby), toupper (awk)</p>
</dd>
<dt>map</dt>
<dd>
<pre class="mwg-prog-cpp">
s.map(filter);
s.map(filter,i);
s.map(filter,i,j);
s.map(filter,r);
</pre>
  <p>c.f. std::transform (C++), System.Array.ConvertAll (CLR), Map (mwg-string)</p>
</dd>
<dt>参考</dt>
<dd>
  <p>c.f. ToLowerInvariant/ToUpperInvariant (CLR),
    ucfirst/lcfirst (Perl), capitalize/tr/swapcase (Ruby)</p>
</dd>
</dl>

<h4>空白・幅調節</h4>
<dl>
<dt>trim</dt>
<dd>
  <p>文字列の両端にある連続する空白を除去します。</p>
<pre class="mwg-prog-cpp">
s1.trim();
s1.trim(s2);   // s2   削除文字集合
s1.trim(pred); // pred 削除文字を判定する関数
</pre>
  <p>c.f. trim (Boost), Trim (CLR), trim (Java), Trim/TrimAny (mwg-string), trim (JavaScript), strip (Ruby), strip (Makefile)</p>
</dd>
<dt>ltrim</dt>
<dd>
  <p>文字列の先頭についている連続する空白を除去します。</p>
<pre class="mwg-prog-cpp">
s1.ltrim();
s1.ltrim(s2);   // s2   削除文字集合
s1.ltrim(pred); // pred 削除文字を判定する関数
</pre>
  <p>c.f. trim_left/trim_left_if (Boost), TrimStart (CLR), TrimL/TrimAnyL (mwg-string), lstrip (Ruby)</p>
</dd>
<dt>rtrim</dt>
<dd>
  <p>文字列の末端についている連続する空白を除去します。</p>
<pre class="mwg-prog-cpp">
s1.rtrim();
s1.rtrim(s2);   // s2   削除文字集合
s1.rtrim(pred); // pred 削除文字を判定する関数
</pre>
  <p>c.f. trim_right/trim_right_if (Boost), TrimEnd (CLR), TrimR/TrimAnyR (mwg-string), rstrip (Ruby)</p>
</dd>
<dt>pad</dt>
<dd>
<pre class="mwg-prog-cpp">
s.pad(len);
s.pad(len,c);
</pre>
  <p>c.f. center (Ruby)</p>
</dd>
<dt>lpad</dt>
<dd>
<pre class="mwg-prog-cpp">
s.lpad(len);
s.lpad(len,c);
</pre>
  <p>c.f. PadLeft (CLR), ljust (Ruby)</p>
</dd>
<dt>rpad</dt>
<dd>
<pre class="mwg-prog-cpp">
s.rpad(len);
s.rpad(len,c);
</pre>
  <p>c.f. PadRight (CLR), rjust (Ruby)</p>
</dd>
</dl>

<h4>判定</h4>
<dl>
<dt>operator==</dt>
<dt>operator!=</dt>
<dt>operator&lt;=</dt>
<dt>operator&gt;=</dt>
<dt>operator&lt;</dt>
<dt>operator&gt;</dt>
<dd>
  <p>文字列を比較します。</p>
<pre class="mwg-prog-cpp">
s1==s2;
s1!=s2;
s1&lt;=s2;
s1&gt;=s2;
s1&lt;s2;
s1&gt;s2;
</pre>
</dd>
<dt>compare</dt>
<dd>
  <p>c.f. strcmp/strncmp (C), lexicographical_compare (Boost), CompareOriginal (CLR), compareTo (Java), operator&lt;=&gt; (Ruby)</p>
</dd>
<dt>icompare</dt>
<dd>
  <p>c.f. stricmp/strcasecmp/strnicmp/strncasecmp (C), ilexicographical_compare (Boost). Compare (CLR), compareToIgnoreCase (Java), casecmp (Ruby)</p>
</dd>
<dt>starts</dt>
<dd>
  <p>文字列が指定された文字列で始まっているかを判定します。</p>
<pre class="mwg-prog-cpp">
s.starts(s1); // s1 文字列
</pre>
  <p>c.f. starts_with (Boost), StartsWith (CLR), startsWith (Java), StartsWith (mwg-string), start_with? (Ruby)</p>
</dd>
<dt>ends</dt>
<dd>
  <p>文字列が指定された文字列で終わっているかを判定します。</p>
<pre class="mwg-prog-cpp">
s.ends(s1); // s1 文字列
</pre>
  <p>c.f. ends_with (Boost), EndsWith (CLR), endsWith (Java), EndsWith (mwg-string), end_with? (Ruby)</p>
</dd>
<dt>参考</dt>
<dd>
  <p>all/istarts_with/iends_with (Boost)</p>
</dd>
</dl>

<h4>検索・置換</h4>
<dl>
<dt>find</dt>
<dd>
  <p>指定した文字列を検索して開始位置を返します。</p>
<pre class="mwg-prog-cpp">
s.find(s1);       // s1   目的文字列
s.find(s1,i);     // i    検索範囲開始位置
s.find(s1,i,j);   // j    検索範囲終端位置
s.find(s1,r);     // r    検索範囲
s.find(pred);     // pred 文字判定関数
s.find(pred,i);   //
s.find(pred,i,j); //
s.find(pred,r);   //
- s.find(reg);      // reg  正規表現
- s.find(reg,i);    //
- s.find(reg,i,j);  //
- s.find(reg,r);    //
</pre>
  <p>c.f. strstr/strchr (C), find (C++), find_first/find_regex (Boost), IndexOf (CLR), indexOf (Java),
    IndexOf (mwg-string), indexOf/search (JavaScript), index (Perl), index (Ruby), index/match (awk)</p>
  <p>文字列が他方の文字列に含まれているかどうかを判定する時。</p>
<pre class="mwg-prog-cpp">
s1.find(...)&gt;=0;
</pre>
  <p>c.f. contains (Boost), Contains (CLR), contains/matches (Java), include? (Ruby), findstring (Makefile)</p>
</dd>
<dt>find_any</dt>
<dd>
  <p>文字集合に含まれる文字を検索して位置を返します。</p>
<pre class="mwg-prog-cpp">
s.find_any(s2);       // s2 文字集合
s.find_any(s2,i);     // s2 文字集合, 検索範囲 [i, s1.length() )
s.find_any(s2,i,j);   // s2 文字集合, 検索範囲 [i, j)
s.find_any(s2,r);     // s2 文字集合, r 検索範囲
</pre>
  <p>strpbrk/strcspn (C), find_first_of (C++), IndexOfAny (CLR), IndexOfAny (mwg-string)</p>
</dd>
<dt>find_not</dt>
<dd>
  <p>文字集合に含まれない文字を検索して位置を返す。</p>
<pre class="mwg-prog-cpp">
s.find_not(s2);       // s2 文字集合
s.find_not(s2,i);     // s2 文字集合, 検索範囲 [i, s1.length() )
s.find_not(s2,i,j);   // s2 文字集合, 検索範囲 [i, j)
s.find_not(s2,r);     // s2 文字集合, r 検索範囲
</pre>
  <p>strspn (C), find_first_not_of (C++), IndexOfNot (mwg-string)</p>
</dd>
<dt>rfind</dt>
<dd>
  <p>指定した文字列を末端から検索して開始位置を返す。</p>
<pre class="mwg-prog-cpp">
s.rfind(s2);     // s2 目的文字列
s.rfind(s2,i);   // s2 目的文字列, 検索範囲 [i, s1.length() )
s.rfind(s2,i,j); // s2 目的文字列, 検索範囲 [i, j)
s.rfind(s2,r);   // s2 目的文字列, r 検索範囲
s.rfind(pred);     // pred 文字判定関数
s.rfind(pred,i);   // pred 文字判定関数, 検索範囲 [i, s1.length() )
s.rfind(pred,i,j); // pred 文字判定関数, 検索範囲 [i, j)
s.rfind(pred,r);   // pred 文字判定関数, r 検索範囲
- s.rfind(reg);     // s2 正規表現
- s.rfind(reg,i);   // s2 正規表現, 検索範囲 [i, s1.length() )
- s.rfind(reg,i,j); // s2 正規表現, 検索範囲 [i, j)
- s.rfind(reg,r);   // s2 正規表現, r 検索範囲
</pre>
  <p>strrstr (C), rfind (C++), find_last(Boost), LastIndexOf (CLR), lastIndexOf (Java),
    IndexOfR (mwg-string), lastIndexOf (JavaScript), rindex (Perl), rindex (Ruby)</p>
</dd>
<dt>rfind_any</dt>
<dd>
  <p>文字集合に含まれる文字を末端から検索して位置を返す。</p>
<pre class="mwg-prog-cpp">
s.rfind_any(s2);       // s2 文字集合
s.rfind_any(s2,i);     // s2 文字集合, 検索範囲 [i, s1.length() )
s.rfind_any(s2,i,j);   // s2 文字集合, 検索範囲 [i, j)
s.rfind_any(s2,r);     // s2 文字集合, r 検索範囲
</pre>
  <p>find_last_of (C++), LastIndexOfAny (CLR), IndexOfAnyR (mwg-string)</p>
</dd>
<dt>rfind_not</dt>
<dd>
  <p>文字集合に含まれない文字を末端から検索して位置を返す。</p>
<pre class="mwg-prog-cpp">
s.rfind_not(s2);       // s2 文字集合
s.rfind_not(s2,i);     // s2 文字集合, 検索範囲 [i, s1.length() )
s.rfind_not(s2,i,j);   // s2 文字集合, 検索範囲 [i, j)
s.rfind_not(s2,r);     // s2 文字集合, r 検索範囲
</pre>
  <p>find_last_not_of (C++), IndexOfNotR (mwg-string)</p>
</dd>
<dt>参考</dt>
<dd>
  <p>Boost find_nth/ifind_first/ifind_last/ifind_nth</p>
</dd>
<dt>replace</dt>
<dd>
<pre class="mwg-prog-cpp">
s.replace(i,j,s2); // 範囲を置換
s.replace(r  ,s2); // 範囲を置換
s.replace(c1 ,c2); // 文字を置換
- s.replace(s1 ,s2); // 文字列を置換
- s.replace(reg,s2); // reg 正規表現
- s.replace(reg,fun); // fun 置換後の文字列を決める関数
</pre>
  <p>replace_all/replace_regex/replace_first/replace_last (Boost), Relace (CLR),
    replace/replaceAll/replaceFirst (Java),
    Replace (mwg-string), replace (JavaScript), gsub/sub (Ruby),
    sub/gsub (awk), subst/patsubst (Makefile)
  </p>
  <p>Boost の replace_nth に対応する関数は、
    それ程有用とは思われないので提供しない。</p>
  <p>Boost の replace_regex_all, replace_head, replace_tail,
    ireplace_first, ireplace_last, ireplace_nth, ireplace_all
    に対応する関数は正規表現及びそのフラグを用いて表現できるので提供しない。
  </p>
  <p>Boost の erase_all, erase_regex, erase_regex_all, erase_head,
    erase_tail, erase_first, erase_last, erase_nth,
    ierase_first, ierase_last, ierase_nth, ierase_all
    に対応する関数は置換後の文字列に "" を指定すれば良いだけなので提供しない。
  </p>
</dd>
<dt>match, rmatch, match_at, rmatch_at</dt>
<dd>
  <p>正規表現に対する一致を試す。</p>
<pre class="mwg-prog-cpp">
- s1.match(reg);     // reg 正規表現
- s1.match(reg,i);   // i   範囲開始位置
- s1.match(reg,i,j); // j   範囲終端位置
- s1.match(reg,r);   // r   範囲
- s1.rmatch(reg,j);
- s1.rmatch(reg,i,j);
- s1.rmatch(reg,r);
- s1.match_at(reg);
- s1.match_at(reg,i);
- s1.match_at(reg,i,j);
- s1.match_at(reg,r);
- s1.rmatch_at(reg,j);
- s1.rmatch_at(reg,i,j);
- s1.rmatch_at(reg,r);
</pre>
  <ul>
  <li>match: 先頭から順に一致を試す。</li>
  <li>rmatch: 末尾から順に一致を試す。</li>
  <li>match_at: 先頭を含む部分列に対してだけ、一致を試す。</li>
  <li>rmatch_at: 末端を含む部分列に対してだけ、一致を試す。</li>
  </ul>
  <p>Search/SearchR/Match/MatchAt (mwg-string), match (JavaScript), match (awk)</p>
</dd>
<dt>match_iterator
  <p>find_all/iter_find (Boost), scan (Ruby), match (JavaScript)</p>
</dt>
</dl>

<h4>他</h4>
<dl>
<dt>format, operator%</dt>
<dd>
  <p>sprintf (C), Format (CLR), format (Java), sprintf (Perl), operator% (Ruby), sprintf (awk)</p>
</dd>
<dt>reverse</dt>
<dd>
  <p>Reverse (mwg-string), reverse (Ruby)</p>
</dd>
<dt>empty</dt>
<dd>
  <p>empty (C++), empty? (Ruby)</p>
</dd>
<dt>参考</dt>
<dd>
  <p>mwg-string: ReverseMap</p>
  <p>Perl: chop chomp, hex oct, </p>
  <p>Ruby: chomp chop, count, crypt, delete, hash sum,
    hex oct to_i to_f to_c to_r to_s to_str, succ next, squeeze tr_s</p>
</dd>
</dl>


</body>
</html>
