// -*- mode: c++; coding: utf-8 -*-
#pragma once
#ifndef MWG_STDM_CMATH
#define MWG_STDM_CMATH
#ifdef _MSC_VER
# define _USE_MATH_DEFINES
#endif
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
#include <math.h>
#include <cmath>
#include <mwg/defs.h>
#include <mwg/std/type_traits>

#pragma%include "../impl/ManagedTest.pp"
#pragma%x begin_check
#include <cstdio>
#include <mwg/std/cmath>
#include <mwg/except.h>
#pragma%x end_check

// ToDo: ilogb logb FP_ILOGB0 FP_ILOGBNAN
// ToDo: nextafter nexttoward copysign scalbn scalbln
// ToDo: nearbyint rint lrint llrint
// ToDo: Correct errhandling of round lround llround
// ToDo: isgreater isgreaterequal isless islessequal islessgreater
// ToDo: isunordered
// ToDo: erf erfc tgamma lgamma
// ToDo: 古くからある関数や using した関数でも arithmetic overloads を追加する。

namespace mwg {
namespace stdm {
namespace cmath_detail {
  template<typename T, typename U = T>
  struct overload: mwg::stdm::enable_if<
    (mwg::stdm::is_arithmetic<T>::value && mwg::stdm::is_arithmetic<U>::value),
    typename mwg::stdm::conditional<
      (mwg::stdm::is_same<T, long double>::value || mwg::stdm::is_same<U, long double>::value), long double,
      typename mwg::stdm::conditional<
        (mwg::stdm::is_same<T, float>::value && mwg::stdm::is_same<U, float>::value), float,
        double>::type>::type>
  {
    static const bool value = mwg::stdm::is_arithmetic<T>::value && mwg::stdm::is_arithmetic<U>::value;
    template<typename R> struct enable: mwg::stdm::enable_if<value, R> {};
  };
}
}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [POSIX math.h XSI]
//
//-----------------------------------------------------------------------------
//
// Math constants
//   できるだけ _USE_MATH_DEFINES や _GNU_SOURCE を define して使っているが、
//   include の順序の都合で結局 define されないという事も多くあるのでここで定義する。
//   値は https://msdn.microsoft.com/en-us/library/4hwaceh6(v=vs.100).aspx から取った。
//
//
#ifndef M_E
# define M_E        2.71828182845904523536e+000
#endif
#ifndef M_LOG2E
# define M_LOG2E    1.44269504088896340736e+000
#endif
#ifndef M_LOG10E
# define M_LOG10E   4.34294481903251827651e-001
#endif
#ifndef M_LN2
# define M_LN2      6.93147180559945309417e-001
#endif
#ifndef M_LN10
# define M_LN10     2.30258509299404568402e+000
#endif
#ifndef M_PI
# define M_PI       3.14159265358979323846e+000
#endif
#ifndef M_PI_2
# define M_PI_2     1.57079632679489661923e+000
#endif
#ifndef M_PI_4
# define M_PI_4     7.85398163397448309616e-001
#endif
#ifndef M_1_PI
# define M_1_PI     3.18309886183790671538e-001
#endif
#ifndef M_2_PI
# define M_2_PI     6.36619772367581343076e-001
#endif
#ifndef M_2_SQRTPI
# define M_2_SQRTPI 1.12837916709551257390e+000
#endif
#ifndef M_SQRT2
# define M_SQRT2    1.41421356237309504880e+000
#endif
#ifndef M_SQRT1_2
# define M_SQRT1_2  7.07106781186547524401e-001
#endif

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.3] Classification macros
//
//-----------------------------------------------------------------------------
/*?lwiki
 * @fn bool mwg::stdm::signbit(float);
 * @fn bool mwg::stdm::signbit(double);
 * @fn bool mwg::stdm::signbit(long double);
 * @fn bool mwg::stdm::signbit('integral-time');
 */

/*?mconf
 * if ! X -t'std::signbit(x)' -oMWGCONF_HAS_STD_SIGNBIT cmath 'std::signbit(2.0)'; then
 *   # 元々マクロで定義されていてかつ ::signbit が存在しない場合、このヘッダによ
 *   # って (名前空間を指定せずに) signbit を使う事ができたのができなくなる。既存
 *   # のコードがコンパイルできなくなるのを防ぐ為、この場合に限ってグローバル名前
 *   # 空間に signbit の定義を引き出す。その他の fpclassify マクロも同様。
 *   X -t'::signbit' -oMWGCONF_HAS_GLOBAL_SIGNBIT cmath $'\n#undef signbit\nsignbit(0.0);'
 * fi
 */

#ifndef MWGCONF_HAS_STD_SIGNBIT
namespace mwg {
namespace stdm_detail {
# ifdef signbit
  static inline bool signbit_impl(float value) {return signbit(value) != 0;}
  static inline bool signbit_impl(double value) {return signbit(value) != 0;}
  static inline bool signbit_impl(long double value) {return signbit(value) != 0;}
#  undef signbit
#  ifndef MWGCONF_HAS_GLOBAL_SIGNBIT
#   define MWG_STDM_CMATH_DefinesGlobalSignbit
#  endif
# else
  template<typename T>
  bool signbit_impl(T value) {return value < 0;}
# endif
}

namespace stdm {

  template<typename T>
  typename cmath_detail::overload<T>::template enable<bool>::type signbit(T value) {
    return ::mwg::stdm_detail::signbit_impl((typename cmath_detail::overload<T>::type) value);
  }
}
}

# ifdef MWG_STDM_CMATH_DefinesGlobalSignbit
using ::mwg::stdm::signbit;
# endif
#endif

//-----------------------------------------------------------------------------
/*?lwiki
 * @fn bool mwg::stdm::isnan(float);
 * @fn bool mwg::stdm::isnan(double);
 * @fn bool mwg::stdm::isnan(long double);
 * @fn bool mwg::stdm::isinf(float);
 * @fn bool mwg::stdm::isinf(double);
 * @fn bool mwg::stdm::isinf(long double);
 * @fn bool mwg::stdm::isfinite(float);
 * @fn bool mwg::stdm::isfinite(double);
 * @fn bool mwg::stdm::isfinite(long double);
 * @fn bool mwg::stdm::isnormal(float);
 * @fn bool mwg::stdm::isnormal(double);
 * @fn bool mwg::stdm::isnormal(long double);
 */

/*?mconf
 * if ! X -t'std::isnan(x)' -oMWGCONF_HAS_STD_ISNAN cmath 'std::isnan(2.0)'; then
 *   # floating-point classification macros
 *   #   C99 に従えばマクロで定義されるので ifdef で判定可能だが、
 *   #   C++ では関数として定義されている事があるので個別にチェックする必要がある。
 *   X -t'::isnan' -oMWGCONF_HAS_GLOBAL_ISNAN cmath $'\n#undef isnan\nisnan(0.0);'
 *   X -t'::isinf' -oMWGCONF_HAS_GLOBAL_ISINF cmath $'\n#undef isinf\nisinf(0.0);'
 *   X -t'::isfinite' -oMWGCONF_HAS_GLOBAL_ISFINITE cmath $'\n#undef isfinite\nisfinite(0.0);'
 *   X -t'::isnormal' -oMWGCONF_HAS_GLOBAL_ISNORMAL cmath $'\n#undef isnormal\nisnormal(0.0);'
 * fi
 */

#ifndef MWGCONF_HAS_STD_ISNAN
#ifdef _MSC_VER
# include <float.h>
namespace mwg {
namespace stdm {
  template<typename T>
  bool isnan(const T& value) {
    return ::_isnan((double) value);
  }
  template<typename T>
  bool isinf(const T& value) {
    return (::_fpclass((double) value) & (_FPCLASS_PINF | _FPCLASS_NINF)) != 0;
  }
  template<typename T>
  bool isfinite(const T& value) {
    return ::_finite((double) value);
  }
  template<typename T>
  bool isnormal(const T& value) {
    return (::_fpclass((double) value) & (_FPCLASS_PN | _FPCLASS_NN)) != 0;
  }
}
}
#else /* !defined(_MSC_VER) */
# include <cfloat>
namespace mwg {
namespace stdm_detail {

#ifdef isnan
  static inline bool isnan_impl(double value) {return isnan(value) != 0;}
  static inline bool isnan_impl(long double value) {return isnan(value) != 0;}
  static inline bool isnan_impl(float value) {return isnan(value) != 0;}
# undef isnan
# ifndef MWGCONF_HAS_GLOBAL_ISNAN
#  define MWG_STDM_CMATH_DefinesGlobalIsnan
# endif
#else
  template<typename T>
  bool isnan_impl(const T& value) {
    return value != value;
  }
#endif

#ifdef isinf
  static inline bool isinf_impl(float value) {return isinf(value) != 0;}
  static inline bool isinf_impl(double value) {return isinf(value) != 0;}
  static inline bool isinf_impl(long double value) {return isinf(value) != 0;}
# undef isinf
# ifndef MWGCONF_HAS_GLOBAL_ISINF
#  define MWG_STDM_CMATH_DefinesGlobalIsinf
# endif
#else
  template<typename T>
  bool isinf_impl(const T& value) {
    return value == HUGE_VAL || value == -HUGE_VAL;
  }
#endif

#ifdef isfinite
  static inline bool isfinite_impl(float value) {return isfinite(value) != 0;}
  static inline bool isfinite_impl(double value) {return isfinite(value) != 0;}
  static inline bool isfinite_impl(long double value) {return isfinite(value) != 0;}
# undef isfinite
# ifndef MWGCONF_HAS_GLOBAL_ISFINITE
#  define MWG_STDM_CMATH_DefinesGlobalIsfinite
# endif
#else
  template<typename T>
  bool isfinite_impl(const T& value) {
    return !(mwg::stdm_detail::isnan_impl(value) || mwg::stdm_detail::isinf_impl(value));
  }
#endif

#ifdef isnormal
  static inline bool isnormal_impl(float value) {return isnormal(value) != 0;}
  static inline bool isnormal_impl(double value) {return isnormal(value) != 0;}
  static inline bool isnormal_impl(long double value) {return isnormal(value) != 0;}
# undef isnormal
# ifndef MWGCONF_HAS_GLOBAL_ISNORMAL
#  define MWG_STDM_CMATH_DefinesGlobalIsnormal
# endif
#else
  static inline bool isnormal_impl(const float& value) {
    if (!mwg::stdm_detail::isfinite_impl(value)) return false;
    return value >= FLT_MIN || -FLT_MIN >= value;
  }
  static inline bool isnormal_impl(const double& value) {
    if (!mwg::stdm_detail::isfinite_impl(value)) return false;
    return value >= DBL_MIN || -DBL_MIN >= value;
  }
  static inline bool isnormal_impl(const long double& value) {
    if (!mwg::stdm_detail::isfinite_impl(value)) return false;
    return value >= LDBL_MIN || -LDBL_MIN >= value;
  }
#endif
}

namespace stdm{
  template<typename T>
  typename cmath_detail::overload<T>::template enable<bool>::type isnan(const T& x) {
    return mwg::stdm_detail::isnan_impl((typename cmath_detail::overload<T>::type) x);
  }
  template<typename T>
  typename cmath_detail::overload<T>::template enable<bool>::type isinf(const T& x) {
    return mwg::stdm_detail::isinf_impl((typename cmath_detail::overload<T>::type) x);
  }
  template<typename T>
  typename cmath_detail::overload<T>::template enable<bool>::type isfinite(const T& x) {
    return mwg::stdm_detail::isfinite_impl((typename cmath_detail::overload<T>::type) x);
  }
  template<typename T>
  typename cmath_detail::overload<T>::template enable<bool>::type isnormal(const T& x) {
    return mwg::stdm_detail::isnormal_impl((typename cmath_detail::overload<T>::type) x);
  }
}
}

# ifdef MWG_STDM_CMATH_DefinesGlobalIsnan
using mwg::stdm::isnan;
# endif
# ifdef MWG_STDM_CMATH_DefinesGlobalIsinf
using mwg::stdm::isinf;
# endif
# ifdef MWG_STDM_CMATH_DefinesGlobalIsfinite
using mwg::stdm::isfinite;
# endif
# ifdef MWG_STDM_CMATH_DefinesGlobalIsnormal
using mwg::stdm::isnormal;
# endif
#endif /* end of !defined(_MSC_VER) */
#endif /* end of !defined(MWGCONF_HAS_STD_ISNAN) */

//-----------------------------------------------------------------------------
/*?lwiki
 * @fn int mwg::stdm::fpclassify(float);
 * @fn int mwg::stdm::fpclassify(double);
 * @fn int mwg::stdm::fpclassify(long double);
 * @fn int mwg::stdm::fpclassify('integral-type');
 * @def int FP_NAN
 * @def int FP_INFINITE
 * @def int FP_NORMAL
 * @def int FP_SUBNORMAL
 * @def int FP_ZERO
 */

/*?mconf
 * if ! X -t'std::fpclassify(x)' -oMWGCONF_HAS_STD_FPCLASSIFY cmath 'std::fpclassify(2.0)'; then
 *   X -t'::fpclassify' -oMWGCONF_HAS_GLOBAL_FPCLASSIFY cmath $'\n#undef fpclassify\nfpclassify(0.0);'
 * fi
 */

#ifndef MWGCONF_HAS_STD_FPCLASSIFY
# ifndef FP_NAN
#  define FP_NAN       0x01
# endif
# ifndef FP_INFINITE
#  define FP_INFINITE  0x02
# endif
# ifndef FP_NORMAL
#  define FP_NORMAL    0x04
# endif
# ifndef FP_SUBNORMAL
#  define FP_SUBNORMAL 0x08
# endif
# ifndef FP_ZERO
#  define FP_ZERO      0x10
# endif

# ifdef _MSC_VER

namespace mwg {
namespace stdm {

  template<typename T>
  int fpclassify(const T& value) {
    switch(::_fpclass((double) value)) {
    case _FPCLASS_SNAN:
    case _FPCLASS_QNAN:
      return FP_NAN;
    case _FPCLASS_PINF:
    case _FPCLASS_NINF:
      return FP_INFINITE;
    case _FPCLASS_PN:
    case _FPCLASS_NN:
      return FP_NORMAL;
    case _FPCLASS_PD:
    case _FPCLASS_ND:
      return FP_SUBNORMAL;
    case _FPCLASS_PZ:
    case _FPCLASS_NZ:
      return FP_ZERO;
    default:
      return FP_NORMAL;
    }
  }
}
}

# else /* !defined(_MSC_VER) */

namespace mwg {
namespace stdm_detail {

#  ifdef fpclassify
  static inline int fpclassify_impl(float value) {return fpclassify(value);}
  static inline int fpclassify_impl(double value) {return fpclassify(value);}
  static inline int fpclassify_impl(long double value) {return fpclassify(value);}
#   undef fpclassify
#   ifndef MWGCONF_HAS_GLOBAL_FPCLASSIFY
#    define MWG_STDM_CMATH_DefinesGlobalFpclassify
#   endif
#  else
  template<typename T>
  int fpclassify_impl(const T& x) {
    if (x == 0) {
      return FP_ZERO;
    } else if (mwg::stdm::isnan(x)) {
      return FP_NAN;
    } else if (mwg::stdm::isinf(x)) {
      return FP_INFINITE;
    } else if (!mwg::stdm::isnormal(x)) {
      return FP_SUBNORMAL;
    } else {
      return FP_NORMAL;
    }
  }
#  endif
}

namespace stdm {
  template<typename T>
  int fpclassify(const T& x) {
    return mwg::stdm_detail::fpclassify_impl(x);
  }
}
}

#  ifdef MWG_STDM_CMATH_DefinesGlobalFpclassify
using mwg::stdm::fpclassify;
#  endif
# endif /* end of !defined(_MSC_VER) */
#endif /* end of !defined(MWGCONF_HAS_STD_FPCLASSIFY) */

//-----------------------------------------------------------------------------
//
// tests for Classification functions
//

#pragma%x begin_test
void test() {
#ifdef _MSC_VER
  double const inf = double(float(1e100));
#else
  double const inf = 1.0 / 0.0;
#endif
  double const qnan = std::sqrt(double(-1));
  mwg_check(!mwg::stdm::isnan(0.0));
  mwg_check(!mwg::stdm::isnan(1.0));
  mwg_check(!mwg::stdm::isnan(inf));
  mwg_check(!mwg::stdm::isnan(-inf));
  mwg_check( mwg::stdm::isnan(qnan));

  mwg_check(!mwg::stdm::isinf(0.0));
  mwg_check(!mwg::stdm::isinf(1.0));
  mwg_check( mwg::stdm::isinf(inf));
  mwg_check( mwg::stdm::isinf(-inf));
  mwg_check(!mwg::stdm::isinf(qnan));

  mwg_check( mwg::stdm::isfinite(0.0));
  mwg_check( mwg::stdm::isfinite(1.0));
  mwg_check(!mwg::stdm::isfinite(inf));
  mwg_check(!mwg::stdm::isfinite(-inf));
  mwg_check(!mwg::stdm::isfinite(qnan));

  mwg_check(!mwg::stdm::isnormal(0.0));
  mwg_check( mwg::stdm::isnormal(1.0));
  mwg_check(!mwg::stdm::isnormal(inf));
  mwg_check(!mwg::stdm::isnormal(-inf));
  mwg_check(!mwg::stdm::isnormal(qnan));

  mwg_check(mwg::stdm::fpclassify(0.0) == FP_ZERO);
  mwg_check(mwg::stdm::fpclassify(1.0) == FP_NORMAL);
  mwg_check(mwg::stdm::fpclassify(inf) == FP_INFINITE);
  mwg_check(mwg::stdm::fpclassify(-inf)== FP_INFINITE);
  mwg_check(mwg::stdm::fpclassify(qnan)== FP_NAN);
}
#pragma%x end_test

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.4] Trigonometric functions
//
//-----------------------------------------------------------------------------

#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
namespace mwg {
namespace stdm {
  using ::std::sin;
  using ::std::cos;
  using ::std::tan;
  using ::std::asin;
  using ::std::acos;
  using ::std::atan;
  using ::std::atan2;
}
}
#endif

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.5] Hyperbolic functions
//
//-----------------------------------------------------------------------------
/*?mconf
 * X -t'std::asinh(x)' -oMWGCONF_HAS_STD_ASINH cmath 'std::asinh(2.0)' ||
 *   X -t'::asinh(x)' -oMWGCONF_HAS_ASINH math.h '::asinh(2.0)'
 * X -t'std::acosh(x)' -oMWGCONF_HAS_STD_ACOSH cmath 'std::acosh(2.0)' ||
 *   X -t'::acosh(x)' -oMWGCONF_HAS_ACOSH math.h '::acosh(2.0)'
 * X -t'std::atanh(x)' -oMWGCONF_HAS_STD_ATANH cmath 'std::atanh(0.5)' ||
 *   X -t'::atanh(x)' -oMWGCONF_HAS_ATANH math.h '::atanh(0.5)'
 */

namespace mwg {
namespace stdm {
#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
  using ::std::sinh;
  using ::std::cosh;
  using ::std::tanh;
#endif

#if !defined(MWGCONF_HAS_STD_ASINH)
# ifdef MWGCONF_HAS_ASINH
  using ::asinh;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type asinh(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return std::log((R) value + std::sqrt((R) value * (R) value + R(1.0)));
  }
  static inline float asinhf(float value) {return asinh(value);}
  static inline long double asinhl(long double value) {return asinh(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::asinh;
#endif

#if !defined(MWGCONF_HAS_STD_ACOSH)
# ifdef MWGCONF_HAS_ACOSH
  using ::acosh;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type acosh(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return std::log((R) value + std::sqrt((R) value * (R) value - R(1.0)));
  }
  static inline float acoshf(float value) {return acosh(value);}
  static inline long double acoshl(long double value) {return acosh(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::acosh;
#endif

#if !defined(MWGCONF_HAS_STD_ATANH)
# ifdef MWGCONF_HAS_ATANH
  using ::atanh;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type atanh(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return R(0.5) * std::log((R(1.0) + (R) value) / (R(1.0) - (R) value));
  }
  static inline float atanhf(float value) {return atanh(value);}
  static inline long double atanhl(long double value) {return atanh(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::atanh;
#endif
}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.6] Exponential and logarithmic functions
//
//-----------------------------------------------------------------------------
/*?mconf
 * X -t'std::exp2(x)' -oMWGCONF_HAS_STD_EXP2 cmath 'std::exp2(2.0)' ||
 *   X -t'::exp2(x)' -oMWGCONF_HAS_EXP2 math.h '::exp2(2.0)'
 * X -t'std::expm1(x)' -oMWGCONF_HAS_STD_EXPM1 cmath 'std::expm1(2.0)' ||
 *   X -t'::expm1(x)' -oMWGCONF_HAS_EXPM1 math.h '::expm1(2.0)'
 * X -t'std::log2(x)' -oMWGCONF_HAS_STD_LOG2 cmath 'std::log2(2.0)' ||
 *   X -t'::log2(x)' -oMWGCONF_HAS_LOG2 math.h '::log2(2.0)'
 * X -t'std::log1p(x)' -oMWGCONF_HAS_STD_LOG1P cmath 'std::log1p(2.0)' ||
 *   X -t'::log1p(x)' -oMWGCONF_HAS_LOG1P math.h '::log1p(2.0)'
 */

namespace mwg {
namespace stdm {
#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
  using ::std::exp;
  using ::std::log;
  using ::std::log10;
  using ::std::frexp;
  using ::std::ldexp;
  using ::std::modf;
#endif

#if !defined(MWGCONF_HAS_STD_EXP2)
# ifdef MWGCONF_HAS_EXP2
  using ::exp2;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type exp2(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return std::pow(R(2.0), (R) value);
  }
  static inline float exp2f(float value) {return exp2(value);}
  static inline long double exp2l(long double value) {return exp2(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::exp2;
#endif

#if !defined(MWGCONF_HAS_STD_EXPM1)
# ifdef MWGCONF_HAS_EXPM1
  using ::expm1;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type expm1(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    R const _value = value;
    if (std::abs(_value) < 1e-4)
      return (((1.0 / 24.0 * _value + 1.0 / 6.0) * _value + 0.5) * _value + 1.0) * _value;
    else
      return std::exp(_value) - R(1.0);
  }
  static inline float expm1f(float value) {return expm1(value);}
  static inline long double expm1l(long double value) {return expm1(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::expm1;
#endif

#if !defined(MWGCONF_HAS_STD_LOG2)
# ifdef MWGCONF_HAS_LOG2
  using ::log2;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type log2(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return R(M_LOG2E) * std::log((R) value);
  }
  static inline float log2f(float value) {return log2(value);}
  static inline long double log2l(long double value) {return log2(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::log2;
#endif

#if !defined(MWGCONF_HAS_STD_LOG1P)
# ifdef MWGCONF_HAS_LOG1P
  using ::log1p;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type log1p(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    R const _value = value;
    if (std::abs(_value) < 1e-4)
      return (((-1.0 / 4.0 * _value + 1.0 / 3.0) * _value - 0.5) * _value + 1.0) * _value;
    else
      return std::log(R(1.0) + _value);
  }
  static inline float log1pf(float value) {return log1p(value);}
  static inline long double log1pl(long double value) {return log1p(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::log1p;
#endif

#pragma%x begin_test
  void test() {
    double const a = mwg::stdm::exp2(1e-5);
    double const b = mwg::stdm::expm1(1e-5);
    double const c = mwg::stdm::log2(1e-5);
    double const d = mwg::stdm::log1p(1e-5);

    mwg_unused(a);
    mwg_unused(b);
    mwg_unused(c);
    mwg_unused(d);
  }
#pragma%x end_test
}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.7] Power and absolute-value functions
//
//-----------------------------------------------------------------------------
/*?mconf
 * X -t'std::cbrt(x)' -oMWGCONF_HAS_STD_CBRT cmath 'std::cbrt(2.0)' ||
 *   X -t'::cbrt(x)' -oMWGCONF_HAS_CBRT math.h '::cbrt(2.0)'
 * X -t'std::hypot(x)' -oMWGCONF_HAS_STD_HYPOT cmath 'std::hypot(1.0, 2.0)' ||
 *   X -t'::hypot(x)' -oMWGCONF_HAS_HYPOT math.h '::hypot(1.0, 2.0)'
 */

namespace mwg {
namespace stdm {

#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
  using ::std::abs;
  using ::std::fabs;
  using ::std::pow;
  using ::std::sqrt;
#endif

#if !defined(MWGCONF_HAS_STD_CBRT)
# ifdef MWGCONF_HAS_CBRT
  using ::cbrt;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type cbrt(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    R const result = std::pow(std::abs((R) value), R(1.0 / 3.0));
    return value < 0? -result: result;
  }
  static inline float cbrtf(float value) {return cbrt(value);}
  static inline long double cbrtl(long double value) {return cbrt(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::cbrt;
#endif

#if !defined(MWGCONF_HAS_STD_HYPOT)
# ifdef MWGCONF_HAS_HYPOT
  using ::hypot;
# else
  template<typename T, typename U>
  typename cmath_detail::overload<T, U>::type hypot(T x, U y) {
    typedef typename cmath_detail::overload<T, U>::type R;
    R const x_ = std::abs((R) x), y_ = std::abs((R) y);
    if (x_ == 0.0 && y_ == 0.0)
      return 0.0;
    else if (x_ < y_)
      return y_ * std::sqrt(1.0 + (x_ / y_) * (x_ / y_));
    else
      return x_ * std::sqrt(1.0 + (y_ / x_) * (y_ / x_));
  }
  static inline float hypotf(float lhs, float rhs) {return hypot(lhs, rhs);}
  static inline long double hypotl(long double lhs, long double rhs) {return hypot(lhs, rhs);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::hypot;
#endif

}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//  extended basic functions
//=============================================================================

namespace mwg {
namespace stdm {

  // C99 Features
  /*?mconf
   * X -t'std::trunc(x)' -oMWGCONF_HAS_STD_TRUNC cmath 'std::trunc(0.5)' ||
   *   X -t'::trunc(x)' -oMWGCONF_HAS_TRUNC math.h '::trunc(0.5)'
   * X -t'std::round(x)' -oMWGCONF_HAS_STD_ROUND cmath 'std::round(0.5)' ||
   *   X -t'::round(x)' -oMWGCONF_HAS_ROUND math.h '::round(0.5)'
   *
   * # 何と gcc-2.95 ではそもそも同じ arity の SFINAE 関数を複数定義できない?
   * # → そもそも SFINAE は gcc 3.0 以降でしか有効でないようだ。
   * S -t'"sfinae"' 'STD_SFINAE' '' '
   * template<typename T> struct is_a{};
   * template<typename T> struct is_b{typedef int type;};
   * template<typename T> void foo(T const&,typename is_a<T>::type = 0){}
   * template<typename T> void foo(T const&,typename is_b<T>::type = 0){}
   * int main(){foo(1);}
   * '
   */

#if !defined(MWGCONF_HAS_STD_TRUNC)
# ifdef MWGCONF_HAS_TRUNC
  using ::trunc;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type trunc(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return (R) value >= 0? std::floor((R) value): std::ceil((R) value);
  }
  static inline float truncf(float value) {return trunc(value);}
  static inline long double truncl(long double value) {return trunc(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::trunc;
#endif

#if !defined(MWGCONF_HAS_STD_ROUND)
# ifndef MWGCONF_HAS_ROUND
  using ::round;
# else
  template<typename T>
  typename cmath_detail::overload<T>::type round(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return (R) value >= 0? std::floor((R) value + R(0.5)): std::ceil((R) value - R(0.5));
  }
  static inline float roundf(float value) {return round(value);}
  static inline long double roundl(long double value) {return round(value);}
# endif

  template<typename T>
  long lround(T value) {return round(value);}
  static inline long lroundf(float value) {return (long) round(value);}
  static inline long lroundl(long double value) {return (long) round(value);}

# ifdef MWGCONF_HAS_LONGLONG
  template<typename T>
  long long llround(T value) {return round(value);}
  static inline long long llroundf(float value) {return (long long) round(value);}
  static inline long long llroundl(long double value) {return (long long) round(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::round;
#endif

}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
#endif /* end of MWG_STDM_CMATH */
#pragma%x begin_check
int main(){
  managed_test::run_tests();

  mwg_check(mwg::stdm::asinh(0.0) == 0.0);
  mwg_check(mwg::stdm::acosh(1.0) == 0.0);
  mwg_check(mwg::stdm::atanh(0.0) == 0.0);

  return 0;
}
#pragma%x end_check
