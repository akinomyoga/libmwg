
* clang -std=c++0x から GCC 4.4.7 libstdc++ を使えない。これに対する対処は諦める。

------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2015-09-18

* xprintf を移植

* mwg/std/type_traits

  TR1 Header からの対応がかなり不完全になっている。
  現在では TR1 Header がある場合の実装と、何もない場合の実装を別々に (ファイルの前半と後半に) 記述している。
  各クラスについて TR1 Header があるかどうかで実装を切り替える様にしないと見通しが悪い。
  更に、現在どの機能が実装されていてどの機能が実装されていないのかも分かりにくい。
  これらについても整理しながら実装を行う必要がある。

  →整理を実行した。

  ToDo:
    is_null_pointer for C++11
    aligned_storage, aligned_union
    is_class, is_union
    is_compound, is_fundamental, is_object
    max_align_t     in <cstddef>

    underlying_type result_of

2015-06-21

* std::tr1

  using namespace std;
  using namespace std::tr1;

  としていると両方で定義されている物を stdm:: を介して使おうとするとエラーになるということがわかった。

* mwg/bio/tape.h

  サポートされていない操作をした時の動作について整理しておいた方が良い。
  現状だと例外を投げたり投げなかったりまちまちである。
  目安としては以下のようにしたらどうだろう?
  - tape を初期化した当初からその操作を実行できないことが明らかである場合は例外を投げる
  - tape の現在の読み取り状況などの都合によって実行できなかった場合は戻り値で返す
  そうすると現状の実装ではだいたい例外を投げるのが正しい動作ということになる。

2015-06-19

* とりあえずビルドのシステムの構造に関しては現状で問題無いと思う
  現状の構造について再度まとめることにする。

  src/Makefile.pp の書き方:

    BASE=..
    source $(BASE)/mmake/
    #%x prologue
    #%x epilogue

    ■ToDo もっと説明を追加する


* 自動で mmake 初期化を実行する仕組みを作る
  (mcxx に統合して mcxx +project init などとする手もある)

* test の方法についてより様々な種類のものを提供できるようにする?
  - コンパイルテスト・実行テスト・出力テスト
  - コンパイルが失敗する事を期待するテスト
  - テストを簡単に生成する mwg_pp マクロ?

* experimental な物をいつ統合するのかについて

  exprimental な実装や他のプログラムで作成したライブラリをどの様に統合するかのルールは作っておいた方がよい様に思う。
  例えば、複数のプロジェクトで同じコードを共有したくなった時に統合を行うとする?

  しかし、統合対象となるサブライブラリの中に更に experimental で余り使われていない
  機能 (であるが実装の根幹に入り込んでしまっている) 様な物がある場合に、
  その部分をどう扱うかは微妙である。例えば tape.h から使われている
  static_flags や iprint, yield, enumerable などの物のことである。
  tape.h 自体は様々なところから利用するので便利である。
  しかし static_flags や iprint, yield, enumerable は tape.h からしか使われていない。
  つまり余り interface としても洗練されていないし本当に必要なものだったのかというのも疑問である。


2015-06-15

* CXXCFG 毎の設定 #20150620.CXXCFG

  設定切り替えに関しては CXXCFG を用いて切り替える。
  CXXCFG を用いて切り替える際にどこにそれを記述するのかについて考える必要がある。
  CXXCFG に対応するファイルを作成してその中に設定を書き込むという方法もある。
  あるいは、どこかに hoge.mk の中に CXXCFG 毎の条件分岐を記述するという手も存在する。

  →$BASE/config.mk に設定を書き込むことにした。
    config ごとにファイルを作成してそこに書き込むのは面倒すぎる。管理が面倒である。
    再利用したい設定に関しては独立したファイルとしてコピーできる様にすると便利という考え方もあるが、
    その様な複雑な設定(?)は限られていると思われるし、
    複雑といっても程度があるので取り敢えずは、
    ファイルとしてではなく設定の文字列をコピーして管理する方針で行く。

* 環境変数 CXX CC FLAGS 等の情報をどのように取り入れるべきか?

  CXXCFG に関して → [[CXXCFG 毎の設定>#20150620.CXXCFG]]

  設定の取り込みに関しては少し考える必要がある。
  基本的に通常の場合と似たような振る舞いにするのが分かりやすい。
  しかし、環境変数によって取り扱い方が異なるのでそれについて確認しておく。
  1 先ず CXX CC FLAGS CXXFLAGS 等の情報は通常は ./configure の際に指定する。
    ./configure よりも後に値を変更したりしてもコンパイルには影響されない。
    そして g++ 等の呼び出しの際に直接に引数に指定することで適用される。
  2 一方で CPLUS_INCLUDE_PATH LIBRARY_PATH 等はコンパイルの実行時の情報が参照される。
    これらは通常は ./configure & make では設定されないし消去することもない。
    つまりビルドシステムはこれらの環境変数に対しては透過的である。

  現状の管理方法についても確認しておく。
  これらの環境変数の設定に関しては現在はコンパイラ側、つまり mcxx 側で勝手に制御している。
  mcxx にコンパイラを登録する時に CXX CC FLAGS および CPLUS_INCLUDE_PATH 等も取り込む。
  そして *_PATH に関しては、コンパイラを登録した時の PATH を勝手に追加する。
  また、FLAGS 等の値に関してはコンパイラを登録した時の値で上書きする (?)。
  実際に使っているかどうかについては疑問である。
  というのも mcxx には source $(mcxx +param config) 的な
  方法で環境変数をロードする仕組みもあるからである。

  ToDo:
  - mcxx の config as env-source files の仕組みは廃止する
    本当に廃止しても大丈夫か? これは g++/cl 等と直接入力して使う方法を封じることになる。
    特に cl に特別な引数を渡したいときに困るのではないだろうか。
  - mcxx の CC・CXX・CFLAGS・CXXFLAGS・LDFLAGS・FLAGS 取り込みは行う。
  - mcxx のCPLUS_INCLUDE_PATH・C_INCLUDE_PATH・LIBRARY_PATHに関しては限定的にする。明示されなければ追加しない。
  - mcxx に上記のパラメータの一覧を表示する仕組みを作る。

2015-05-15

* 識別子の衝突の問題

  同じ識別子に複数の異なるテストが割り当てられても気付かない可能性がある。
  そうすると片方のテスト結果がもう片方の結果を上書きしてしまう事になり予期しない結果になる。
  一つの解決方法は mwg_config.h の結合時に識別子の重複がないか確認する事である。

  しかし、重複する識別子を完全に禁止した場合、
  異なるファイルに同じテスト内容が存在する場合に不本意な結果になる。
  例えば、同じテスト内容に異なる (例えばファイル名をプレフィックスとした様な) 識別子をつけるという手もある。
  しかし、折角同じテストであるのだから統合したい。テスト内容を修正する場合にもそちらの方が都合が良いだろう。
  結局、複数のファイルの間で共有する可能性のあるテストに関しては今迄通り外部のファイルに記述するというのが現実的だろうか。

* check の依存性の問題

  大量の include を含めると Makefile の読込が遅くなるのではないか、という懸念。
  -include ....mk を纏めるという事

  当初は Makefile がこれ以上重くならない為に check の依存性まで含めるのを躊躇していたが、
  Makefile が重くなる原因が判明し、これが問題にならない様であるという事が分かったので余り気にしないでよい。


------------------------------------------------------------------------------
  ChangeLog
------------------------------------------------------------------------------



------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

* clang -std=c++0x から GCC 4.4.7 libstdc++ を使った時の問題

  std::move が壊れているために、それを使っている std::swap や std::vector などまでも
  全てエラーに成ってしまうので救いようがない。

  また type_info が前方宣言されていないのに typeinfo の先頭で使おうとしているので
  それでもエラーに成ってしまう。これについては一応 type_info を自分で前方宣言すれば良いが…。

  これはサポートの対象外とすることにする(そもそもヘッダファイルを include しようとするだけで死ぬ)。
  workaround のために書いたコードは削除することにする。以下に残しておく。

  // from mwg/defs.h
  //------------------------------------------------------------------------------
  // clang -std=c++0x: #include <typeinfo> (gcc 4.4.7 libstdc++) がエラーになる。
  // 内部で更に呼び出したヘッダで type_info* を使っているため。
  //?mconf X -t'"std::type_info sane?"' -oMWGCONF_STD_TYPE_INFO_SANE typeinfo 'const std::type_info* ptr=0;'
  #if !defined(MWGCONF_STD_TYPE_INFO_SANE)
  namespace std{
    class type_info;
    class bad_cast;
    class bad_typeid;
  }
  #endif

  // from mwg/std/utlility
  //-----------------------------------------------------------------------------
  // clang -std=c++0x: gcc 4.4.7 libstdc++ bug workaround
  // c.f. http://lists.cs.uiuc.edu/pipermail/cfe-dev/2011-February/013216.html
  //?mconf X -t'"std::move sane?"' -oMWGCONF_STD_MOVE_SANE utlility 'int j=std::move(i)';
  # ifndef MWGCONF_STD_MOVE_SANE
  #  include <type_traits>
  namespace mwg{
  namespace stdm{
    template<typename T>
    T& move(const T& value){return const_cast<T&>(value);}
    template<typename T>
    typename enable_if<!is_const<T>::value,T&>::type
    move(T& value){return value;}

    template<typename T>
    void swap(T& a,T& b){
      T tmp(move(a));
      a=move(b);
      b=move(tmp);
    }
  }
  }
  # endif

2015-04-28

*目標: 新しいビルド管理システム

  > ***ソースコード埋め込み指定
  > 
  > 以下に挙げるような様々な機能を\
  > ソースコード中に埋め込んだ指定から呼び出せる様にする。
  > - configure script (mcxx)
  > - document (lwiki)
  > - preprocess (mwg_pp.awk)
  > - check (mwg_pp.awk sub)
  > 
  > 処理の手順
  > 1. mwg_pp.awk による処理
  > 2. perl による処理
  >    (lwiki 部分なども mwg_pp.txt によって生成したくなるだろうから)
  > 
  > ***出力に関して
  > 
  > - 出力は別のディレクトリに対して行う様にしたい
  > - ソースファイル、ヘッダファイルの文字コード変換に対応する。
  >   original の文字コードも選択できる様にする。
  > - コンパイラの種類毎の出力に対応する。
  >   コンパイラのオプション毎の出力にも対応する。
  >   mcxx の機構を使用している場合 CXXFLAGS CFLAGS 等の設定に対応した設定を行うのが難しい。
  > 
  > out/src.charset
  > out/cxxprefix.option/obj
  > out/cxxprefix.option/lib
  > out/cxxprefix.option/include
  > 
  > ***その他の機能
  > wx-config 的なコマンドで cxxflags 等の必要な設定を呼び出す方法も提供する
  > 簡単なプロジェクトの初期化スクリプトも用意する
  > インストール・アンインストールの対応

  取り敢えず試しに実装を行ってみる。

  このビルド管理システムでは src に置いたソースコードを起点として、
  out ディレクトリに加工したソースコード・オブジェクトファイル・結果ファイルを出力する。

  現在以下のシーケンスが用意されている。

    src/dir/file.cpp

    → mwg_pp.awk による前処理

    out/src.utf-8/dir/file.cpp

    → make_extract.pl による lwiki, mconf の抽出

    out/src.utf-8/dir%file_cpp.lwiki
    out/src.utf-8/dir%file_cpp.mconf


2015-05-15

* 問題点: Makefile 起動が遅い

  -そもそもパス区切に % を用いているのが良くない?
    % はワイルドカードである。パターンマッチングが実行されている。
    →ファイル名中の % を + に変更してみたがそんなに時間は変わらない気がする。

  -原因が分からないので問題になっている Makefile を少しずつ弄って確かめる
   先ずは all に登録されている prerequisites を空にする。
   1.374s → 1.092s まで下がった。依存性の確認に 220ms かかっている事になる。
   次に生成コマンドを全て削除する。1.092 → 1.088 全然変わらない。誤差の範囲内である。
   つまり生成コマンドの登録はゼロコストである。
   今度は hoge+= となっている物を全て削除する。
   1.090s → 0.819s になった。72項目で 0.270ms かかっていた事になる。
   変数の = を := に変えたら旧に滅茶苦茶速くなった…。
   どうやら CPPPREFIX=$(shell $(MWGCXX) +prefix) が登場した回数だけ評価されていた事による様だ…。

  結局、原因は $(shell ) の展開が毎回行われていた事に依る物と分かった。

* 問題点: 各ファイルの config 条件と更新時刻

  現在は config 関係を以下のように処理している。
  1 各ファイルに config の条件を定義してファイルが更新される度にテストを実行する。
  2 全ファイルの結果を一つのファイル mwg_config.h に結合して出力する

  依存関係の問題

  しかしこの様にすると問題なのは、全てのファイルが
  基本的に mwg_config.h を include しているという事である。
  ファイルの依存性はコンパイラオプションの -M で追跡しているので、
  mwg_config.h を更新すれば全てをコンパイルし直す羽目になる。
  つまり、全てのファイルが他の全てのファイルに依存しているという状態になるという事である。

  a 解決方法の一つは、各ファイル毎に config ファイルを生成するという事である。
    しかしこれは煩雑になる。特に最終的な結果として install する場合に沢山の環境依存ヘッダがあるのは気になる。

  b 或いは、設計中は各ファイル毎の config を使うとして install する時にはそれらを結合した物を使うという手もある。
    でも恐らく今迄の自分の使い方だと、最終的に install する段階よりも書きながら使う場合の方が多い。
    できれば普段使っている段階でも config が一つに纏まった状態で取り扱いたい。

  c もう一つの方法は出力する config の内容を記録しておいて内容に変化があった場合にのみ、
    mwg_config.h を更新するという方法である。しかしこの方法も微妙である。
    config 指定さえ弄らなければ全体をコンパイルし直す事にはならないが、
    config 指定を弄った時に結局全体のコンパイルをやり直さなければならなくなる。
    これは従来の autotools でも同じ事であるが、今回はファイル毎に指定できるようにしたので
    config 指定の依存関係が明らかであり、この事を利用して必要な物だけコンパイルする様にしたい。

  d gmake の機能で良さそうな物はないだろうか。
    どうやら A: B | C とすると C の存在だけ確認をしてタイムスタンプの比較は行わない様だ。
    然し乍ら、上記の様にルールを書き換える為には g++ -M で出力した依存性ファイルを書き換える必要がある。
    (例えば sed -i '
      s/\(^\|[[:space:]]\{1,\})mwg_config.h\([[:space:]]\{1,\}\|$\)//
      s/[^\]$/& | mwg_config.h/
    ' x.dep)
    実行するコマンドが増加するので余りこれを採用したくはない。
    また Makefile の記述が複雑になる。特にユーザ側で特別に何か記述したい時に問題になる。
    が取り敢えず第一候補である。

  e touch mwg_config.h
    これで mwg_config.h の日付が更新前と比べて変化しないようにする…。
    余り良い方法ではないかも知れないがコスト的にこれが一番楽である。

* 疑問: Makefile: タイムスタンプを見ない依存関係?

  例えば、A: X としたいが
  - X が存在しない時は X を生成するコマンドを実行し A 更新も行う。
  - X が存在する時はそのファイル時刻に関係なく A 更新は行わない。

  .SECONDARY: X 等とすると
  - A が(X 以外の依存関係に対して)最新で、X が存在しなければ何もしない
  - X が存在する時はそのファイル時刻を見て必要が有れば A 更新を行う
  の様になる。似たような特別ターゲットが存在するのでは? → 探したがない気がする。
  ファイル更新時刻を無視するという機能自体が存在しない様に思われる。

  https://lists.gnu.org/archive/html/help-gnu-utils/2007-08/msg00016.html
  にも似たような質問が投稿されている。
  一つの解決方法は、A 生成の中で X の存在の確認をして X の生成も行うという物。
  もう一つの解決方法は、A の依存関係のリストを X の存在・非存在で切り替わる様に書くという物。
  後者は興味深い方法ではあるが今回の場合には使えない。

  https://lists.gnu.org/archive/html/help-gnu-utils/2006-02/msg00034.html
  に似たような質問が投稿されている。
  order-only prerequisites として登録しろという返答が為されている。
  A: | X
  # # でもこれだと X も要求しなければ X を生成するコマンド自体が実行されないのではないか。。
  # と思ったが、Makefile の解説を読んだ所 X が存在しなければちゃんと X 生成も行われる様だ。
  # 但し、X の生成が行われた後に A の更新は実行されない。。

  まとめ:

  A: | X の場合
  - Xが存在しない場合: X が生成される。Aの更新は要求しない。
  - Xが存在して A よりも新しい場合、A は更新されない。

  .SECONDARY: X
  A: | X の場合
  - Xが存在しない場合: Aが最新でない場合 X を更新してから A を更新する。
  - Xが存在して A よりも新しい場合、何も起きない。

  .SECONDARY: X
  X:
  A: | X の場合
  - Xが存在しない場合: 何もしない
  - Xが存在して A よりも新しい場合、A を更新する。

* Makefile: 複数のファイルを生成するコマンドの管理の方法

  複数のコマンドを生成する場合

  > [[GNU Makefile rule generating a few targets from a single source file - Stack Overflow>http://stackoverflow.com/questions/2973445/gnu-makefile-rule-generating-a-few-targets-from-a-single-source-file]]
  > 
  > | B1 B2: A1
  > | 	command B1 B2 < A1
  > 
  > 上記の様にするとコマンドが 2 回実行されて無駄である。
  > その上 -j4 などで並列化するとコマンドが同時に起動されて出力が変になる。
  > 以下のようにする解決方法が提示されている。
  > 
  > | B1: A1
  > |   command B1 B2 < A1
  > | B2: B1 A1
  > 
  > 上の様にしていると、B1 の方が後に生成された場合に毎回 B2 を更新しようとするのでは?
  > と思ったが、実際に試してみると Nothing to be done となる。
  > つまり、更新用のコマンドが設定されていない場合にはファイルが存在する事だけを確認する様だ。
  >
  > また、A1 が更新された時に B2 が更新されないのではないかという懸念がある。
  > →試してみたら更新されないではないか。。
  > というか B1 A1 が存在しているだけで B2 も完了している様に見受けられる。
  > つまりこの方法は B1 が最新版であれば必ず B2 も最新版である事が保証されている場合にのみ有効である。
  >

  もっと複雑な場合はどうするか?

  現在の状況は以下の様な物である。
  - B1 も B2 も同時に生成される。
  - B1 は環境変数依存のファイル名である。B2 は環境変数に依存しない。
  - 環境変数が変化した時に B2 は既に最新版だが、B1 は未だ生成されていない(or最新版でない)という状況がある。
  - B2 に依存するルールが大量にあるのでできるだけ B2 は更新したくない。

  更新が発生するのは以下の状況のどちらかである。
  +環境変数が変更された事により B1 の更新が必要になる。
  +A1 が変更された事により B1 と B2 の両方の更新が必要になる。

  何れにしても B1 は必ず更新されるのであるから、今回の場合には
  | B2: B1
  等としておけば良いのではないだろうか。そして B1 のルールの方では
  | B1: A1
  |   command B1 B2.tmp < A1
  |   [[ B2 -nt A1 ]] || mv B2.tmp B1.tmp
  等のようにする。

  # B1: A1
  #   command B1 /dev/null < A1
  # B2: A1
  #   command /dev/null B2 < A1
  # 
  # B1: A1
  #   command B1.tmp B2.tmp < A1
  #   [[ B1 -nt A1 ]] || mv B1.tmp B1
  #   -rm -rf B1.tmp B2.tmp
  # B2: A1
  #   command B1.tmp B2.tmp < A1
  #   [[ B2 -nt A1 ]] || mv B2.tmp B2
  #   -rm -rf B1.tmp B2.tmp

