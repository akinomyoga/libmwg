

*2015-04-28

**目標: 新しいビルド管理システム

> ***ソースコード埋め込み指定
> 
> 以下に挙げるような様々な機能を\
> ソースコード中に埋め込んだ指定から呼び出せる様にする。
> - configure script (mcxx)
> - document (lwiki)
> - preprocess (mwg_pp.awk)
> - check (mwg_pp.awk sub)
> 
> 処理の手順
> 1. mwg_pp.awk による処理
> 2. perl による処理
>    (lwiki 部分なども mwg_pp.txt によって生成したくなるだろうから)
> 
> ***出力に関して
> 
> - 出力は別のディレクトリに対して行う様にしたい
> - ソースファイル、ヘッダファイルの文字コード変換に対応する。
>   original の文字コードも選択できる様にする。
> - コンパイラの種類毎の出力に対応する。
>   コンパイラのオプション毎の出力にも対応する。
>   mcxx の機構を使用している場合 CXXFLAGS CFLAGS 等の設定に対応した設定を行うのが難しい。
> 
> out/src.charset
> out/cxxprefix.option/obj
> out/cxxprefix.option/lib
> out/cxxprefix.option/include
> 
> ***その他の機能
> wx-config 的なコマンドで cxxflags 等の必要な設定を呼び出す方法も提供する
> 簡単なプロジェクトの初期化スクリプトも用意する
> インストール・アンインストールの対応

取り敢えず試しに実装を行ってみる。


このビルド管理システムでは src に置いたソースコードを起点として、
out ディレクトリに加工したソースコード・オブジェクトファイル・結果ファイルを出力する。


現在以下のシーケンスが用意されている。

  src/dir/file.cpp

  → mwg_pp.awk による前処理

  out/src.utf-8/dir/file.cpp

  → make_extract.pl による lwiki, mconf の抽出

  out/src.utf-8/dir%file_cpp.lwiki
  out/src.utf-8/dir%file_cpp.mconf

------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2015-05-15

* 識別子の衝突の問題

  同じ識別子に複数の異なるテストが割り当てられても気付かない可能性がある。
  そうすると片方のテスト結果がもう片方の結果を上書きしてしまう事になり予期しない結果になる。
  一つの解決方法は mwg_config.h の結合時に識別子の重複がないか確認する事である。

  しかし、重複する識別子を完全に禁止した場合、
  異なるファイルに同じテスト内容が存在する場合に不本意な結果になる。
  例えば、同じテスト内容に異なる (例えばファイル名をプレフィックスとした様な) 識別子をつけるという手もある。
  しかし、折角同じテストであるのだから統合したい。テスト内容を修正する場合にもそちらの方が都合が良いだろう。
  結局、複数のファイルの間で共有する可能性のあるテストに関しては今迄通り外部のファイルに記述するというのが現実的だろうか。

* check の依存性の問題

  大量の include を含めると Makefile の読込が遅くなるのではないか、という懸念。
  -include ....mk を纏めるという事

  当初は Makefile がこれ以上重くならない為に check の依存性まで含めるのを躊躇していたが、
  Makefile が重くなる原因が判明し、これが問題にならない様であるという事が分かったので余り気にしないでよい。


------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------


2015-05-15

* 問題点: Makefile 起動が遅い

  -そもそもパス区切に % を用いているのが良くない?
    % はワイルドカードである。パターンマッチングが実行されている。
    →ファイル名中の % を + に変更してみたがそんなに時間は変わらない気がする。

  -原因が分からないので問題になっている Makefile を少しずつ弄って確かめる
   先ずは all に登録されている prerequisites を空にする。
   1.374s → 1.092s まで下がった。依存性の確認に 220ms かかっている事になる。
   次に生成コマンドを全て削除する。1.092 → 1.088 全然変わらない。誤差の範囲内である。
   つまり生成コマンドの登録はゼロコストである。
   今度は hoge+= となっている物を全て削除する。
   1.090s → 0.819s になった。72項目で 0.270ms かかっていた事になる。
   変数の = を := に変えたら旧に滅茶苦茶速くなった…。
   どうやら CPPPREFIX=$(shell $(MWGCXX) +prefix) が登場した回数だけ評価されていた事による様だ…。

  結局、原因は $(shell ) の展開が毎回行われていた事に依る物と分かった。

* 問題点: 各ファイルの config 条件と更新時刻

  現在は config 関係を以下のように処理している。
  1 各ファイルに config の条件を定義してファイルが更新される度にテストを実行する。
  2 全ファイルの結果を一つのファイル mwg_config.h に結合して出力する

  依存関係の問題

  しかしこの様にすると問題なのは、全てのファイルが
  基本的に mwg_config.h を include しているという事である。
  ファイルの依存性はコンパイラオプションの -M で追跡しているので、
  mwg_config.h を更新すれば全てをコンパイルし直す羽目になる。
  つまり、全てのファイルが他の全てのファイルに依存しているという状態になるという事である。

  a 解決方法の一つは、各ファイル毎に config ファイルを生成するという事である。
    しかしこれは煩雑になる。特に最終的な結果として install する場合に沢山の環境依存ヘッダがあるのは気になる。

  b 或いは、設計中は各ファイル毎の config を使うとして install する時にはそれらを結合した物を使うという手もある。
    でも恐らく今迄の自分の使い方だと、最終的に install する段階よりも書きながら使う場合の方が多い。
    できれば普段使っている段階でも config が一つに纏まった状態で取り扱いたい。

  c もう一つの方法は出力する config の内容を記録しておいて内容に変化があった場合にのみ、
    mwg_config.h を更新するという方法である。しかしこの方法も微妙である。
    config 指定さえ弄らなければ全体をコンパイルし直す事にはならないが、
    config 指定を弄った時に結局全体のコンパイルをやり直さなければならなくなる。
    これは従来の autotools でも同じ事であるが、今回はファイル毎に指定できるようにしたので
    config 指定の依存関係が明らかであり、この事を利用して必要な物だけコンパイルする様にしたい。

  d gmake の機能で良さそうな物はないだろうか。
    どうやら A: B | C とすると C の存在だけ確認をしてタイムスタンプの比較は行わない様だ。
    然し乍ら、上記の様にルールを書き換える為には g++ -M で出力した依存性ファイルを書き換える必要がある。
    (例えば sed -i '
      s/\(^\|[[:space:]]\{1,\})mwg_config.h\([[:space:]]\{1,\}\|$\)//
      s/[^\]$/& | mwg_config.h/
    ' x.dep)
    実行するコマンドが増加するので余りこれを採用したくはない。
    また Makefile の記述が複雑になる。特にユーザ側で特別に何か記述したい時に問題になる。
    が取り敢えず第一候補である。

  e touch mwg_config.h
    これで mwg_config.h の日付が更新前と比べて変化しないようにする…。
    余り良い方法ではないかも知れないがコスト的にこれが一番楽である。

* 疑問: Makefile: タイムスタンプを見ない依存関係?

  例えば、A: X としたいが
  - X が存在しない時は X を生成するコマンドを実行し A 更新も行う。
  - X が存在する時はそのファイル時刻に関係なく A 更新は行わない。

  .SECONDARY: X 等とすると
  - A が(X 以外の依存関係に対して)最新で、X が存在しなければ何もしない
  - X が存在する時はそのファイル時刻を見て必要が有れば A 更新を行う
  の様になる。似たような特別ターゲットが存在するのでは? → 探したがない気がする。
  ファイル更新時刻を無視するという機能自体が存在しない様に思われる。

  https://lists.gnu.org/archive/html/help-gnu-utils/2007-08/msg00016.html
  にも似たような質問が投稿されている。
  一つの解決方法は、A 生成の中で X の存在の確認をして X の生成も行うという物。
  もう一つの解決方法は、A の依存関係のリストを X の存在・非存在で切り替わる様に書くという物。
  後者は興味深い方法ではあるが今回の場合には使えない。

  https://lists.gnu.org/archive/html/help-gnu-utils/2006-02/msg00034.html
  に似たような質問が投稿されている。
  order-only prerequisites として登録しろという返答が為されている。
  A: | X
  # # でもこれだと X も要求しなければ X を生成するコマンド自体が実行されないのではないか。。
  # と思ったが、Makefile の解説を読んだ所 X が存在しなければちゃんと X 生成も行われる様だ。
  # 但し、X の生成が行われた後に A の更新は実行されない。。

  まとめ:

  A: | X の場合
  - Xが存在しない場合: X が生成される。Aの更新は要求しない。
  - Xが存在して A よりも新しい場合、A は更新されない。

  .SECONDARY: X
  A: | X の場合
  - Xが存在しない場合: Aが最新でない場合 X を更新してから A を更新する。
  - Xが存在して A よりも新しい場合、何も起きない。

  .SECONDARY: X
  X:
  A: | X の場合
  - Xが存在しない場合: 何もしない
  - Xが存在して A よりも新しい場合、A を更新する。

* Makefile: 複数のファイルを生成するコマンドの管理の方法

  複数のコマンドを生成する場合

  > [[GNU Makefile rule generating a few targets from a single source file - Stack Overflow>http://stackoverflow.com/questions/2973445/gnu-makefile-rule-generating-a-few-targets-from-a-single-source-file]]
  > 
  > | B1 B2: A1
  > | 	command B1 B2 < A1
  > 
  > 上記の様にするとコマンドが 2 回実行されて無駄である。
  > その上 -j4 などで並列化するとコマンドが同時に起動されて出力が変になる。
  > 以下のようにする解決方法が提示されている。
  > 
  > | B1: A1
  > |   command B1 B2 < A1
  > | B2: B1 A1
  > 
  > 上の様にしていると、B1 の方が後に生成された場合に毎回 B2 を更新しようとするのでは?
  > と思ったが、実際に試してみると Nothing to be done となる。
  > つまり、更新用のコマンドが設定されていない場合にはファイルが存在する事だけを確認する様だ。
  >
  > また、A1 が更新された時に B2 が更新されないのではないかという懸念がある。
  > →試してみたら更新されないではないか。。
  > というか B1 A1 が存在しているだけで B2 も完了している様に見受けられる。
  > つまりこの方法は B1 が最新版であれば必ず B2 も最新版である事が保証されている場合にのみ有効である。
  >

  もっと複雑な場合はどうするか?

  現在の状況は以下の様な物である。
  - B1 も B2 も同時に生成される。
  - B1 は環境変数依存のファイル名である。B2 は環境変数に依存しない。
  - 環境変数が変化した時に B2 は既に最新版だが、B1 は未だ生成されていない(or最新版でない)という状況がある。
  - B2 に依存するルールが大量にあるのでできるだけ B2 は更新したくない。

  更新が発生するのは以下の状況のどちらかである。
  +環境変数が変更された事により B1 の更新が必要になる。
  +A1 が変更された事により B1 と B2 の両方の更新が必要になる。

  何れにしても B1 は必ず更新されるのであるから、今回の場合には
  | B2: B1
  等としておけば良いのではないだろうか。そして B1 のルールの方では
  | B1: A1
  |   command B1 B2.tmp < A1
  |   [[ B2 -nt A1 ]] || mv B2.tmp B1.tmp
  等のようにする。

  # B1: A1
  #   command B1 /dev/null < A1
  # B2: A1
  #   command /dev/null B2 < A1
  # 
  # B1: A1
  #   command B1.tmp B2.tmp < A1
  #   [[ B1 -nt A1 ]] || mv B1.tmp B1
  #   -rm -rf B1.tmp B2.tmp
  # B2: A1
  #   command B1.tmp B2.tmp < A1
  #   [[ B2 -nt A1 ]] || mv B2.tmp B2
  #   -rm -rf B1.tmp B2.tmp

------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

