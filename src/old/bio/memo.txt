-*- coding:utf-8 -*-

■バイナリ列編集の抽象化

□ Idea1
・どの様に抽象化するべきか?
　先ず、色々なデータへの inherent なアクセス方法を分類する。

・バイナリ列への編集の方法
　□ランダムアクセス
　　位置とバイナリを指定してコピー - ディスクなど
　　  →read(buff,range)
　　  →write(buff,range)
　　直接アクセス                   - メモリ上のポインタ
　　                               - メモリ上にロックしたデータ
　　  →直接参照・ポインタで操作
　□シーケンシャルアクセス
　　Seek 不可能                    - プログラムの出力など
　　Seek 可能                      - FILE*
　　  →read(buff,len)
　　  →write(buff,len)
　　  →seek(pos)

・三種類のデータインターフェイスを定義し、
　簡単な物に対して実装してみる。

・三種類のデータインターフェイスに対し、
　それぞれ三種類のインターフェイスアダプタを実装する。
　1. bstream_disk_driver : disk ランダムアクセス
　2. bstream_tape_driver : tape シーケンシャルアクセス
　3. bstream_ram_driver  : ランダムアクセスメモリ (直接)

　disk.tape の RAM 的インターフェイスでは
　メモリ上へのマッピングを必要とする。
　一般的には、メモリ上に lock して、unlock 時に書き戻すようにする。

・先ず直接アクセスについて実装を行う

□Idea2
　Idea1 で少し実装してみた所、分かった事・思った事
・バイナリのアクセスのパターンには三種類有る
　1.<テープ的アクセス> "tape"
　　ストリームで書込・読取・場合により seek
　　
　　・シーケンシャルなファイルアクセス
　　・ネットワーク・通信
　　
　2.<ディスク的アクセス?> "disk"
　　メソッドを通してちまちま読んだり書いたり
　　
　　・ファイルへのランダムアクセス
　　・他のプロセスのメモリ領域
　　
　3.<キャッシュ付メモリ的?アクセス> "view"
　　特定のバッファに lock (read) して編集し、
　  終わったら unlock (write back) する。

　　・メモリを直接触る
　　　lock/unlock を "何もしない" とすればこれに含められる。
　　・MemoryMappedFile
　　・VRAM
　　・その他色々の編集
　　・好きな矩形・ピクセル形式でのビットマップの編集
　　　← これは違うかも。その儘のバイナリを編集するというより
　　　　 表現を変えた編集を提供している。

・それぞれの名前を itape/idisk/iview とする事にする。
　→ram_driver は view に改名
　
　[予定]
　0. itape/idisk/iview のインターフェイスを決定する。
　　一応現段階でのインターフェイスは何となく決定した。
　　これは実際に実装しながら最も良い物を模索していきたい。
　
　1. 色々な物に対するインターフェイスの実装
　　・メモリ iview -> 一応完
　　・FILE itape
　　・iview itape アダプタ (キャッシュ機構を実装するか?)
　　・iview idisk アダプタ (キャッシュ機構を実装するか?)
　　・itape idisk アダプタ (can_seek 時)
　　・itape iview アダプタ (can_seek 時)
　　・idisk itape アダプタ
　　・idisk iview アダプタ
　
　3. StreamAccessor の実装
　　型毎にバイナリで書き込む場合、
　　文字列として書き込む場合 (これは std::ostream を利用する)、
　　を用意する。



