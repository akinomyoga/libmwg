// -*- mode: c++; coding: utf-8 -*-
#pragma once
#ifndef MWG_STDM_CMATH
#define MWG_STDM_CMATH
#ifdef _MSC_VER
# define _USE_MATH_DEFINES
#endif
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
#include <math.h>
#include <cmath>
#include <cfloat>
#include <climits>
#include <mwg/defs.h>
#include <mwg/std/type_traits>

#pragma%include "../impl/ManagedTest.pp"
#pragma%x begin_check
#include <cstdio>
#include <mwg/std/cmath>
#include <mwg/except.h>
#pragma%x end_check

// ToDo: nan nanf nanl
// ToDo: remainder remquo fma fmax fmin fdim
// ToDo: erf erfc tgamma lgamma
// ToDo: 古くからある関数や using した関数でも arithmetic overloads を追加する?

namespace mwg {
namespace stdm {
namespace cmath_detail {
  template<typename T, typename U = T>
  struct overload: mwg::stdm::enable_if<
    (mwg::stdm::is_arithmetic<T>::value && mwg::stdm::is_arithmetic<U>::value),
    typename mwg::stdm::conditional<
      (mwg::stdm::is_same<T, long double>::value || mwg::stdm::is_same<U, long double>::value), long double,
      typename mwg::stdm::conditional<
        (mwg::stdm::is_same<T, float>::value && mwg::stdm::is_same<U, float>::value), float,
        double>::type>::type>
  {
    static const bool value = mwg::stdm::is_arithmetic<T>::value && mwg::stdm::is_arithmetic<U>::value;
    template<typename R> struct enable: mwg::stdm::enable_if<value, R> {};
  };
}
}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [POSIX math.h XSI]
//
//-----------------------------------------------------------------------------
//
// Math constants
//   できるだけ _USE_MATH_DEFINES や _GNU_SOURCE を define して使っているが、
//   include の順序の都合で結局 define されないという事も多くあるのでここで定義する。
//   値は https://msdn.microsoft.com/en-us/library/4hwaceh6(v=vs.100).aspx から取った。
//
//
#ifndef M_E
# define M_E        2.71828182845904523536e+000
#endif
#ifndef M_LOG2E
# define M_LOG2E    1.44269504088896340736e+000
#endif
#ifndef M_LOG10E
# define M_LOG10E   4.34294481903251827651e-001
#endif
#ifndef M_LN2
# define M_LN2      6.93147180559945309417e-001
#endif
#ifndef M_LN10
# define M_LN10     2.30258509299404568402e+000
#endif
#ifndef M_PI
# define M_PI       3.14159265358979323846e+000
#endif
#ifndef M_PI_2
# define M_PI_2     1.57079632679489661923e+000
#endif
#ifndef M_PI_4
# define M_PI_4     7.85398163397448309616e-001
#endif
#ifndef M_1_PI
# define M_1_PI     3.18309886183790671538e-001
#endif
#ifndef M_2_PI
# define M_2_PI     6.36619772367581343076e-001
#endif
#ifndef M_2_SQRTPI
# define M_2_SQRTPI 1.12837916709551257390e+000
#endif
#ifndef M_SQRT2
# define M_SQRT2    1.41421356237309504880e+000
#endif
#ifndef M_SQRT1_2
# define M_SQRT1_2  7.07106781186547524401e-001
#endif

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12] Types and Macros
//
//-----------------------------------------------------------------------------
/*?mconf
 * X -t'std::float_t' -oMWGCONF_HAS_STD_FLOAT_T cmath 'std::float_t a' ||
 *   X -t'::float_t' -oMWGCONF_HAS_FLOAT_T math.h '::float_t a'
 * X -t'std::double_t' -oMWGCONF_HAS_STD_DOUBLE_T cmath 'std::double_t a' ||
 *   X -t'::double_t' -oMWGCONF_HAS_DOUBLE_T math.h '::double_t a'
 */

namespace mwg {
namespace stdm {

#ifndef MWGCONF_HAS_STD_FLOAT_T
# ifdef MWGCONF_HAS_FLOAT_T
  typedef ::float_t float_t;
# else
  typedef float float_t;
# endif
#endif

#ifndef MWGCONF_HAS_STD_DOUBLE_T
# ifdef MWGCONF_HAS_DOUBLE_T
  typedef ::double_t double_t;
# else
  typedef double double_t;
# endif
#endif

}
}

// Note: 各コンパイラで警告が出ない表式が異なる。
#ifndef INFINITY
// # ifdef _MSC_VER
// #  define INFINITY (float(1e100));
// # else
// #  define INFINITY (1.0f / 0.0f);
// # endif
# include <limits>
# define INFINITY (::std::numeric_limits<float>::infinity())
#endif

//?mconf X -t'qNAN' -oMWGCONF_FLOAT_HAS_QUIET_NAN limits 'char arr[std::numeric_limits<float>::has_quiet_NaN? 1: -1];'
#ifndef NAN
# ifdef MWGCONF_FLOAT_HAS_QUIET_NAN
#  define NAN (::std::numeric_limits<float>::quiet_NaN())
# else
#  include <mwg/std/cfenv>
namespace mwg {
namespace stdm {
namespace cmath_detail {
  inline float qnan() {
    static mwg::stdm::fenv_t env;
    static float tmp;
    static float value = (
      mwg::stdm::feholdexcept(&env),
      tmp = -std::sqrt(float(-1)),
      mwg::stdm::fesetenv(&env),
      tmp);
    return value;
  }
}
}
}
#  define NAN (::mwg::stdm::cmath_detail::qnan())
# endif
#endif

#pragma%x begin_test
void test() {
  float a;
  //a = mwg::stdm::cmath_detail::qnan();
  a = INFINITY;
  a = NAN;
  (void) a;
}
#pragma%x end_test

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.3] Classification macros
//
//-----------------------------------------------------------------------------
/*?lwiki
 * @fn bool mwg::stdm::signbit(float);
 * @fn bool mwg::stdm::signbit(double);
 * @fn bool mwg::stdm::signbit(long double);
 * @fn bool mwg::stdm::signbit('integral-time');
 */

/*?mconf
 * if ! X -t'std::signbit(x)' -oMWGCONF_HAS_STD_SIGNBIT cmath 'std::signbit(2.0)'; then
 *   # 元々マクロで定義されていてかつ ::signbit が存在しない場合、このヘッダによ
 *   # って (名前空間を指定せずに) signbit を使う事ができたのができなくなる。既存
 *   # のコードがコンパイルできなくなるのを防ぐ為、この場合に限ってグローバル名前
 *   # 空間に signbit の定義を引き出す。その他の fpclassify マクロも同様。
 *   X -t'::signbit' -oMWGCONF_HAS_SIGNBIT cmath $'\n#undef signbit\nsignbit(0.0);'
 * fi
 */

#ifndef MWGCONF_HAS_STD_SIGNBIT
namespace mwg {
namespace stdm_detail {
# ifdef signbit
  static inline bool signbit_impl(float value) {return signbit(value) != 0;}
  static inline bool signbit_impl(double value) {return signbit(value) != 0;}
  static inline bool signbit_impl(long double value) {return signbit(value) != 0;}
#  undef signbit
#  ifndef MWGCONF_HAS_SIGNBIT
#   define MWG_STDM_CMATH_DefinesGlobalSignbit
#  endif
# else
  template<typename T>
  bool signbit_impl(T value) {return value < 0;}
# endif
}

namespace stdm {

  template<typename T>
  typename cmath_detail::overload<T>::template enable<bool>::type signbit(T value) {
    return ::mwg::stdm_detail::signbit_impl((typename cmath_detail::overload<T>::type) value);
  }
}
}

# ifdef MWG_STDM_CMATH_DefinesGlobalSignbit
using ::mwg::stdm::signbit;
# endif
#endif

//-----------------------------------------------------------------------------
/*?lwiki
 * @fn bool mwg::stdm::isnan(float);
 * @fn bool mwg::stdm::isnan(double);
 * @fn bool mwg::stdm::isnan(long double);
 * @fn bool mwg::stdm::isinf(float);
 * @fn bool mwg::stdm::isinf(double);
 * @fn bool mwg::stdm::isinf(long double);
 * @fn bool mwg::stdm::isfinite(float);
 * @fn bool mwg::stdm::isfinite(double);
 * @fn bool mwg::stdm::isfinite(long double);
 * @fn bool mwg::stdm::isnormal(float);
 * @fn bool mwg::stdm::isnormal(double);
 * @fn bool mwg::stdm::isnormal(long double);
 */

#ifndef MWGCONF_HAS_STD_ISNAN
#ifdef _MSC_VER
# include <float.h>
namespace mwg {
namespace stdm {
  template<typename T>
  bool isnan(const T& value) {
    return ::_isnan((double) value);
  }
  template<typename T>
  bool isinf(const T& value) {
    return (::_fpclass((double) value) & (_FPCLASS_PINF | _FPCLASS_NINF)) != 0;
  }
  template<typename T>
  bool isfinite(const T& value) {
    return ::_finite((double) value);
  }
  template<typename T>
  bool isnormal(const T& value) {
    return (::_fpclass((double) value) & (_FPCLASS_PN | _FPCLASS_NN)) != 0;
  }
}
}
#else /* !defined(_MSC_VER) */
# include <cfloat>

#pragma%#ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp#
#pragma%#                                                                     #
#pragma%# ppmacro: MWG_STDM_CMATH::ImportClassificationMacros                 #
#pragma%#                                                                     #
#pragma%#---------------------------------------------------------------------#
// floating-point classification macros
//   C99 に従えばマクロで定義されるので ifdef で判定可能だが、
//   C++ では関数として定義されている事があるので個別にチェックする必要がある。
#pragma%m MWG_STDM_CMATH::ImportClassificationMacros
#pragma%%[fname="@fname",FNAME=fname.toupper(),expr="@expr"]
#pragma%%x
/*?mconf
 * X -t'std::fname(x)' -oMWGCONF_HAS_STD_ISNAN cmath 'std::fname(2.0)' ||
 *   X -t'::fname' -oMWGCONF_HAS_ISNAN cmath $'\n#undef fname\n::fname(0.0);'
 */
#if !defined(MWGCONF_HAS_STD_FNAME)
namespace mwg {
namespace stdm_detail {
# ifdef fname
  static inline bool fname_impl(double value) {return fname(value) != 0;}
  static inline bool fname_impl(long double value) {return fname(value) != 0;}
  static inline bool fname_impl(float value) {return fname(value) != 0;}
#  undef fname
#  ifndef MWGCONF_HAS_FNAME
#   define MWG_STDM_CMATH_DefinesGlobalFNAME
#  endif
# elif defined(MWGCONF_HAS_FNAME)
  template<typename T>
  bool fname_impl(T value) {
    return ::fname(value);
  }
# else
  template<typename T>
  bool fname_impl(T value) {
    return [expression];
  }
# endif
}

namespace stdm {
  template<typename T>
  typename cmath_detail::overload<T>::template enable<bool>::type fname(T x) {
    typedef typename cmath_detail::overload<T>::type R;
    return mwg::stdm_detail::fname_impl((R) x);
  }
}
}
# ifdef MWG_STDM_CMATH_DefinesGlobalFNAME
using ::mwg::stdm::fname;
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
namespace mwg {
namespace stdm {
  using ::std::fname;
}
}
#endif
#pragma%%end.r/FNAME/${FNAME}/.r/fname/${fname}/.r/\[expression\]/${expr}/.i
#pragma%end
#pragma%#ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp#

#if !defined(MWGCONF_HAS_STD_ISNORMAL) && !defined(MWGCONF_HAS_ISNORMAL) && !defined(isnormal)
namespace mwg {
namespace stdm {
namespace cmath_detail {
  static inline bool isnormal_impl(const float& value) {
    if (!mwg::stdm_detail::isfinite_impl(value)) return false;
    return value >= FLT_MIN || -FLT_MIN >= value;
  }
  static inline bool isnormal_impl(const double& value) {
    if (!mwg::stdm_detail::isfinite_impl(value)) return false;
    return value >= DBL_MIN || -DBL_MIN >= value;
  }
  static inline bool isnormal_impl(const long double& value) {
    if (!mwg::stdm_detail::isfinite_impl(value)) return false;
    return value >= LDBL_MIN || -LDBL_MIN >= value;
  }
}
}
}
#endif
#pragma%x MWG_STDM_CMATH::ImportClassificationMacros.r/@fname/isnan/   .r/@expr/value != value/
#pragma%x MWG_STDM_CMATH::ImportClassificationMacros.r/@fname/isinf/   .r/@expr/value == (T) INFINITY || value == (T) -INFINITY/
#pragma%x MWG_STDM_CMATH::ImportClassificationMacros.r/@fname/isfinite/.r/@expr/!(mwg::stdm_detail::isnan_impl(value) || mwg::stdm_detail::isinf_impl(value))/
#pragma%x MWG_STDM_CMATH::ImportClassificationMacros.r/@fname/isnormal/.r/@expr/mwg::stdm::cmath_detail::isnormal_impl(value)/

#endif /* end of !defined(_MSC_VER) */
#endif /* end of !defined(MWGCONF_HAS_STD_ISNAN) */

//-----------------------------------------------------------------------------
/*?lwiki
 * @fn int mwg::stdm::fpclassify(float);
 * @fn int mwg::stdm::fpclassify(double);
 * @fn int mwg::stdm::fpclassify(long double);
 * @fn int mwg::stdm::fpclassify('integral-type');
 * @def int FP_NAN
 * @def int FP_INFINITE
 * @def int FP_NORMAL
 * @def int FP_SUBNORMAL
 * @def int FP_ZERO
 */

/*?mconf
 * if ! X -t'std::fpclassify(x)' -oMWGCONF_HAS_STD_FPCLASSIFY cmath 'std::fpclassify(2.0)'; then
 *   X -t'::fpclassify' -oMWGCONF_HAS_FPCLASSIFY cmath $'\n#undef fpclassify\nfpclassify(0.0);'
 * fi
 */

#ifndef MWGCONF_HAS_STD_FPCLASSIFY
# ifndef FP_NAN
#  define FP_NAN       0x01
# endif
# ifndef FP_INFINITE
#  define FP_INFINITE  0x02
# endif
# ifndef FP_NORMAL
#  define FP_NORMAL    0x04
# endif
# ifndef FP_SUBNORMAL
#  define FP_SUBNORMAL 0x08
# endif
# ifndef FP_ZERO
#  define FP_ZERO      0x10
# endif

# ifdef _MSC_VER

namespace mwg {
namespace stdm {

  template<typename T>
  int fpclassify(const T& value) {
    switch(::_fpclass((double) value)) {
    case _FPCLASS_SNAN:
    case _FPCLASS_QNAN:
      return FP_NAN;
    case _FPCLASS_PINF:
    case _FPCLASS_NINF:
      return FP_INFINITE;
    case _FPCLASS_PN:
    case _FPCLASS_NN:
      return FP_NORMAL;
    case _FPCLASS_PD:
    case _FPCLASS_ND:
      return FP_SUBNORMAL;
    case _FPCLASS_PZ:
    case _FPCLASS_NZ:
      return FP_ZERO;
    default:
      return FP_NORMAL;
    }
  }
}
}

# else /* !defined(_MSC_VER) */

namespace mwg {
namespace stdm_detail {

#  ifdef fpclassify
  static inline int fpclassify_impl(float value) {return fpclassify(value);}
  static inline int fpclassify_impl(double value) {return fpclassify(value);}
  static inline int fpclassify_impl(long double value) {return fpclassify(value);}
#   undef fpclassify
#   ifndef MWGCONF_HAS_FPCLASSIFY
#    define MWG_STDM_CMATH_DefinesGlobalFpclassify
#   endif
#  else
  template<typename T>
  int fpclassify_impl(const T& x) {
    if (x == 0) {
      return FP_ZERO;
    } else if (mwg::stdm::isnan(x)) {
      return FP_NAN;
    } else if (mwg::stdm::isinf(x)) {
      return FP_INFINITE;
    } else if (!mwg::stdm::isnormal(x)) {
      return FP_SUBNORMAL;
    } else {
      return FP_NORMAL;
    }
  }
#  endif
}

namespace stdm {
  template<typename T>
  int fpclassify(const T& x) {
    return mwg::stdm_detail::fpclassify_impl(x);
  }
}
}

#  ifdef MWG_STDM_CMATH_DefinesGlobalFpclassify
using mwg::stdm::fpclassify;
#  endif
# endif /* end of !defined(_MSC_VER) */
#endif /* end of !defined(MWGCONF_HAS_STD_FPCLASSIFY) */

//-----------------------------------------------------------------------------
//
// tests for Classification functions
//

#pragma%x begin_test
void test() {
  double const inf = INFINITY;
  double const qnan = NAN;
  mwg_check(!mwg::stdm::isnan(0.0));
  mwg_check(!mwg::stdm::isnan(1.0));
  mwg_check(!mwg::stdm::isnan(inf));
  mwg_check(!mwg::stdm::isnan(-inf));
  mwg_check( mwg::stdm::isnan(qnan));

  mwg_check(!mwg::stdm::isinf(0.0));
  mwg_check(!mwg::stdm::isinf(1.0));
  mwg_check( mwg::stdm::isinf(inf));
  mwg_check( mwg::stdm::isinf(-inf));
  mwg_check(!mwg::stdm::isinf(qnan));

  mwg_check( mwg::stdm::isfinite(0.0));
  mwg_check( mwg::stdm::isfinite(1.0));
  mwg_check(!mwg::stdm::isfinite(inf));
  mwg_check(!mwg::stdm::isfinite(-inf));
  mwg_check(!mwg::stdm::isfinite(qnan));

  mwg_check(!mwg::stdm::isnormal(0.0));
  mwg_check( mwg::stdm::isnormal(1.0));
  mwg_check(!mwg::stdm::isnormal(inf));
  mwg_check(!mwg::stdm::isnormal(-inf));
  mwg_check(!mwg::stdm::isnormal(qnan));

  mwg_check(mwg::stdm::fpclassify(0.0) == FP_ZERO);
  mwg_check(mwg::stdm::fpclassify(1.0) == FP_NORMAL);
  mwg_check(mwg::stdm::fpclassify(inf) == FP_INFINITE);
  mwg_check(mwg::stdm::fpclassify(-inf)== FP_INFINITE);
  mwg_check(mwg::stdm::fpclassify(qnan)== FP_NAN);
}
#pragma%x end_test

#pragma%begin
//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// Definition of mwgpp macros
//
//-----------------------------------------------------------------------------

namespace mwg {
namespace stdm {

#pragma%m MWG_STDM_CMATH::ImportUnaryMathFunction::UseCOverload
  using ::@fname;
  using ::@fnamel;
  using ::@fnamef;
  static inline float @fname(float value) {return ::@fnamef(value);}
  static inline long double @fname(long double value) {return ::@fnamel(value);}
  template<typename T>
  typename cmath_detail::overload<T>::type @fname(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return @fname((R) value);
  }
#pragma%end
#pragma%m MWG_STDM_CMATH::ImportBinaryMathFunction::UseCOverload
  using ::@fname;
  using ::@fnamel;
  using ::@fnamef;
  static inline float @fname(float lhs, float rhs) {return ::@fnamef(lhs, rhs);}
  static inline long double @fname(long double lhs, long double rhs) {return ::@fnamel(lhs, rhs);}
  template<typename T, typename U>
  typename cmath_detail::overload<T, U>::type @fname(T lhs, T rhs) {
    typedef typename cmath_detail::overload<T, U>::type R;
    return @fname((R) lhs, (R) rhs);
  }
#pragma%end
#pragma%m MWG_STDM_CMATH::ImportMathFunctionFFI::UseCOverload
  using ::@fname;
  using ::@fnamel;
  using ::@fnamef;
  static inline float @fname(float value, @int rhs) {return ::@fnamef(value, rhs);}
  static inline long double @fname(long double value, @int rhs) {return ::@fnamel(value, rhs);}
  template<typename T>
  typename cmath_detail::overload<T>::type @fname(T value, @int rhs) {
    typedef typename cmath_detail::overload<T>::type R;
    return @fname((R) value, rhs);
  }
#pragma%end

#pragma%m MWG_STDM_CMATH::ImportUnaryMathFunction
#pragma%%[fname="@fname",FNAME=fname.toupper(),expr="@expr"]
#pragma%%[ret = ("@ret" != "@" + "ret")? "enable<@ret>::type": "type"]
#pragma%%x
/*?mconf
 * X -t'std::fname(x)' -oMWGCONF_HAS_STD_FNAME cmath 'std::fname(2.0)' ||
 *   X -t'::fname(x)' -oMWGCONF_HAS_FNAME math.h '::fname(2.0);::fnamef(2.0f);::fnamel(2.0L);'
 */
#if !defined(MWGCONF_HAS_STD_FNAME)
# ifdef MWGCONF_HAS_FNAME
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction::UseCOverload.r/@fname/fname/
# else
  template<typename T>
  typename cmath_detail::overload<T>::return_type fname(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    return [expression];
  }
  static inline float fnamef(float value) {return fname(value);}
  static inline long double fnamel(long double value) {return fname(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::fname;
#endif
#pragma%%end.r/FNAME/${FNAME}/.r/fname/${fname}/.r/\[expression\]/${expr}/.r/return_type/${ret}/.i
#pragma%end

#pragma%m MWG_STDM_CMATH::ImportBinaryMathFunction
#pragma%%[fname="@fname",FNAME=fname.toupper(),expr="@expr"]
#pragma%%x
/*?mconf
 * X -t'std::fname(x, y)' -oMWGCONF_HAS_STD_FNAME cmath 'std::fname(1.0, 2.0)' ||
 *   X -t'::fname(x, y)' -oMWGCONF_HAS_FNAME math.h '::fname(1.0, 2.0);::fnamef(1.0f, 2.0f);::fnamel(1.0L, 2.0L);'
 */
#if !defined(MWGCONF_HAS_STD_FNAME)
# ifdef MWGCONF_HAS_FNAME
#pragma%x MWG_STDM_CMATH::ImportBinaryMathFunction::UseCOverload.r/@fname/fname/
# else
  template<typename T, typename U>
  typename cmath_detail::overload<T, U>::type fname(T lhs, U rhs) {
    typedef typename cmath_detail::overload<T, U>::type R;
    return [expression];
  }
  static inline float fnamef(float lhs, float rhs) {return fname(lhs, rhs);}
  static inline long double fnamel(long double lhs, long double rhs) {return fname(lhs, rhs);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::fname;
#endif
#pragma%%end.r/FNAME/${FNAME}/.r/fname/${fname}/.r/\[expression\]/${expr}/.i
#pragma%end

}
}

#pragma%end

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.4] Trigonometric functions
//
//-----------------------------------------------------------------------------

#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
namespace mwg {
namespace stdm {
  using ::std::sin;
  using ::std::cos;
  using ::std::tan;
  using ::std::asin;
  using ::std::acos;
  using ::std::atan;
  using ::std::atan2;
}
}
#endif

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.5] Hyperbolic functions
//
//-----------------------------------------------------------------------------

namespace mwg {
namespace stdm {
#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
  using ::std::sinh;
  using ::std::cosh;
  using ::std::tanh;
#endif

#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/asinh/.r|@expr|std::log((R) value + std::sqrt((R) value * (R) value + R(1.0)))|
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/acosh/.r|@expr|std::log((R) value + std::sqrt((R) value * (R) value - R(1.0)))|
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/atanh/.r|@expr|R(0.5) * std::log((R(1.0) + (R) value) / (R(1.0) - (R) value))|
}
}

#pragma%x begin_test
void test() {
  mwg_check(mwg::stdm::sinh(0) == 0.0);
  mwg_check(mwg::stdm::asinh(0) == 0.0);
  mwg_check(mwg::stdm::asinh(0.0) == 0.0);
  mwg_check(mwg::stdm::acosh(1.0) == 0.0);
  mwg_check(mwg::stdm::atanh(0.0) == 0.0);
}
#pragma%x end_test

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.6] Exponential and logarithmic functions
//
//-----------------------------------------------------------------------------

namespace mwg {
namespace stdm {
#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
  using ::std::exp;
  using ::std::log;
  using ::std::log10;
  using ::std::frexp;
  using ::std::ldexp;
  using ::std::modf;
#endif

#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/exp2/.r|@expr|std::pow(R(2.0), (R) value)|
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/log2/.r|@expr|R(M_LOG2E) * std::log((R) value)|

/*?mconf
 * X -t'std::expm1(x)' -oMWGCONF_HAS_STD_EXPM1 cmath 'std::expm1(2.0)' ||
 *   X -t'::expm1(x)' -oMWGCONF_HAS_EXPM1 math.h '::expm1(2.0);::expm1f(2.0f);::expm1l(2.0L);'
 */
#if !defined(MWGCONF_HAS_STD_EXPM1)
# ifdef MWGCONF_HAS_EXPM1
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction::UseCOverload.r/@fname/expm1/
# else
  template<typename T>
  typename cmath_detail::overload<T>::type expm1(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    R const _value = value;
    if (std::abs(_value) < 1e-4)
      return (((1.0 / 24.0 * _value + 1.0 / 6.0) * _value + 0.5) * _value + 1.0) * _value;
    else
      return std::exp(_value) - R(1.0);
  }
  static inline float expm1f(float value) {return expm1(value);}
  static inline long double expm1l(long double value) {return expm1(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::expm1;
#endif

/*?mconf
 * X -t'std::log1p(x)' -oMWGCONF_HAS_STD_LOG1P cmath 'std::log1p(2.0)' ||
 *   X -t'::log1p(x)' -oMWGCONF_HAS_LOG1P math.h '::log1p(2.0);::log1pf(2.0f);::log1pl(2.0L);'
 */
#if !defined(MWGCONF_HAS_STD_LOG1P)
# ifdef MWGCONF_HAS_LOG1P
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction::UseCOverload.r/@fname/log1p/
# else
  template<typename T>
  typename cmath_detail::overload<T>::type log1p(T value) {
    typedef typename cmath_detail::overload<T>::type R;
    R const _value = value;
    if (std::abs(_value) < 1e-4)
      return (((-1.0 / 4.0 * _value + 1.0 / 3.0) * _value - 0.5) * _value + 1.0) * _value;
    else
      return std::log(R(1.0) + _value);
  }
  static inline float log1pf(float value) {return log1p(value);}
  static inline long double log1pl(long double value) {return log1p(value);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::log1p;
#endif

/*?mconf
 * X -t'std::scalbn(x, y)' -oMWGCONF_HAS_STD_SCALBN cmath 'std::scalbn(1.0, 2)' ||
 *   X -t'::scalbn(x, y)' -oMWGCONF_HAS_SCALBN math.h '::scalbn(1.0, 2);::scalbnf(1.0f, 2);::scalbnl(1.0L, 2);'
 */
#if !defined(MWGCONF_HAS_STD_SCALBN)
# ifdef MWGCONF_HAS_SCALBN
#pragma%x MWG_STDM_CMATH::ImportMathFunctionFFI::UseCOverload.r/@fname/scalbn/.r/@int/int/
# else
  template<typename T>
  typename cmath_detail::overload<T>::type scalbn(T value, int n) {
    typedef typename cmath_detail::overload<T>::type R;
    if (FLT_RADIX == 2)
      return std::ldexp((R) value, n);
    else
      return (R) value * std::pow((R) FLT_RADIX, (R) n);
  }
  static inline float scalbnf(float value, int n) {return scalbn(value, n);}
  static inline long double scalbnl(long double value, int n) {return scalbn(value, n);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::scalbn;
#endif

/*?mconf
 * X -t'std::scalbln(x, y)' -oMWGCONF_HAS_STD_SCALBLN cmath 'std::scalbln(1.0, 2L)' ||
 *   X -t'::scalbln(x, y)' -oMWGCONF_HAS_SCALBLN math.h '::scalbln(1.0, 2L);::scalblnf(1.0f, 2L);::scalblnl(1.0L, 2L);'
 */
#if !defined(MWGCONF_HAS_STD_SCALBLN)
# ifdef MWGCONF_HAS_SCALBLN
#pragma%x MWG_STDM_CMATH::ImportMathFunctionFFI::UseCOverload.r/@fname/scalbln/.r/@int/long/
# else
  template<typename T>
  typename cmath_detail::overload<T>::type scalbln(T value, long n) {
    typedef typename cmath_detail::overload<T>::type R;
    static_assert(
      INT_MIN <= (mwg::stdm::is_same<R, float>::value? FLT_MIN_EXP:
        mwg::stdm::is_same<R, long double>::value? LDBL_MIN_EXP:
        DBL_MIN_EXP) &&
      INT_MAX >= (mwg::stdm::is_same<R, float>::value? FLT_MAX_EXP:
        mwg::stdm::is_same<R, long double>::value? LDBL_MAX_EXP:
        DBL_MAX_EXP),
      "the exponent of the floating-point type is too wide");
    return mwg::stdm::scalbn((R) value, n > INT_MAX? INT_MAX: n < INT_MIN? INT_MIN: n);
  }
  static inline float scalblnf(float value, long n) {return scalbln(value, n);}
  static inline long double scalblnl(long double value, long n) {return scalbln(value, n);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::scalbln;
#endif

#if !defined(MWGCONF_HAS_STD_ILOGB) && !defined(MWGCONF_HAS_ILOGB)
# undef FP_ILOGB0
# undef FP_ILOGBNAN
# define FP_ILOGB0   -INT_MAX
# define FP_ILOGBNAN  INT_MIN
  namespace cmath_detail {
    int ilogb(float value);
    int ilogb(double value);
    int ilogb(long double value);
  }
#endif
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/ilogb/.r/@ret/int/.r|@expr|cmath_detail::ilogb((R) value)|

#if !defined(MWGCONF_HAS_STD_LOGB) && !defined(MWGCONF_HAS_LOGB)
  namespace cmath_detail {
    float logb(float value);
    double logb(double value);
    long double logb(long double value);
  }
#endif
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/logb/.r|@expr|cmath_detail::logb((R) value)|

#if !defined(MWGCONF_HAS_STD_NEXTAFTER) && !defined(MWGCONF_HAS_NEXTAFTER)
  namespace cmath_detail {
    float nextafter(float lhs, float rhs);
    double nextafter(double lhs, double rhs);
    long double nextafter(long double lhs, long double rhs);
  }
#endif
#pragma%x MWG_STDM_CMATH::ImportBinaryMathFunction.r/@fname/nextafter/.r|@expr|cmath_detail::nextafter((R) lhs, (R) rhs)|

/*?mconf
 * X -t'std::nexttoward(x, y)' -oMWGCONF_HAS_STD_NEXTTOWARD cmath 'std::nexttoward(1.0, 2L)' ||
 *   X -t'::nexttoward(x, y)' -oMWGCONF_HAS_NEXTTOWARD math.h '::nexttoward(1.0, 2L);::nexttowardf(1.0f, 2L);::nexttowardl(1.0L, 2L);'
 */
#if !defined(MWGCONF_HAS_STD_SCALBLN)
# ifdef MWGCONF_HAS_SCALBLN
#pragma%x MWG_STDM_CMATH::ImportMathFunctionFFI::UseCOverload.r/@fname/nexttoward/.r/@int/long double/
# else
  template<typename T>
  typename cmath_detail::overload<T>::type nexttoward(T from, long double to) {
    typedef typename cmath_detail::overload<T>::type R;
    if ((long double) from == to) return (R) to;
    if (mwg::stdm::isnan(from) || mwg::stdm::isnan(to)) return (R) NAN;
    return mwg::stdm::nextafter((R) from, (long double) from > to? (R) -INFINITY: (R) INFINITY):
  }
  static inline float nexttowardf(float from, long double to) {return nexttoward(from, to);}
  static inline long double nexttowardl(long double from, long double to) {return nexttoward(from, to);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::nexttoward;
#endif

#pragma%x begin_test
  void test() {
    mwg::stdm::exp2(1e-5);
    mwg::stdm::log2(1e-5);
    mwg::stdm::expm1(1e-5);
    mwg::stdm::log1p(1e-5);
    mwg_check((mwg::stdm::expm1(0.0) == 0.0));
    mwg_check((mwg::stdm::log1p(0.0) == 0.0));
  }
#pragma%x end_test
}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.11] Manipulation functions (1)
//
//-----------------------------------------------------------------------------

namespace mwg {
namespace stdm {

#pragma%x MWG_STDM_CMATH::ImportBinaryMathFunction.r/@fname/copysign/.r|@expr|(R) rhs < 0? -(R) lhs: (R) lhs|

// ToDo: nan

}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.7] Power and absolute-value functions
//
//-----------------------------------------------------------------------------

namespace mwg {
namespace stdm {

#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
  using ::std::abs;
  using ::std::fabs;
  using ::std::pow;
  using ::std::sqrt;
#endif

#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/cbrt/.r|@expr|mwg::stdm::copysign(std::pow(std::abs((R) value), R(1.0 / 3.0)), value)|

/*?mconf
 * X -t'std::hypot(x, y)' -oMWGCONF_HAS_STD_HYPOT cmath 'std::hypot(1.0, 2.0)' ||
 *   X -t'::hypot(x, y)' -oMWGCONF_HAS_HYPOT math.h '::hypot(1.0, 2.0);::hypotf(1.0f, 2.0f);::hypotl(1.0L, 2.0L);'
 */
#if !defined(MWGCONF_HAS_STD_HYPOT)
# ifdef MWGCONF_HAS_HYPOT
#pragma%x MWG_STDM_CMATH::ImportBinaryMathFunction::UseCOverload.r/@fname/hypot/
# else
  template<typename T, typename U>
  typename cmath_detail::overload<T, U>::type hypot(T x, U y) {
    typedef typename cmath_detail::overload<T, U>::type R;
    R const x_ = std::abs((R) x), y_ = std::abs((R) y);
    if (x_ == 0.0 && y_ == 0.0)
      return 0.0;
    else if (x_ < y_)
      return y_ * std::sqrt(1.0 + (x_ / y_) * (x_ / y_));
    else
      return x_ * std::sqrt(1.0 + (y_ / x_) * (y_ / x_));
  }
  static inline float hypotf(float lhs, float rhs) {return hypot(lhs, rhs);}
  static inline long double hypotl(long double lhs, long double rhs) {return hypot(lhs, rhs);}
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
  using ::std::hypot;
#endif

#pragma%x begin_test
  void test() {
    mwg_check(mwg::stdm::cbrt(0.0) == 0.0);
    mwg_check((mwg::stdm::cbrt(-8.0) - -2.0) <= 1e-14);
    mwg_check((mwg::stdm::cbrt(+8.0) - +2.0) <= 1e-14);
    mwg_check((mwg::stdm::cbrt(-1.0) - -1.0) <= 1e-14);
    mwg_check((mwg::stdm::cbrt(+1.0) - +1.0) <= 1e-14);
  }
#pragma%x end_test

}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
// [C11 7.12.14] Comparison macros
//
//-----------------------------------------------------------------------------

#pragma%m MWG_STDM_CMATH::ImportComparisonMacros
#pragma%%[fname="@fname",FNAME=fname.toupper(),expr="@expr"]
#pragma%%[ret = ("@ret" != "@" + "ret")? "enable<@ret>::type": "type"]
#pragma%%x
/*?mconf
 * if ! X -t'std::fname(x, y)' -oMWGCONF_HAS_STD_FNAME cmath 'std::fname(1.0, 2.0)'; then
 *   X -t'::fname(x, y)' -oMWGCONF_HAS_FNAME cmath $'\n#undef fname\n::fname(1.0, 2.0);'
 * fi
 */
#ifndef MWGCONF_HAS_STD_FNAME
namespace mwg {
namespace stdm_detail {
# ifdef fname
  static inline bool fname_impl(float lhs, float rhs) {return fname(lhs, rhs) != 0;}
  static inline bool fname_impl(double lhs, double rhs) {return fname(lhs, rhs) != 0;}
  static inline bool fname_impl(long double lhs, long double rhs) {return fname(lhs, rhs) != 0;}
#  undef fname
#  ifndef MWGCONF_HAS_FNAME
#   define MWG_STDM_CMATH_DefinesGlobalIsunordered
#  endif
# elif defined(MWGCONF_HAS_FNAME)
  template<typename T>
  bool fname_impl(T lhs, T rhs) {
    return ::fname(lhs, rhs);
  }
# else
  template<typename T>
  bool fname_impl(T lhs, T rhs) {
    return [expression];
  }
# endif
}
namespace stdm {
  template<typename T, typename U>
  typename cmath_detail::overload<T, U>::type fname(T x, U y) {
    typedef typename cmath_detail::overload<T, U>::type R;
    return ::mwg::stdm_detail::fname_impl((R) x, (R) y);
  }
}
}
# ifdef MWG_STDM_CMATH_DefinesGlobalIsunordered
using ::mwg::stdm::fname;
# endif
#elif defined(MWGCONF_GCC295BUG_USING_NAMESPACE_STD)
namespace mwg {
namespace stdm {
  using ::std::fname;
}
}
#endif
#pragma%%end.r/FNAME/${FNAME}/.r/fname/${fname}/.r/\[expression\]/${expr}/.r/return_type/${ret}/.i
#pragma%end

#pragma%x MWG_STDM_CMATH::ImportComparisonMacros.r/@fname/isunordered/   .r#@expr#mwg::stdm::isnan(lhs) || mwg::stdm::isnan(rhs)#
#pragma%x MWG_STDM_CMATH::ImportComparisonMacros.r/@fname/isgreater/     .r#@expr#mwg::stdm::isunordered(lhs, rhs)? false: lhs > rhs#
#pragma%x MWG_STDM_CMATH::ImportComparisonMacros.r/@fname/isless/        .r#@expr#mwg::stdm::isunordered(lhs, rhs)? false: lhs < rhs#
#pragma%x MWG_STDM_CMATH::ImportComparisonMacros.r/@fname/isgreaterequal/.r#@expr#mwg::stdm::isunordered(lhs, rhs)? false: lhs >= rhs#
#pragma%x MWG_STDM_CMATH::ImportComparisonMacros.r/@fname/islessequal/   .r#@expr#mwg::stdm::isunordered(lhs, rhs)? false: lhs <= rhs#
#pragma%x MWG_STDM_CMATH::ImportComparisonMacros.r/@fname/islessgreater/ .r#@expr#mwg::stdm::isunordered(lhs, rhs)? false: lhs < rhs || lhs > rhs#

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
//
//  [C11 7.12.9] Nearest integer functions
//
//=============================================================================

/*?mconf
 * # 何と gcc-2.95 ではそもそも同じ arity の SFINAE 関数を複数定義できない?
 * # → そもそも SFINAE は gcc 3.0 以降でしか有効でないようだ。
 * S -t'"sfinae"' 'STD_SFINAE' '' '
 * template<typename T> struct is_a{};
 * template<typename T> struct is_b{typedef int type;};
 * template<typename T> void foo(T const&,typename is_a<T>::type = 0){}
 * template<typename T> void foo(T const&,typename is_b<T>::type = 0){}
 * int main(){foo(1);}
 * '
 */

namespace mwg {
namespace stdm {
#ifdef MWGCONF_GCC295BUG_USING_NAMESPACE_STD
  using ::std::ceil;
  using ::std::floor;
#endif

#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/trunc/.r|@expr|mwg::stdm::isnan((R) value)? NAN: (R) value >= 0? std::floor((R) value): std::ceil((R) value)|
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/round/.r|@expr|mwg::stdm::isnan((R) value)? NAN: (R) value >= 0? std::floor((R) value + R(0.5)): std::ceil((R) value - R(0.5))|

#if ((!defined(MWGCONF_HAS_STD_NEARBYINT) && !defined(MWGCONF_HAS_NEARBYINT)) \
  || (!defined(MWGCONF_HAS_STD_RINT) && !defined(MWGCONF_HAS_RINT)))
#define MWG_STDM_CMATH_Defines_nbint
  namespace cmath_detail {
    float nbint(float value);
    double nbint(double value);
    long double nbint(long double value);
  }
#endif
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/nearbyint/.r|@expr|cmath_detail::nbint((R) value)|
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/rint/     .r|@expr|cmath_detail::nbint((R) value)|

#if ((!defined(MWGCONF_HAS_STD_LRINT) && !defined(MWGCONF_HAS_LRINT)) \
  || (!defined(MWGCONF_HAS_STD_LROUND) && !defined(MWGCONF_HAS_LROUND)))
#define MWG_STDM_CMATH_Defines_lint
  namespace cmath_detail {
    long lint(float value);
    long lint(double value);
    long lint(long double value);
  }
#endif
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/lround/.r/@ret/long/.r|@expr|cmath_detail::lint(mwg::stdm::round((R) value))|
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/lrint/.r/@ret/long/.r|@expr|cmath_detail::lint(mwg::stdm::rint((R) value))|

#ifdef MWGCONF_HAS_LONGLONG
#if ((!defined(MWGCONF_HAS_STD_LLRINT) && !defined(MWGCONF_HAS_LLRINT)) \
  || (!defined(MWGCONF_HAS_STD_LLROUND) && !defined(MWGCONF_HAS_LLROUND)))
#define MWG_STDM_CMATH_Defines_llint
  namespace cmath_detail {
    long long llint(float value);
    long long llint(double value);
    long long llint(long double value);
  }
#endif
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/llround/.r/@ret/long long/.r|@expr|cmath_detail::llint(mwg::stdm::round((R) value))|
#pragma%x MWG_STDM_CMATH::ImportUnaryMathFunction.r/@fname/llrint/.r/@ret/long long/.r|@expr|cmath_detail::llint(mwg::stdm::rint((R) value))|
#endif

}
}

//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
#endif /* end of MWG_STDM_CMATH */
#pragma%x begin_check
int main(){
  managed_test::run_tests();
  return 0;
}
#pragma%x end_check
