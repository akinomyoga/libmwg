libmwg implementation memo.txt

------------------------------------------------------------------------------
  Note
------------------------------------------------------------------------------

Support

* clang -std=c++0x から GCC 4.4.7 libstdc++ を使えない。これに対する対処は諦める。

* gcc-3.3.6 は &X::member, void (X::*)() の形の SFINAE が効かない。
  これにより has_member 系統が全て実装できないので <type_traits> が提供できない。
  gcc-3.3.6 の full support は諦める。

* gcc-2.95.3 はそもそも SFINAE が使えない。
  SFINAE は overload 選択に使用する物であるが、
  別の方法を用いて overload 選択をすれば対応できる可能性がある。

  但し、別の方法 (クラステンプレートによる分類) は現在不安定である。


実装方法

* mwg/std: 新しい多重定義を追加するとき・既存の多重定義を上書きするとき

  既存の関数について新しい多重定義を追加するときは明示的に using std::hoge を記述する必要がある。
  ただし、既存の多重定義を上書きする場合は using std::hoge してはならない (多重定義解決が曖昧になる)。
  代わりにすべての各多重定義について完全転送をしなければならない。
  ※転送にするとコピー省略が阻害される場合があるがより良い方法はない。

C++

* mwg/fun: 何と C++ には参照メンバに対するメンバポインタはない様だ (2017-02-12)


------------------------------------------------------------------------------
  ToDo of mwg/fun
------------------------------------------------------------------------------

2017-08-19

* mwg/fun: 早々に決着をつけたい。

  先ず mwg/functor.h を廃止する前に最低限対応するべき機能と、
  後々ゆっくり実装していけば良い機能を分別したい。

  取り敢えず mwg/functor.h を廃止する前に対応する機能について列挙すれば良い。

  今何が問題になっているのかというと、
  どのような機能に対応したいのかということが不明瞭なことである気がする。

    元々は functor.h で提供されているテストに対して、
    それと等価なテストに通るようにしたいということだった。
    しかし、テストの中には要求仕様に定義するものとは限らず、
    専ら動作検証のために細かいテストをしているものも含まれる。
    また、functor.h の反省から仕様が大きく変わっているという問題もある。
    これによって、大枠として対応したいインターフェイスというものが不明瞭になっている。

    従って、ここで改めて (最低限の) 欲しいインターフェイスについて整理し、
    それについて仕様を完結に示す程度のサンプルコードをテストに加えて、
    コンパイルが通ることを確かめる程度のチェックとするのが良い。
    この仕様を示すサンプルコードではコメントをつけて、
    それ自体が簡単な説明書を為すようにするのが良い。


* mwg/fun: [付録機能] 関数ポインタ・関数参照などへの変換関数が定義されているクラスの対応?

  そのクラスが持っている変換関数をどのようにして調べるのか。
  特に変換先の型が分かっている場合には良いが、
  任意の関数ポインタ・関数参照・関数ポインタ参照の場合には難しい。

2017-02-13

* mwg/fun: [付録機能] mwg::fun_detail::type_traits::canonical_parameter を用いた operator()() 探索。

  Note: canonical_parameter は現在定義はされているが、誰も使用していない。
  経緯は覚えていないが、今後 operator()() による探索を行う時に使うために予め定義されたものであろう。

  % 所で、現在はどのように処理をしているか確認しておく必要がある。
  % 関数呼び出し演算子による判定は has_single_operator_functor 及び、
  % can_be_called_as で行われている。has_single_operator_functor は使用されていない。
  % can_be_called_as は functor_traits_rule<traits_priority_operator, F, S> の実装で使われている
  % (具体的な実装は function_call_operator_traits::_switch<F, S> で与えられる)。
  % 
  % 従って関手の判定に関しては具体的な opperator()() の取得を必要としていない。
  % つまり operator()() を探索しなくても処理ができるということ?
  % と思ったが decltype/modern sizeof がない場合には can_be_called_as の実装は、
  % check_function_call_operator に fallback している。
  % この check_function_call_operator は具体的に operator()() を探索しているが、
  % 現在の実装は単純に要求される signature の関数がないかどうか確認するものである。
  % 
  % この項目は check_function_call_operator の実装をよりちゃんとした物にする
  % という目的で建てられた物であろう。

  この項目が具体的にどういうことなのかについての記述が抜けていたが、これは要するに
  mwg::fun_detail::type_traits::can_be_called_as_detail::check_function_call_operator
  の実装をもっとちゃんとしたものにしたいという話である。

* mwg/fun: functor を提供する箇所は何処にする?

  % 実際に調べてみると functor を使っているのは xprintf.h しかない。
  % (それでも確かに functor を使っている箇所はあるということに注意する)。
  % なので、functor は mwg/fun.h で直接対応するのではなくて、
  % 別のヘッダで提供しても良いのではないだろうか。
  %
  % 但し、functor を実現するために functor_traits に大幅な変更を加えなければならないかもしれない。
  % もし functor_traits に対する大幅な変更が大半を占めるのだとしたらば、
  % やはり mwg/fun.h の中におまけとして functor を入れてしまった方が自然な気がする。
  %
  % byref_functor と byval_functor をどの様に名付けるか?
  % 面倒なので functor<void (int)> と functor<void (&)(int)> で区別するとか。
  % 既定では byval_functor という事で良い。

  取り敢えず mwg/fun.h の内部に試験的に実装していき、
  肥大化してきたら別のヘッダに移動するという方法で問題ない気がする。

* mwg/fun: [付録機能] auto hoge = mwg::delegate<int (A, B)>(obj, &Class::do_action);

  の様な関数を提供しても良いのではないだろうか。
  mwg::delegate ではなくて mwg::fun という名前を使い回す方が良さそう。

  或いは mwg::fun で部分適用もできるようにしてしまうという考え方も。

* mwg/fun: 既定の関数オブジェクト及び多重定義

  実は既に関数型だったり関数オブジェクトだったりする物については、
  adapter は自分自身の型への参照にすれば良いのでは。
  そちらの方が多重定義を失う事もないし良い。

  と思ったがその為には現在の様に as_fun の内部で adapter を定義するという方法は使えない。
  自分で特別な adapter を生成する場合には functor_traits に `intrinsic_adapter` という名前で、
  型メンバーを提供する様にすれば良い。

  % メンバポインタに関連して。受け取るオブジェクトに応じて戻り値の型が変わる。
  % つまり、`T C::*` は `T& (C&)` と `T& (C&)` の多重定義を持つ関数オブジェクトと考えられる。
  % より一般化して多重定義を持つ関数オブジェクトをどの様に実現するのかという事である。
  %
  % 例えば、多重定義を持つ関数オブジェクトの場合には `intrinsic_signature` として関数型ではなくて、
  % `std::pair<S1, std::pair<S2, S3> >` の様な物を指定することにするのはどうだろう。
  % そして `functor_interface` は `std::pair` に対する特殊化を用意して、
  % 何とか `operator` を複数用意する事にするのである。
  %
  % 取り敢えず現状では `T& (C&)` を使用する事にする。

  オブジェクトの本来の多重定義を提供するというのであれば、普通に個別に実装した方が良い。

  - というのも関数型及び関数オブジェクトに関してはそのまま自身への参照を返す様にすれば済む話だからである。
  - 残るのはメンバ関数型とメンバオブジェクト型である。
    メンバオブジェクト型については有限個の多重定義が明らかなのでそのまま実装すれば良い。
  - メンバ関数型については対応するシグニチャでそのまま operator() を定義すれば良い。
    但し、ref-qualifier のついていないメンバ関数については && 版と & 版の両方を用意する必要がある。

* mwg/fun: 可変長引数関数オブジェクトの型消去方法

  可変長引数の関数オブジェクトの実現方法は謎である。
  というのも、任意の引数を転送する為にはテンプレートを使わなければならないが、
  テンプレートは仮想関数にする事ができないからである。
  ただ、関数オブジェクトにしない範囲では対応可能である。

  更に良く考えてみたら多重定義が色々になっている関数オブジェクトに関しても、
  なかなか実現方法は面倒である。だとするのであれば、
  関数オブジェクトにする時には常に固定の引数になる様にするのが良いだろうか。
  そもそも可変長テンプレート引数の関数ですら仮想関数にするのは難しい。

  型情報などを使って無理矢理に実現する方法はあるかもしれないが、
  そういった無理矢理で効率の悪い方法は今回の対象ではない。
  (mwg/fun (もしくは前身の mwg/functor) は、
  できるだけ効率的に実装したいが毎回自分で実装するのは面倒な仕組み、
  というのの共通部分を括りだしてまとめた物を作ることである。)


  関数オブジェクトを adapter を通して使う場合には、
  adapter は直接その関数オブジェクトへの参照にする。
  これによって可変長引数の関数呼び出し演算子を含めて多重定義された状態で公開できる。
  一方で関数オブジェクトを mwg::functor<> などに型消去して利用する場合には、
  可変長引数を渡すことはできないので困る。
  可変長引数は使えないので固定の引数しか許さない様にする?

2017-02-11

* mwg/fun: 関数オブジェクトへのポインタ (*obj)(...) に対応する。

  つまり、ポインタやスマートポインタ等に格納された関数オブジェクトである。

* mwg/fun: <functor.h> functor_traits<F> に対応する機能はどうなったのか。

  | そもそも "そのオブジェクト自体のシグニチャ" というのを意識しない理由は何か。
  | 以前の実装では、is_functor と be_functor という2種類の判定を用意していた。
  | is_functor ではシグニチャが完全に一致するかどうかを判定し、
  | be_functor は反変性や共変性を用いて呼び出すことが出来るかどうかを判定した。
  | 現在の実装では反変性や共変性を用いて呼び出せれば良いという事になっている。
  |
  | 然し、今後多重定義選択に用いる場合には問題になるかもしれない。
  | 例えば void(int) を要求する多重定義1 と void(int,int) を要求する多重定義があった場合に、
  | void(int,int) の関数オブジェクトがどちらに解決されるかという事を考える。
  | 反変性・共変性をフルに使っていると両方に適合する事が可能になる。
  |
  | しかし can_be_called_as を用いて呼び出し可能かどうかを判定するのだとしたら、
  | 引数の個数が異なる様な場合については競合しない様な気がする。
  | もし operator() の多重定義がある場合には、実際に呼び出してみるというのしか
  | 呼び出し可能性を判定する方法はない。いや、でもそれなら一つずつ引数を減らして
  | 行って全部の引数の個数で試せば良いのではないか。
  | デフォルト引数などが定義されているかもしれないので、
  | できるだけ引数の個数が大きい物の優先順位を大きくするのが良い。
  |
  | 結局、複数の適合レベルを用意するのが良い様な気がする。
  | 以前の実装では完全にシグニチャが一致するか、
  | 反変性・共変性を使って一致するか (関数・メンバ)、
  | 呼び出し可能かどうか (関数オブジェクト)、
  | というものを使っていた。特に反変性・共変性と呼び出し可能性については、
  | 厳密には等価ではない。今回の実装では反変性・共変性によるものと、
  | 単純な呼び出し可能性に依るものを区別して二つの異なるレベルの
  | 呼び出し可能性として定義したい。素朴には、
  |
  | - インターフェイスの引数の個数の増加
  | - インターフェイスの戻り値を void にする事
  |
  | を許すか許さないかという事に帰着できるのではないかという気がしたりする。
  | さて、この異なるレベルの呼び出し可能性をどの様に traits で表現するか。
  |
  | - 一つの方法は traits の側で呼び出し許容レベルの引数を余分に渡す方法である。
  |   しかし、その方法だとテンプレート引数が全体的に一個増える事になり改修が面倒である。
  |
  | - もう一つの方法は要求シグニチャ型 S に、呼び出し許容レベルの情報を埋め込むという事である。
  |   現在は直接に関数型 R(A) を S に指定しているが、例えば variant<R(A)> 等の様にして、
  |   何らかのタグ情報をつけて渡すという様にしても良いのである。
  |   しかしこれはこれで何だか分かりにくいし、方法として汚い。
  |
  | - 或いは、テンプレート引数は今までのままで、複数の値を traits の側で提供するか。
  |   現在は ::value でフル反変性・共変性による判定結果を返しているが、
  |   それに加えて ::preserves_arity 的なメンバを用意して、
  |   多重定義の優先度の判定の為にそれを参照する必要がある場合には適宜参照する
  |   という様にするのである。特に無視する戻り値・引数の個数を保持するメンバの方が汎用的に使えるかもしれない。
  |
  |   この方法の良い所は、更に他のレベルの呼び出し可能性 (例えば厳密一致) を提供するのが簡単であるという事である。
  |   新しいメンバ変数を追加するだけで良いという事である。

  参考: 初期の実装において以下のような議論もあった。

  | is_functor/be_functor に対応する物は何か。
  | mwg/functor では is_functor は厳密に一致するシグニチャを持つ物であった。
  | 一方で be_functor は (引数の個数が異なる物も含めて) 適合するシグニチャを持つ物であった。
  | is_functor の条件は厳しすぎる一方で be_functor の条件は緩すぎる。
  | 丁度中間になる様なものが存在しても良いのではないだろうか。
  | (例えば const, volatile, const& を外した上での比較を行う等)

  [結論]

  "そのオブジェクト本来のシグニチャ" は functor_traits<F, S> の判定で、
  共変性や反変性の判定を行う際に参考にする為に用いられた。
  今回の実装ではそれらの判定自体を functor_traits<F, S> の内部で自分で提供する事にする。
  中途半端な自動化のためにインターフェイスを複雑にする必要はないからである。
  従って、functor_traits<F> の従来の機能は不要である。

  一方で、様々な多重定義に対応したメンバオブジェクト・メンバ関数ポインタの
  インターフェイスを提供する目的で functor_traits<F, S = void> を用意する余地はある。

  また、共変性や反変性を含めた呼び出し適合レベルには様々なレベルがある。

  - シグニチャの厳密な一致
  - 戻り値・引数の型のぶれ: T const& か T かなどの細かい違いを無視した比較。
  - 共変性・反変性を用いた呼び出し: 引数の型の変更、戻り値の型の変更を含む。
  - 完全な共変性・反変性を用いた呼び出し: 引数の個数の変化や戻り値を捨てる (void) 事も含む。

  ::value では完全な共変性・反変性を用いた呼び出しの判定を提供する。
  これが一番ゆるいのでこれが false の場合には、そのオブジェクトは関手にはなりえない。
  そして、他のメンバでそれぞれのレベルの呼び出し可能性についての情報を提供する。

  取り敢えず初めは ::value の提供だけを目指す。


* mwg/fun: member_object_pointer/member_function_pointer について、
  多重定義に対応した adapter を提供する。

2017-02-10

* mwg/fun: clang++ -std=c++11 bug?

  mwg/fun (check) において、

  mwg::functor_detail::member_object_pointer_traits::_switch のデフォルトのテンプレート引数において、
  int flags = ..., typename return_t = typename stdm::conditional<flags, ...>::type の様に指定すると、
  mwg_check((mwg::functor_detail::member_object_pointer_traits::_switch<int, Rect, int (Rect const&)>::value)); // これはエラーになるのに、
  mwg_check((mwg::functor_detail::functor_traits_member<int Rect::*, int (Rect const&)>::value)); // これは静かに false (誤った値) になる。
  この振る舞いは規格的にはどうなのだろうか。未定義動作か何かだろうか。

  ※これは 2017-02-10 の clang c++11 における bugfix で判明したものである。

2017-02-09

* mwg/fun: vs でのテストはいつ実行するか。

  タスクがどんどん複雑になるので現時点では vc によるテストは導入しないほうが良い。
  後になればなる程コードが巨大化し、vc++ における問題の特定が難しくなるという問題はあるかもしれないが、
  その辺りは適宜テストを on/off して少しずつ対応していく様にすれば問題ないはずである。
  何れにしても、問題の起こりやすい vc におけるテストはできるだけ後回しにして、
  他のコンパイラで完全に動く様になってからテストを開始した方が良いだろうと思う。


2017-02-06

* mwg/functor: 重荷になっている。整理したい。

  特に C++11+ 前提での実装はどうなるかについて考え直したい。
  そのために現在の構造について全体がどうなっているか再度整理する必要がある。

  hint: concept_map

  先ず functor.proto.h を見てみる事にする。まあ、大体以下のような感じになっている。

  | struct mwg::functor_traits          <typename F, typename S = void>;
  |   struct mwg::functor_traits_empty                ;
  |   struct mwg::functor_traits_signature<typename S>;
  |
  | class  mwg::functor_detail::functor     <typename S>;
  | class  mwg::functor_detail::functor_ref <typename S>;
  | class  mwg::functor_detail::vfunctor    <typename S>;
  | class  mwg::functor_detail::vfunctor_ref<typename S>;
  |   struct mwg::functor_base<typename S>;
  |   struct mwg::functor_case_traits<typename F>;
  |   struct mwg::functor_case       <typename S>;
  |   class  mwg::functor_case_impl  <typename S, typename Tr>;
  |
  | struct mwg::functor_detail::is_functor<typename F, typename S>;
  | struct mwg::functor_detail::be_functor<typename F, typename S>;

  functor.h を上から順番に見ていく事にする。
  先ず functor_traits は concept の積りの様である。

  | template<typename F>
  | struct functor_traits {
  |   static const bool is_functor;
  |   typedef F fct_t;
  |   typedef auto sgn_t;
  |
  |   typedef auto ref_tr; // functor への参照を保持
  |   typedef auto ins_tr; // functor の複製インスタンスを保持
  |   static '''return-type''' invoke(const fct_t& f, ...) {
  |     f(...);
  |   }
  | };
  | template<typename F, typename S>
  | struct functor_traits {
  |   static const bool is_functor;
  |   typedef F fct_t;
  |   typedef S sgn_t;
  |
  |   typedef auto ref_tr; // functor への参照を保持
  |   typedef auto ins_tr; // functor の複製インスタンスを保持
  |   static '''return-type''' invoke(const fct_t& f, ...) {
  |     f(...);
  |   }
  | };

  functor_traits には以下の2種類がある。

  - functor_traits<F>    ... 型 F の自然な関数としての振る舞い
  - functor_traits<F, S> ... 型 F を関数型 S の様にして使う時の振る舞い

    基本的に functor_traits<F, S> の振る舞いは
    functor_traits<F> から導出されるべきである。

  functor_traits は以下のメンバを持つ

  - is_functor
    これは (指定した) 関数型として振る舞うかどうかを表す。

  - fct_t, sgn_t
    fct_t は本体の関数オブジェクトの型で、
    sgn_t はどの関数型として振る舞うかを示す。

  - invoke 関数

    実はこれは concept_map みたいな実装にした方が良いかもしれない。

    ★可変長引数 (...) で余分の引数を捨てる設計になっている事
      functor_traits<F, S> として使う場合にはシグニチャが確定しているから良いが、
      functor_traits<F> として使う場合にはより緩い invoke が必要である。
      その為に ... で余分の引数を捨てている。
      しかしここで緩い invoke をするのは違う様な気がする。
      と思ったが緩くするために一段関数を挟んでも良い様な気もする。
      (しかし perfect forward を何段も行うというのもなかなか気が引ける。
      現在の実装になっているのはこの段数を少なくする為だったかもしれない…)。

  - ref_tr, ins_tr
    それぞれ、参照・実体を保持する為の functor_case_traits.
    つまり functor_ref, functor を記述するための型特性である。

    ref_tr は普通に参照を保持すれば良い様な気もするが、
    関数の参照を採ることができない (?) という事と、
    参照を保持する関数オブジェクトと実体を保持する
    関数オブジェクトを区別して取り扱うのが面倒というのがある。

    勿論、ラムダ式も保持できる様にしてある (はずである)。

    唯の concept_map と異なるのは型消去を行うという点である。

  次に見るのは functor_case_traits である。
  これは ref_tr, ins_tr のインターフェイスを決定する。
  (実際、ref_tr 及び ins_tr は独自に定義して良いが、
  この functor_case_traits を通して定義するのが簡単である。)

  | template<typename F>
  | struct functor_case_traits {
  |   typedef F fct_t;
  |   typedef functor_traits<F> fct_tr;
  |   typedef fct_t case_data;
  |   static const case_data& endata(const fct_t    & f) {return f;}
  |   static const fct_t    & dedata(const case_data& f) {return f;}
  | };

  次に functor_traits_chain の定義が来る。
  これは既定の functor_traits の実装に用いられている。
  あれでなければこれ、これでなければそれ、という具合にして優先順位の順に
  functor_traits の実装を条件式で切り替える手法で使う。

  実際の functor_traits_chain の実装は以下の include 先で行われる。

  | #pragma%include "bits/functor.link.function.pp"
  | #pragma%include "bits/functor.link.member.pp"
  | #pragma%include "bits/functor.link.operator.pp"
  | #pragma%include "bits/functor.link.variance.pp"
  | #pragma%x functor_traits_chain::terminate

  functor_ref/functor の類はこれまでに定義した物を利用して
  ごちゃごちゃと実装しているにすぎない様だ。
  実は多くの場合は functor_ref/functor は不要であり、
  ここまでの物の間で interface を分かりやすくすれば、
  functor_ref/functor の実装も簡単になるだろう。

  因みに functor_ref/functor の実装についても見てみる。
  →2017-02-06 "mwg/functor: functor_ref/functor の実装の再確認" を参照のこと。

  取り敢えず functor_adapter の様な物を作ろうか。

2016-10-26

* functor: gcc-2.95.3 bug workaround

  struct get_vaarg_variance の param を渡す所で駄目。

  [[Full Text Bug Listing>https://gcc.gnu.org/bugzilla/show_bug.cgi?format=multiple&amp;id=2513]]
  g++-2.95.3 ではクラステンプレートの中で定義されたテンプレートを、
  テンプレートテンプレートパラメータに渡せない様だ。

2016-04-04

* mwg/functor.h 整理が終わったが、気になる点が色々ある。
  これらについては後で対応を行う必要がある。

  todo: 現在 invoke を介して呼び出しているが分かりにくい。
    mwg/str.h に倣って adapter (byref, non virtual) を定義してはどうだろうか。
    或いは invoke は ... で幾らでも余分な引数を受け取れる様にしているが、
    adapter はそうだと困るので、その辺りの棲み分けを考えて両者を残すというのが良い。

    現在 invoke は外からも使える様になっているが、隠蔽する。
    公開するのは byref adapter という事にする。

  todo: invoke ... で余分に引数を受け取れる様にしている。
    しかし non-pod 型を ... で呼び出すと警告が発生するなど煩い。
    ここは適当にテンプレート引数で受け取って無視できるようにならないか。
    しかし、警告を発しているのが古いコンパイラだけという事を考えれば、
    対応するためにコードが複雑になる、もしくは、無駄に長くなるというのであれば対応しなくても良いかもしれない。

  todo: ref-qualifiers に対応する?

    C++11 → cv qualifiers 4 通り×ref-qualifiers 3通り with variadic
      多くのコンパイラで variadic templates の方を先に実装しているので、
      ref-qualifiers の対応には variadic templpates を前提として良い。
      (そうでないと大量の overload を用意しなければ為らず非現実的だ。)
    C++03 → cv qualifiers 4 通り×ARITY_MAX

  todo: invoke 周りの forward は一体どうなっているのか?

    C++11 ならば関数本体に到達するまで forward を繰り返すべきである。
    C++03 の時は、引数の型は基本的に T か T& か const T& かの3通りしかない。
    値の時は引数の型は T const& として受け取る様にすればよい。

  todo: 参照のメンバポインタ型の場合には何が起こるのか?

    ※メンバポインタを通して通常メンバの参照を取得するという意味ではない。
    メンバ自体が参照である場合に、今の実装で対応しきれているのかは非自明である。
    実装するときには特に意識した記憶が無いので、テストを追加して振る舞いを見る必要がある。

  todo: コピー構築できない型の場合には invoke の戻り値を渡せない?
    これは仕方がない。mwg::functor に限らず、関数を間接的に呼び出す事が不可能である。
    ただ、コピー構築できないという事をチェックしてその様に警告を出す様にできるかもしれない。

2015-09-23

* mwg/functor.h: functor_case の alignment は一体どうなっているのか…。


------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2017-07-22

* mcxx msc -MT .obj (for benchmark)

  adapter/msc が -MD で吐くファイルの target 部分が *.obj になってしまう問題。

  mmake では直接 -MT/-MQ を指定しているので問題ない。
  問題は何も指定せずに cxx を呼び出した時に既定で .obj になっていることである。
  しかし Makefile に書く時には gcc の側に合わせて *.o で書くのが普通である。
  この時に .obj でなくて .o になるようにするのが良い。

2017-07-06

* <algorithm> test

  std::rotate

* <any>

2017-06-30

* 謎: <algorithm> の関数の集合は不完全な気がする。例えば以下のようなものがない。

  - find_n

  - count_n

  - find_last

    std::reverse_iterator を使えば良いという人もいるがそれだと ForwardIterator に対して使えない。
    また、引数に渡すのに std::reverse_iterator を begin と end の両方に適用しなければならない。
    また戻り値を通常の iterator に戻すのに .base() を付加して、更に first でないことを確認して -- する必要がある。

  - find_ith

* ForwardIterator を指定するところに InputIterator を入れると変なことになるので、
  ForwardIterator のチェックはするべきなのではないだろうか。

  つまり、ForwardIterator と InputIterator は文法的には要求内容は同じである。
  但し、InputIterator は ++ が破壊的 (他のイテレータオブジェクトも影響を受ける) であるので、
  ForwardIterator と同様にして扱うと変なことになってしまう。


2017-06-27

* 多重定義解決の方法について再度確認する必要がある。

  特に、他の名前空間から using した関数と、
  その名前空間に定義した関数のどちらがどのように優先されるのか。
  同じシグニチャの関数は上書きされるような気がするが、
  微妙に異なるシグニチャの関数があったらどうなるのか。

  using namespace するのと、関数を個別で using するのでは振る舞いが異なるが、
  これはそれぞれ規格でどの様に記述されているのか。など。


2017-02-13

* そろそろ experimental のコンパイラに対するサポートは捨てて良いのではないか。

  ソースコードが汚くなっている原因である。
  特に様々な機能の組み合わせに応じて対応している部分である。
  必要な機能の一つでもなかった場合には C++03 と同じ実装にしてしまって良い気がする。

  →取り敢えず現状で実装して動いている物については気にしない事にする。
    新しく実装するものに関しては基本的に __cplusplus だけを見て判断する事にし、
    処理系のバグなどがあった場合には改めて検査を行う事にする。
  →そのために MWG_STD_CXX11, MWG_STD_CXX14 などのマクロを用意した。

  また、バグのない処理系での mwg/config.h という物も用意して良いのではないかという気がする。
  これは __cplusplus を用いてあるべき機能はあるとしてないかもしれない機能はないとすれば良い。

  テストが難しいという事もあるので、c++0x などの experimental 実装についてくる
  標準ライブラリは信用しないという事にした方が良いかもしれない。
  但し、type_traits などは C++03 の範囲では再現するのが難しい。
  そういった c++03 の範囲では実装できないものについてだけ experimental c++0x
  のライブラリを使用する様にするという手がある。


2017-02-09

* 以下の様な感じに記述できるライブラリがあると面白いかもしれない。

  | typename sig_t = typename mwg::mpl::eval<
  | progn_(
  |   start_template_<functor_traits_impl>,
  |   MemFun,
  |   cond_(
  |     type_traits::is_variant_function<sig1_t, S> (sig1_t),
  |     type_traits::is_variant_function<sig2_t, S> (sig2_t),
  |     type_traits::is_variant_function<sig3_t, S> (sig3_t),
  |     void),
  |   end_template_,
  | )>::type,

  でもこれはテンプレートで実装する <> が () に変わっただけの様な気もする。
  エディタのインデントが変になるという事がないというだけで、余り面白くない。

2016-10-26

* 演算子周辺のスペースの変更について

  done> functor.h

  ToDo: functor.h から #%include している一連の物
  ToDo: subdirectory 全て

  - \([^[:space:]:<*][:?,]\)\([^:>[:space:][:cntrl:]]\) -> \1 \2
    ※* < や > を除外するのは lwiki の /*? <? ?> に反応しない為である。
      演算子 > は二項演算子にしかないので ,:? の前後に現れる事はない。
      演算子 *, < に関しては前置演算子または二項演算子なので ,:? の前に現れる事はない。
    ※重複した一致 (例: 1,2,3 は 1,2 と 2,3 に一致しなければならない) があるので、
      2回全体の置換を試行する必要がある。

  - \(\_>\|[]})'"]\)\(\(?:||\|&&\|[-+*/%^|&<>=]\|>>\|<<\)=?\|!=\)\(\_<\|[*&!~({['"]\) → \1 \2 \3
  - \(\_>\|[])'"]\)\(\(?:[*/%^|&<>=]\|>>\|<<\)=?\|!=\|||\|&&\)\([-+]\) → \1 \2 \3

  - \([^$[:space:]]\)\({\) → \1 \2
    ※${...} は mwg_pp.awk で処理されるものである。少なくとも C++ の構造ではない。

  - \(;\)\([^;'"}[:space:][:cntrl:]]\) → \1 \2

  - \([])]\)\([^])>[.:?,;[:space:][:cntrl:]]\)
    → \1 \2 (閉じ括弧の後のスペース)
    ※これのノイズは多い。

  - \b\(for\|while\|if\|catch\|switch\)\((\) → \1 \2
    $ refact '\b(for|while|if|catch|switch)(\()' '\1 \2'
  - \(}\)\(catch\|else\|while\) → \1 \2
    $ refact '(\})(catch|else|while)\b' '\1 \2'

* mwg/bio/tape.h (tape_header): 64bit 整数に対応していない処理系の場合、
  64bit データの読み書きで間違いが生じる。そしてそれを検知していない。
  int64_t, uint64_t の無いシステムでは代替となる型を提供する必要があるのではないか。

  - mwg/bio/mwb_header.h でも同様。但し、こちらはコンパイルエラーになる。
    →mwg_config.mconf で 64bit 整数が存在するかどうかをチェックする事にした。
      MWGCONF_HAS_64BIT_INTEGER マクロを追加する。

  int64_t, uint64_t を自分で定義するとしたら何が必要になるだろうか。
  一番非自明なのは割り算になるだろう。
  愚直な実装方法としては絶対値が大きい限り引き算を繰り返すという物が考えられる。
  しかし複数の整数に分割して考えるのであれば、もう少しまともな実装を考える事ができるだろう。
  例えば最上位で割り算をしてみて引き算できる回数を見積もってから引き算するなど。

2016-10-16

* mwg::stdm: namespace mwg::stdm に実際に宣言を置く?

  つまり namespace detail で定義して using で引っ張ってくるのは駄目なのではという事。
  特に specialization を作る時に何処に作れば良いのかが分からない。
  というか、これを気にしだすと using namespace std も駄目という事になる。
  再現がないのでやはり気にしなくても良いだろうか。
  しかし特殊化を追加したい時に何処に追加したらよいか定まらないというのは問題である。

  或いは、下手に標準ライブラリの機能を引っ張ってこようとせずに
  自分で実装できるものに関しては全て自分で実装するという方針にする方が将来的に良いのかもしれない。
  まあ、将来的にといっても現在ではどのコンパイラも C++11 に対応していてバグもなくなってきているので、
  そんなに気にする所ではないのかもしれない。

2016-08-04

* mwg/str: std::unordered_map で使えるようにする為には hash を提供する必要があるのではないか。

  また std::map で使える様にする為には何らかの比較関数・比較演算子が定義されている必要があるのではないか。
  →比較演算子については一通り用意してある。これで std::map がOKなのかどうかも後で調べておく。

2016-04-11

* mwg/str: XCH の代わりに char_traits 的な物を受け取れる様にする。

  std::ctype<XCH> : std::locale::facet 的な物にも対応できると良い。
  但し std::ctype に直接対応するのは避けたい。virtual だから。

  また、静的な traits だけではなくオブジェクトとして設定を受け取れる様にもするべき。
  そうしないと文字の処理方法が動的に決まる場合に対応できない。

* property の実装には empty base optimization を用いれば良い?
  →駄目。property をデータメンバとして持たなければならないから、empty base にはできない。
    但し base class にする利点はある。static_cast で元オブジェクトのポインタを取得できる。
    マクロだとかを用いて持ち主オブジェクト内の自分の位置を抽出するなどの面倒は不要である。

  struct Rectangle{
    std::int32_t x,y,w,h;

    // property Left Right Top Bottom
    // property X Y Width Height
  };
  // sizeof(Rectangle) = 4*sizeof(std::int32_t)+8 = 24 bytes


* mwg/str: C++ で拡張メソッド (C#) 再考 - Extension methods in C++ Revisited

  | ToDo: 既存の記事
  |
  | # 拡張可能なメソッドの実装手法について。
  |
  | 現状の方法では文字列に対する操作をメンバ関数として実装している。
  | この実装方法では以下のようないわゆる "メソッドチェイン (method chaining)" の形で操作を記述できる。
  |
  |   my_str r = str.replace("a", "b").replace("c", "d").slice(1, 5).toupper();
  |
  | "メソッドチェイン" という単語はもともとは Ruby だか何かが提唱したものだろうか。
  | 勿論この様な書き方自体は Ruby に限ったものではなく様々な言語で繰り返されてきたものだと思われるが、
  | 殊に "メソッドチェイン" という呼び方に関しては、JavaScript での用例 (特に jQuery) を通して広まったような印象がある。
  | 因みに、JavaScript ではもっとぐちゃぐちゃに (適宜改行・インデントを入れて) 関数呼出を繋いだり入れ子にしたりするのが習慣である。
  |
  | しかし大問題がある。この方法だと新しい機能が欲しくなるたびに
  | 文字列クラス本体にメンバ関数を追加する必要がある。
  | このモノリシックな設計は良い設計とは言い難い。
  |
  | 一番無難な方法は、以下のような形にユーザに書いて貰うようなインターフェイスにする事である:
  |
  |   my_str temporary1 = replace(str, "a", "b");
  |   my_str temporary2 = replace(temporary1, "c", "d");
  |   my_str temporary3 = slice(temporary2, 1, 5);
  |   my_str r = toupper(temporary3);
  |
  | これで大人しく諦めておけば何も問題はない。
  |
  | ★しかしそもそも今回文字列のライブラリを新しく書いてみている動機が二つある。
  |
  | - ★一つが、まさにこの様な書き方が嫌だから (というか、もっというとメソッドチェインで書きたいから) というものである。
  |   なのでここで大人しく引き下がる訳には行かないのである。ひと暴れしなければならないのである。
  |
  |   ところで、上記の書き方の何が不満かについても書いておく――身も蓋もない言い方をすれば、**書くのが面倒**である。
  |   もっと説得力があるかも知れない (後付けの) 言い訳をすると、
  |   **記述が冗長だし、処理の流れが分かりにくい** という事になる。
  |
  | - もう一つの動機は、従来の std::string を用いて上記のように実装すると、
  |   無駄にメモリ (文字列を記録する領域) の確保・解放が起こり効率が悪いことにある。
  |   長い操作のチェインでも一回のメモリ確保で済むようにしたい。
  |   思い返して C言語で地道に実装するとなるとその様に記述するはずである。
  |   文字列処理がボトルネックになるケースで、C++ (std::string 利用) が C 言語に較べて滅茶苦茶遅くなる理由はここにある。
  |   ★C++ で記述を楽して、でも中では C 言語の様に処理したいという時は式テンプレートにすれば良い。
  |   しかし、上のように分断して書いてしまっては式テンプレートも出番無しである。
  |
  | **通常関数で頑張る
  |
  | さて、こういう時は案外無難な方法を模索すれば良い方法が見つかることもある。
  | 取り敢えず無難な方針でしばらく考えてみる。
  |
  | (ref) のコードは、無理矢理以下のようにまとめる事も出来る。
  |
  |   my_str r = toupper(slice(replace(replace(str, "a", "b"), "c", "d"), 1, 5));
  |
  | しかしこれは如何にも見にくい。
  | といって入れ子の階層に従って改行・インデントをしたとしても、
  | これはこれで見にくいしかつ嵩張りすぎである:
  |
  |   my_str r = toupper(
  |     slice(
  |       replace(
  |         replace(
  |           str,
  |           "a", "b"
  |         ),
  |         "c", "d"
  |       ),
  |       1, 5
  |     )
  |   );
  |
  | 引数の順序を変えれば多少は見やすくなるかも知れない。
  | つまり、操作対象の文字列引数を最後に持ってくることにする:
  |
  |   my_str r = toupper(
  |     slice(1, 5,
  |       replace("c", "d",
  |         replace("a", "b",
  |           str
  |         )
  |       )
  |     )
  |   );
  |
  | Lisp みたいに (括弧の対応をエディタに任せて) 書けば、嵩張る問題も許せるレベルになる:
  |
  |   my_str r = toupper(
  |     slice(1, 5,
  |       replace("c", "d",
  |         replace("a", "b",
  |           str))));
  |
  | しかしそれでも見た目が良いとはいいがたい。
  | 少なくとも、保守的な C++ コードに慣れた者に見せたら何だこのスタイルはと言われるに違いない (たぶん)。
  | 世の中にはもっと怖い物知らずな書き方をする言語もあるので、そういった物に慣れている人は何も思わないに相違ないが。
  |
  |
  | こうやって眺めてみるとメソッドチェインの良い所が改めて浮き彫りになる。
  |
  | - それは偏に操作対象が明らかであるという事にある。
  |
  |   唯の関数として記述すると "操作対象である文字列の引数"
  |   と "操作を記述するそれ以外の引数" が見た目に区別できない。
  |   しかし、メソッドチェインの形式だと、操作対象と、操作自体を記述する引数が区別されている。
  |   勿論関数のマニュアルを見てどの引数がどれに対応してという事を確認すれば (或いは暗記しておけば)、
  |   考えればどれが操作の対象であるかなどと言う事はすぐに分かる事であるが、
  |   しかしそれでも、考えて分かるというのと考えなくても明らかというのには大きな隔たりがある。
  |   文字列が少しずつ変形を受けていくという処理においてメソッドチェインは自然なのである。
  |
  | **Boost Range Adapters 的な手法
  |
  | これを避ける為の方法として Boost Range Adapters '|' 的な演算子の overload を用いる方法がある。
  | (他に、Boost Format '%' だとか Boost Assignment ',' だとか、
  | 更に悪名高き std::iostream '<<' もこの口である。
  | こういう "左辺に操作を施して返す二項演算子" を用いてチェインを作るイディオムには名前が付いているのだろうか。
  | こんなに広く利用されているのに、Boost Range Adapters 的なとしか表現できないのは悲しい。
  | 誰か名前を教えて欲しい。
  |
  | ★余談: 驚くべき事に "boost::assign" "boost::format" "boost::adaptors" で Google 検索すると 17 件しか当たらない。
  |   そして何れのページでもこれらに共通するパターンについての指摘は見えない様だ。
  |
  | 余談: 代入演算子も左辺を返す二項演算子であるが、左結合ではなく右結合なのでチェインにするには具合が悪い。)
  |
  | ★余談: そういえば iostream の演算子多重定義に対する批判は偶にみかけるが、
  | Boost hogehoge の同様な演算子多重定義に文句をいう人は見たことない。
  | 両者に何か決定的な違いがあるのかと考えてみたが、他言語から来た人は初めはシフト演算子の謎多重定義に違和感を感じて文句をいうが、
  | Boost に辿り着く頃には閉口しているというだけのことだろうか。

  References

  http://nyaruru.hatenablog.com/entry/20080316/p2 # C# におけるメソッドチェイン
  http://p-monster.hatenablog.com/entry/2012/11/16/000000 # C++テンプレートテクニック11章 Extension Member Functions
  http://gimkondo.blog98.fc2.com/blog-entry-3.html # 特殊化をマクロに置き換えるというだけのことである。ひどい実装だ。
  http://www.boost.org/doc/libs/1_60_0/libs/format/doc/choices.html # Boost.Format % を選択する時の問題と考察

  ■ToDo: 過去の様々な人の試行錯誤についてまとめる
  ■ToDo: operator chain に名前がついていないか色々の本を調べる
  ■PEM 提案についての言及 N3863 本の虫
  http://cpplover.blogspot.jp/2014/11/cunified-call-syntax-n4165-n4174.html # 本の虫 提案 N4165 N4174

  | 優先順位に注意する必要がある。
  |
  | x しかしこの方法の一般的な問題点の一つとして演算子の優先順位がある。
  |
  |   例えば << を用いると、
  |
  |     std::cout << x^0x3b;
  |
  |   は (std::cout << x)^0x3b と解釈されてしまう。
  |   注意深く括弧が必要かどうかをユーザに判断させるのは問題があるし、
  |   かと言って常に括弧で囲んで使うようにしてくれと言うのも面倒だし、強制力がない。
  |   この様な意図しない結合を避ける為にはできるだけ優先順位の低い物を使えばよい。
  |   特にこの様な場合は、operator| が良さそうである。
  |   operator| より低い優先順位の演算子として論理演算子 (&&, ||, ?:) や代入演算子が存在するが、
  |   多くの場合 operand として論理演算子式や代入演算子式がくるような事は少ないだろう。
  |
  |   しかし、いつでも優先順位の低い | を使えば良いという訳ではない。
  |   例えば、文字列の場合には比較演算を行いたいので、| を用いると問題が生じる。
  |
  |     str1|toupper() == str2|toupper()
  |
  |   は、意図に反して
  |
  |     str1 | (toupper() == str2) | toupper()
  |
  |   と解釈されてしまうのである。これについても安全の為に常に括弧をつけるのは面倒である。
  |   今回の目的ではメンバ関数的な物を好きに追加できる事を目的としている。
  |   もし右辺として関数呼出の形しか想定しないのであれば、
  |   実は逆に結合強度の高い物を使う事ができる。
  |   特に、うってつけの演算子として ->* が存在する。
  |   というか正に拡張メソッドのために ->* の演算子オーバーロードが
  |   できる様になっているのではないかという気配すらある。
  |
  |     str1->*toupper() == str2->*toupper()
  |
  |     注意: これは (str1->*(toupper())) == (str2->*(toupper())) の様に解釈される
  |
  |   一般的な状況に対する解ではないが、今回は ->* で考えることにする。
  |
  |   > 余談:
  |   >   ->* 演算子を使う場合、演算子の優先順位の都合で、
  |   >
  |   >   ((str ->* replace)("a", "b") ->* replace)("c", "d");
  |   >
  |   >   の様な具合に一々余分な括弧をつけなければならないイメージだったが、
  |   >   これはメンバ関数へのポインタの時だけの制約であることに今更ながら気づく。
  |   >   自分で好きに設計できる場合には
  |   >   a 先にオブジェクトを受け取ってから引数を受け取る様にも設計できるし、
  |   >   b 或いは、先に引数を受け取っておいてからオブジェクトと結合する様にも設計できるのである。
  |
  |   > 余談:
  |   >   改めて拡張メソッドで検索してみたら以下の記事でも ->* に到達している。
  |   >   [[「や」の字: (今更) C++ で拡張メソッド>http://yak-ex.blogspot.jp/2012/09/c.html]]■
  |   > http://d.hatena.ne.jp/pastel-magic/20090512/1242120459■

■"*" で chain にするというコメント (何処かで見た)

  実は C# 拡張メソッドと較べた時にもう一つ不便なことがある。それは関数名の名前空間である。
  メンバ演算子 `.` や `->` の右辺の識別子は左辺のクラスのメンバから探してくれるので、
  クラス外にある関数と名前が衝突する心配なく自由にメンバ名をつける事ができた。
  しかし、演算子多重定義にした場合、拡張メソッドの関数はクラス外に定義しなければならない。
  従って `replace`, `slice`, `toupper` の様に他でも使いそうな名前で関数を定義するのに抵抗がある。
  同一の仮引数を持った通常の関数があると多重定義できなくなる。
  もっとありそうなのは、異なるクラスについて同名の拡張メソッドを定義したい場合だが、これも面倒である。

  インターフェイス2 [nested] の場合には引数に拡張対象のクラスが含まれるので ADL に頼る事ができたが、
  演算子チェインによる拡張メソッドの場合には引数に拡張対象のクラスは含まれないので ADL は使えない。

  従って、以下のような感じにしなければならない。

  ```cpp
  my_str r = str ->* my::extensions::replace("a", "b")
                 ->* my::extensions::replace("c", "d")
                 ->* my::extensions::slice(1, 5)
                 ->* my::extensions::toupper();
  ```

  もしくは、

  ```cpp
  {
    using namespace my::extensions;
    my_str r = str ->* replace("a", "b")
                   ->* replace("c", "d")
                   ->* slice(1, 5)
                   ->* toupper();
  }
  ```

  x もう一つの問題は識別子の名前空間である。

    メンバ関数の名称は、メンバ名の名前空間的な物(?)の中に追加されるので、
    通常の変数や関数 (静的スコープの変数・関数、局所変数、 etc) と名前が衝突する心配はなかった。
    つまり自由に名前をつける事ができた。

    しかし、非メンバ関数として定義するとすると、他の識別子と衝突する危険性があるので、
    toupper だとか slice だとか replace だとかの様な一般的な識別子を使いがたい。
    toupper() だとか replace() だとかの引数に自作文字列が来る訳ではないので ADL も使えない。


    …それとも std::hex や std::flush の様に、
    識別子の衝突など気にせずズバっと定義してしまえばよいのだろうか。

  結局この方針で現実的なのは最後の方法だろうか。

  | しかし書いていて思ったのだが ->* は入力しにくい。(何故 ->* は多重定義できて .* が多重定義できないんだ…。)
  | この際、次の優先順位の * でも良い気がする。->* が使われる事は滅多にないだろうから。
  | それに、toupper() だとかを右作用素的なものだと思えば、乗法 * で繋ぐのも見た目は悪くない。
  |
  |   {
  |     using namespace string_adapters;
  |     my_str r = str * replace("a", "b")
  |                    * replace("c", "d")
  |                    * slice(1, 5)
  |                    * toupper();
  |   }
  |
  | ※最近 Qiita の誰かの記事の誰かのコメントで * を使うのが一般的というような物があった気がするのだが、
  |   改めて探そうとしても見つからない、というか、どうやって探すのかが分からない。
  |   心当たりのある人がいれば教えてほしい。
  |
  | 或いはこんなんでも良い:
  |
  |   {
  |     using namespace string_adapters;
  |     my_str r = str( replace("a", "b") )
  |                   ( replace("c", "d") )
  |                   ( slice(1, 5 ))
  |                   ( toupper() );
  |   }
  |
  | これなら演算子の優先順位の問題はない。何處までが "拡張メソッド" 呼び出しなのか見た目に明らかなので混乱する余地が無い。


  でもこんな調子だと、先に述べた問題点

  > 少なくとも、保守的な C++ コードに慣れた者に見せたら何だこのスタイルはと言われるに違いない (たぶん)。

  に関してどんどん悪くなっている気がする。いっその事 '<<' にした方が標準ライブラリの実例もあるし許容されやすいかも。

  **Decorator による方法

  或いはメソッドチェインを積極的に利用している jQuery を真似して、
  拡張オブジェクトというかラッパーオブジェクトを作る。
  雰囲気としては、例えば、`replace_extensions` だとか
  `slice_extensions` というクラスの中に何らかの方法で拡張メンバ関数を定義しておき、以下の様な感じに使う。

  ```cpp
  typedef extended_object<my_str, replace_extensions,
                                  slice_extensions,
                                  foo_extensions,
                                  /* … */
                                  > ex_str;

  ex_str str = /* 略 */;
  ex_str r = str.replace("a", "b").replace("c", "d").slice(1, 5).toupper();
  ```

  具体的に extended_object だとか replace_extensions をどう定義するかということだが、
  extended_object を元のオブジェクトから派生させれば良い (Decorator)。

  ■ToDo: 実現可能性確認

  ```cpp:ライブラリの内側
  template<typaname Obj,template<typename CRTP> class... Extensions>
  class extended_object:public Obj,public Extensions<extended_object<Obj,Extensions...> >...{
    typedef Obj object_type;
    using Obj::Obj;
  };

  template<typename CRTP>
  class replace_extensions{
    typedef typename CRTP::object_type object_type;

  private:
    // オリジナルのオブジェクトを取得
    object_type& _this(){return static_cast<object_type&>(static_cast<CRTP&>(*this))}
    object_type const& _this() const{ /* 略 */ }

  public:
    CRTP replace(const char* target, const char* replacement) const{ /* _this() を使って操作 */ }

    /* 他にも色々拡張メンバ関数追加 */
  };
  ```

  ----

  とか色々考えあぐねて踏ん切りがつかず、そのままメンバ関数で実装したままである。
  Ruby とかの前例があるし、文字列クラスみたいな基礎部分ぐらいは、
  巨大なユーティリティクラスでもいいじゃないかという気がしてきたり。

2016-03-24

* SD-6 support

  C++ に SD-6 という recommendation ができて C++11/14/1z
  の各機能の実装状況について調べられる様になった様である。
  libmwg のテストを更新しようという事になった。

  SD-6 に関する文書は以下にある。
  [[本の虫: SD-6: 機能テスト>https://ezoeryou.github.io/blog/article/2014-12-16-feature-test.html]]
  [[SD-6: SG10 Feature Test Recommendations : Standard C++>https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations]]

  今迄 libmwg のテストの名称は clang を元にしていた。
  その為か既に記述してあるテストについては名称は全て SD-6 の物と一致していたので変更はない。
  また、SD-6 では機能の version (どの論文に従った実装なのか) に応じてマクロに値を持たせる。
  既に libmwg にあるテストで対応する SD-6 マクロが存在する物に関しては値を一致させる。

2016-03-22

* xprintf: wchar_t, etc. 対応
* xprintf: template 部分を xprintf.cpp から xprintf.h に移動
  明示的インスタンス化を省略できる様にする。
  同時に str.support.xprintf.h も xprintf_writer ではなく
  template を利用した実装に切り替える。

2016-03-18

* mwg::strbuf: strbuf のテストを追加する。■
* mwg::strbuf: strbuf の破壊的機能を実装する。■

2016-03-07

* mwg/str: char_reference 名称再考?

2016-03-03

* string: strbase::insert(char_type c,range-spec) に対応する。

  現在の replace の実装は寧ろ splice という関数名に変えた方が良いのではないか。

* find_any, find_not, その他文字集合を指定する overload は、
  Boost, CLX の様に is_any_of() predicate か何かを用意すれば解決するのではないか。
  しかし、記述が面倒になる。よく使いそうな機能についてはそれ専用の overload があっても良い気がする。

  例.  s.find_any("<>")
    -> s.find(mwg::is_any_of("<>"));
    -> s.find(mwg::glob("[<>]"));
    -> s.find(mwg::rx("[<>]",mwg::rx_glob));
    -> s.find(mwg::rx("[<>]"));
    -> s.find("[<>]"_rx);

  例. s.ltrim("<>")
    -> s.ltrim(mwg::is_any_of("<>"));
    -> s.ltrim(mwg::glob("*([<>])","k")); // ksh extension

* #include <mwg/string.interop.cstring.h>

2016-03-02

* string: 現在の文字列インターフェイス (予定)

  以下実装済

  mwg::str_detail::strbase<Policy>
    全ての文字列クラスの基底クラス。
    基本的な非破壊的操作関数を備える。

  mwg::str_detail::strfix<XCH>
    固定文字列。データを他の文字列と共有しうる。

  mwg::str_detail::strsub<XCH>
    他の文字列、データに対する部分文字列を表現するクラス。

  mwg::str_detail::strbuf<XCH>
    編集用の文字列。参照の複製はされない。
    自己破壊関数も備える。

  以下は廃止された

  % mwg::str_detail::stradp<XCH>
  %   アダプタ。実質的に strsub と等価。
  %   # 唯一違う点は様々なクラスインスタンスから implicit に構築できる事。
  %   # 文字列の類を受け取る関数の引数の型などに用いるのが目的。

  →従来はこの一つの型によって様々な文字列からの変換を考えていたが、
    現在は、変換元の型により実装を自由に切り替えられる様にし、
    またどれを用いるかについても mwg::str というテンプレート関数で自動選択する様にした。

  以下は実装予定

  mwg::str_detail::strsymb<XCH>
    インスタンスの単一性を保証するクラス
    等値比較が、ポインタを比較するだけで済むので楽。
    比較的長い文字列で同じ物が沢山現れる場合にはメモリの節約にもなるかも。

    クラス名に関しては一考の余地有り。
    ruby では symbol と呼ばれている物である。

  mwg::str_detail::strsymb_dictionary<XCH>
    strsymb の親クラス。
    存在しているインスタンス全てをこの中に保持して管理する。
    デフォルトでグローバルに使用できるインスタンスを生成するが、
    ローカルに使いたいシンボル群を管理する為に、自分でインスタンスを生成する事も可能にする。

    内部構造は取り敢えず std::map (sorted list) で二分探索。
    将来的には trie を考えても OK

  mwg::str_detail::strpath<XCH>
    ファイル名を管理する為の文字列。
    ファイル名を操作する関数を備える? operator/

2016-02-29

* string: できるだけ operator[] ではなく iterator を使って処理を行う。

  特に複数の連続した文字を取り扱う様な処理では iterator を使うべき。

  - 但し、operator[] の呼び出しに対しては operator[] を使うのは気にしなくて良い。
    つまり、次の operator[] 呼び出しを予期して位置と状態を内部にキャッシュするなどの処置はしない。
    その時の非効率性は元々の operator[] の呼び出し元が責任を持つべきである。

  従来の iterator の要件だけでは、様々な処理をするのに不十分である。
  データを連続に読み取って行う処理を一通りできる程度の機能は有するべきである。
  iterator の要件として i+offset, i-offset, i-j, --i を追加する。

  - 逆方向に辿る事ができない様な文字コードの場合、この要件を満たすのが難しいかもしれない。
    その様な文字コードがあるとしたらその文字コードがいけないのである。
    もしその様な文字コードを使用しての処理を無理にでも行うとすれば、
    iterator を生成する際に文字列全体に対するインデックスを生成する様にしてしまえば良い。

    a 例えば、index -> byte offset の様な対応を行う配列を用意する。
      データ量の節約の為、5 文字か 10 文字ごとにこの対応を覚える様にする。
      覚えていない位置へ移動したくなったら、その直前の記録位置から辿る様にする。

    多少非効率になるかもしれないが、その様な文字コードを使用するのは現代に於いては稀であるだろうし、
    その文字コードを使用した時だけの非効率性なので問題とはしない。
    何れにしても iterator として使いそうな機能は一通り要求して良いだろう。

  > trim, ends は iterator を用いて書き直した。
  > find の系統は全て書き直す必要がある
    意外と変更点は少なくて済んだ。template で書かれている御陰である。

  - default_const_iterator についても書き直す必要がある。

    現在は (buffer,index) のペアとして記述していて、
    値を読み出す時は毎回 buffer[index] として値を取り出している。
    これでは iterator にしている意味が余りない。
    本当は実際の buffer の詳細に応じて連続的にポインタを動かせる様に工夫するべきである。
    特に、multibyte に対応する時には buffer[index] の様にすると
    値を読み出すたびに文字列の先頭から文字を数えなければならず大変である。

    これを解決する為には buffer 毎に const_iterator を実装する必要が出て来る。
    現在の default_const_iterator の実装では、
    buffer 毎の処理の違いを共通インターフェイス operator[] に押し付けている。
    しかし、連続的に移動するという情報を利用して効率化する為には、
    この operator[] の実装毎に、対応する最適化が必要になるからである。

    > _strtmp_sub_policy
    > _strtmp_map_policy
    > _strtmp_ranged_map_policy
    > _strtmp_pad_policy
    - _strtmp_cat_policy<2>
    - _strtmp_cat_policy<3>
    - _strtmp_repeat_policy
    - _strtmp_reverse_policy

    ■実は元になる iterator がポインタの場合には、
      default_const_iterator の方が効率がよいのではないか。

2016-02-27

* mwg::string multibyte character 対応

  文字の抽出と境目の判定を行う関数を用意して一般的に処理する?

  - 本来は、内部的には utf32 か utf16 を直接使うなどしたい。
    しかし乍ら可変長の文字コードのまま使用したいという需要は無視できない。
  - slice, remove, insert などは OK
  - tolower, toupper は OK だが、
    一般の map 関数については実装を変える必要がある。
    文字列の長さが変更される可能性があるので。

  多少観察してみた。基本的には buffer を弄れば何とかなりそうな気がする。

  - multibyte における文字型 char_type は
    multibyte 文字が格納できるぐらい大きな整数、
    もしくは、ベクトル型となる。
  - これは格納に用いる型 element_type とは異なる事に注意する。
  - operator[], length() などは char_type 単位の操作を提供する。
    begin, end も char_type 単位に列挙する反復子として定義する。
  －get_ptr だけは element_type 単位の操作を行う為の物とする。
    現状ではこれは strsub の定義にしか使用していない。
    この部分に関しては offset をずらす為の displacement について
    multibyte を考慮したものに書き換えれば良いだけである。

  - operator[] を直接使って処理を行っている箇所は
    できるだけ iterator を使って処理を行う様に書き換える必要がある。


  * string.multibyte: operator[] を multibyte で実装する場合には、
    終端位置と開始位置の近い方から scan を行うようにすると良い。
    但し逆方向からスキャンできない様な種類の文字コードを使っている場合は駄目である。

  * string.multibyte: JIS などの様に途中状態が存在する様な文字コードはどう取り扱うか?
    特に substr は途中からのデータの部分列を保持することになる。
    データの部分列だけを取り出しても、文字列として部分列にならないのである。
    この場合は substr に途中状態も一緒に覚えて置かなければならない。

  * 或いは substr 自体 iterator pair として実装するのが良さそう。

2016-02-25

* [2012-11-13] mwg::string: 関数名

    重要なのは分かり易くて、面倒でない関数名である。
    それぞれのライブラリで、どの機能にどの様な名前が与えられているかを調べる。

  + C++ 標準ライブラリ
    <a href="http://www.cppll.jp/cppreference/cppstring_details.html#find">C++文字列</a></li>
  + Boost String Algorithm Library
    <a href="http://www.boost.org/doc/libs/1_52_0/doc/html/string_algo/quickref.html">Quick Reference - 1.52.0</a>
    ※ Boost では基本的に破壊的操作を行う関数であり、
    _copy がついている物が新しいインスタンスを生成する関数である。

  + ATL/MFC CStringT
    [[CStringT Class>https://msdn.microsoft.com/en-us/library/5bzxfsea.aspx]]
  + CLR
    <a href="http://msdn.microsoft.com/ja-jp/library/7wtc81z6(v=vs.80).aspx">String メソッド (System)</a></li>
  + mwg-string
    <a href="../../dist/mwg-string/doc/document.htm">lib-string 更新履歴</a></li>
    初期の実装。CLR と似たような形式で関数名を決めていた。

  + Java
    <a href="http://docs.oracle.com/javase/jp/6/api/java/lang/String.html">String (Java Platform SE 6)</a></li>
  + JavaScript/ECMAScript
    <a href="https://developer.mozilla.org/ja/docs/JavaScript/Reference/Global_Objects/String/prototype#Methods">String.prototype - JavaScript | MDN</a></li>

  + ToDo: Perl
    <a href="http://www.perlplus.jp/func/string/">文字列に関する関数 - Perl関数のリファレンス</a></li>
  + ToDo: PHP
  + Ruby
    <a href="http://doc.ruby-lang.org/ja/1.9.2/class/String.html">class String</a></li>
  + CLX C++ Library
    [[CLX C++ Libraries>http://clx.cielquis.net/]]
    基本的には Ruby の命名を踏襲している様であるが、
    多用な引数を受け取る様にして hoge_if などの様な関数も追加している。

  + AWK (gawk)
    <a href="http://www.kt.rim.or.jp/~kbk/gawk/gawk_13.html">The GAWK Manual - 組込み関数</a></li>
  + Makefile

2015-10-19

* vc9 support

  - is_default_constructible for `struct Test1{Test1();};`
  - mwg/concept.h: has_add_operator 関連を正しく実現する方法を模索する。
  - mwg/std/limits: long double に対するサポート。

2015-10-15

* tuple 再設計

  % 現状の operator= の実装だと `tuple<int&> a,b; a=b` が参照ではなくて値をコピーする事になる。
  % (これは旧来の実装でも同じ問題を抱えていた。)
  %
  % 結局正しくコピーを実装する為には reference_wrapper を使用するしかないのだろうか。
  % というか標準の代入演算子は一体どの様になっているのか??
  % →参照メンバを持つクラスはそもそも代入演算子は定義されない様である。
  %   (※後述の通り、tuple では std::tie(x,y) = ... の様な使い方をする為に敢えて代入演算子を定義し、
  %   参照メンバの代入に関しては「参照先に値を書き込む」動作を行う。)
  %
  % と思ったが、寧ろ値をコピーするという動作の方が正しいのかも知れない。
  % というのも std::tie(x,y)=std::make_tuple(a,b); の様な使い方をするからである。
  % もしかしてそもそも C++ 構造体の参照メンバの代入について勘違いをしている???
  % →どうやら勘違いをしていた様である。そもそも参照メンバが存在している時はクラスの代入演算子は削除される。
  %   std::tuple の場合は代入演算子を敢えて定義して、参照先に値を代入できる様にしている事に注意する。

  →寧ろ値を参照先に書き込むという動作で正しい。

  tuple 実装上の注意:

    コピー代入演算子について

      通常参照をメンバに持つクラスはコピー代入演算子を持たない。
      tuple の場合は特別にコピー代入演算子を定義して参照先の値を書き換える動作として実装する。
      これによって std::tie(x, y) = std::make_tuple(1, 2); の様な使い方が可能になる。

  * tuple_cat は tuple_push/tuple_unshift ではなくて tuple_pop/tuple_shift を使って実装する方が自然である。

  ToDo: memberwise construction は各メンバ copy constructible である必要があるのではないか?
    何れにしても template で初期化する様にしたので、memberwise のコンストラクタを呼び出さない限りはエラーにはならない。

2015-09-22

* tuple のテスト達。今は #if 0 ... #endif で囲んでいる。

2015-09-21

* mmake が要求するコマンド群

  bash gawk perl iconv

* mwg/xprintf.h: xprintf_convert, create_xprintf_writer を定義する namespace を変更する?

  現在は mwg::xprintf_detail になっている。
  実は mwg でも良い様な気がする。xprintf_* という関数名なので他と混じる事もない。

  adl_helper を mwg/defs.h に移動する。xprintf_convert を mwg 名前空間に出す。

2015-09-20

* mwg/xprintf.h: 一応引数は完全 forward しているが、
  位置パラメータ N$ 等を用いると複数回引数を読み取る事が可能である。
  つまり、各関数は右辺値参照を受け取ってもそれを破壊するべきではない。

* mwg/xprintf.h: %; で std::flush, std::fflush, etc.?

2015-09-18

* mwg/std/type_traits ToDo

  is_null_pointer for C++11
    is_null_pointer は C++14 で導入された。
    C++11 未満では追加したが、C++11 はそのまま使っているので補填する必要がある。

  aligned_storage,
  aligned_union,
  underlying_type,
  result_of,
  max_align_t in <cstddef>

* mwg/xprintf.h: tuple_element_select 関連の整理。

2015-06-21

* std::tr1

  using namespace std;
  using namespace std::tr1;

  としていると両方で定義されている物を stdm:: を介して使おうとするとエラーになるということがわかった。

* mwg/bio/tape.h

  サポートされていない操作をした時の動作について整理しておいた方が良い。
  現状だと例外を投げたり投げなかったりまちまちである。
  目安としては以下のようにしたらどうだろう?
  - tape を初期化した当初からその操作を実行できないことが明らかである場合は例外を投げる
  - tape の現在の読み取り状況などの都合によって実行できなかった場合は戻り値で返す
  そうすると現状の実装ではだいたい例外を投げるのが正しい動作ということになる。

2015-06-19

* とりあえずビルドのシステムの構造に関しては現状で問題無いと思う
  現状の構造について再度まとめることにする。

  src/Makefile.pp の書き方:

    BASE=..
    source $(BASE)/mmake/
    #%x prologue
    #%x epilogue

    ■ToDo もっと説明を追加する

* 自動で mmake 初期化を実行する仕組みを作る
  (mcxx に統合して mcxx +project init などとする手もある)

* test の方法についてより様々な種類のものを提供できるようにする?
  - コンパイルテスト・実行テスト・出力テスト
  - コンパイルが失敗する事を期待するテスト
  - テストを簡単に生成する mwg_pp マクロ?

* experimental な物をいつ統合するのかについて

  exprimental な実装や他のプログラムで作成したライブラリをどの様に統合するかのルールは作っておいた方がよい様に思う。
  例えば、複数のプロジェクトで同じコードを共有したくなった時に統合を行うとする?

  しかし、統合対象となるサブライブラリの中に更に experimental で余り使われていない
  機能 (であるが実装の根幹に入り込んでしまっている) 様な物がある場合に、
  その部分をどう扱うかは微妙である。例えば tape.h から使われている
  static_flags や iprint, yield, enumerable などの物のことである。
  tape.h 自体は様々なところから利用するので便利である。
  しかし static_flags や iprint, yield, enumerable は tape.h からしか使われていない。
  つまり余り interface としても洗練されていないし本当に必要なものだったのかというのも疑問である。

2015-06-15

* CXXCFG 毎の設定 #20150620.CXXCFG

  設定切り替えに関しては CXXCFG を用いて切り替える。
  CXXCFG を用いて切り替える際にどこにそれを記述するのかについて考える必要がある。
  CXXCFG に対応するファイルを作成してその中に設定を書き込むという方法もある。
  あるいは、どこかに hoge.mk の中に CXXCFG 毎の条件分岐を記述するという手も存在する。

  →$BASE/config.mk に設定を書き込むことにした。
    config ごとにファイルを作成してそこに書き込むのは面倒すぎる。管理が面倒である。
    再利用したい設定に関しては独立したファイルとしてコピーできる様にすると便利という考え方もあるが、
    その様な複雑な設定(?)は限られていると思われるし、
    複雑といっても程度があるので取り敢えずは、
    ファイルとしてではなく設定の文字列をコピーして管理する方針で行く。

* 環境変数 CXX CC FLAGS 等の情報をどのように取り入れるべきか?

  CXXCFG に関して → [[CXXCFG 毎の設定>#20150620.CXXCFG]]

  設定の取り込みに関しては少し考える必要がある。
  基本的に通常の場合と似たような振る舞いにするのが分かりやすい。
  しかし、環境変数によって取り扱い方が異なるのでそれについて確認しておく。
  1 先ず CXX CC FLAGS CXXFLAGS 等の情報は通常は ./configure の際に指定する。
    ./configure よりも後に値を変更したりしてもコンパイルには影響されない。
    そして g++ 等の呼び出しの際に直接に引数に指定することで適用される。
  2 一方で CPLUS_INCLUDE_PATH LIBRARY_PATH 等はコンパイルの実行時の情報が参照される。
    これらは通常は ./configure & make では設定されないし消去することもない。
    つまりビルドシステムはこれらの環境変数に対しては透過的である。

  現状の管理方法についても確認しておく。
  これらの環境変数の設定に関しては現在はコンパイラ側、つまり mcxx 側で勝手に制御している。
  mcxx にコンパイラを登録する時に CXX CC FLAGS および CPLUS_INCLUDE_PATH 等も取り込む。
  そして *_PATH に関しては、コンパイラを登録した時の PATH を勝手に追加する。
  また、FLAGS 等の値に関してはコンパイラを登録した時の値で上書きする (?)。
  実際に使っているかどうかについては疑問である。
  というのも mcxx には source $(mcxx +param config) 的な
  方法で環境変数をロードする仕組みもあるからである。

  ToDo:
  - mcxx の config as env-source files の仕組みは廃止する
    本当に廃止しても大丈夫か? これは g++/cl 等と直接入力して使う方法を封じることになる。
    特に cl に特別な引数を渡したいときに困るのではないだろうか。
  - mcxx の CC・CXX・CFLAGS・CXXFLAGS・LDFLAGS・FLAGS 取り込みは行う。
  - mcxx のCPLUS_INCLUDE_PATH・C_INCLUDE_PATH・LIBRARY_PATHに関しては限定的にする。明示されなければ追加しない。
  - mcxx に上記のパラメータの一覧を表示する仕組みを作る。

2015-05-15

* 識別子の衝突の問題

  同じ識別子に複数の異なるテストが割り当てられても気付かない可能性がある。
  そうすると片方のテスト結果がもう片方の結果を上書きしてしまう事になり予期しない結果になる。
  一つの解決方法は mwg_config.h の結合時に識別子の重複がないか確認する事である。

  しかし、重複する識別子を完全に禁止した場合、
  異なるファイルに同じテスト内容が存在する場合に不本意な結果になる。
  例えば、同じテスト内容に異なる (例えばファイル名をプレフィックスとした様な) 識別子をつけるという手もある。
  しかし、折角同じテストであるのだから統合したい。テスト内容を修正する場合にもそちらの方が都合が良いだろう。
  結局、複数のファイルの間で共有する可能性のあるテストに関しては今迄通り外部のファイルに記述するというのが現実的だろうか。

* check の依存性の問題

  大量の include を含めると Makefile の読込が遅くなるのではないか、という懸念。
  -include ....mk を纏めるという事

  当初は Makefile がこれ以上重くならない為に check の依存性まで含めるのを躊躇していたが、
  Makefile が重くなる原因が判明し、これが問題にならない様であるという事が分かったので余り気にしないでよい。


------------------------------------------------------------------------------
  ChangeLog
------------------------------------------------------------------------------



------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2017-07-24

* mmake -MP

  コンパイラの更新などでシステムヘッダが移動・削除された場合に、
  依存関係のファイルがないと言ってコンパイルできなくなる。
  これを防ぐために空の prerequisite を生成するオプションがあったはずだ → -MP だ。

  mcxx/adapter/msc は -MP に既に対応している。
  gcc-3.3.6 は -MP に対応している。
  mcxx/adapter/gcc for gcc-2.9.5 は -MP に対応していない → 対応した。

  更に mwg_pp.awk も -MP に対応したいところである → 対応した。

  取り敢えず様子を見る。

* mwg::c2t, mwg::c4t の実装として char_t<T, CP> を使う事について

  そもそも mwg::c4t で char32_t が使えない時に実装を char_t<T, CP> にしている意味は何だったか。

  将来的に何らかの文字列クラスを設計する時に使うために char_t を定義した。
  その特殊化として c4t というものを定義しようと目論んだ。
  しかし文字列クラスとしてそのような物は結局実装していないので char_t の CP は現状で意味を為していない。

  - そもそも char_t<T, CP> の存在意義はあるのか? 文字自体が文字コードを持つ事の是非?

    更に文字自体が文字コードを持つほうが良いのか、それとも文字列が文字コードを持つほうが良いのかというのは微妙である。
    一方で、単体の文字を扱う場合があるのだからその時に文字コードと静的に結びついていた方が便利である。
    そのように考えるとやはり文字自体が文字コードを持つという実装はあっても良いように思う。

    →将来的にちゃんと実装するのであれば意味はある。

  | しかしながら現状実装されていないものを使用して c2t/c4t を実装するというのは変である。
  | 更にいうと char16_t / char32_t が用意されている場合には c2t/c4t はそちらが使用されるのであるから、
  | c2t/c4t は char_t 固有の機能を利用することはできない。
  | そのように考えるとやはり c2t/c4t は char_t<T, CP> ではなくてそれ専用のクラスで定義するべきなのでは。
  | もしくはクラスではなくて enum で定義できればそちらの方が良いが…それだとサイズを指定できない。
  | 更にいうと int への暗黙の変換を削除することができない…と思ったが元々の char16_t は int に暗黙に変換できるのでは。
  | というか char_t は安易に int への変換が起こらない様にしているのだから、やはり char16_t/char32_t とは振る舞いが違う。
  | char_t の振る舞いを char16_t/char32_t に合わせて緩くするのは本意ではない。
  | 或いは char_t の第三テンプレート引数として整数型への暗黙変換を許すかどうかを指定できる様にしても良いが…。

  やはり mwg::c2t/mwg::c4t は独立な型として定義するのが良い。
  但し二種類あるのでやはりテンプレートで定義することには変わりない。

  * ところで char_data/char_t に実装を分けているのは何故であったか。
    何故このような実装にする必要があったのか。
    何か色々試行錯誤してこの設計にしたということは微かに覚えているが何故かが思い出せない。

    観察して分かる事は char_data は中のデータメンバが public で公開されているという事である。

    また char_data には変な変換演算子などが定義されていないので意図せぬ変換が起こらない。

    あと char_data はコンストラクタ・代入演算子の類が定義されない pod であるということ。
    - pod である事は何らかの制約を齎しただろうか。例えば可変長引数 (...) に指定できるかできないかなど?
    - 調べると後は C 言語で定義された関数と受け渡しする時 (つまり extern "C" の関数の宣言に使う型) に使える。
    - memmove/malloc などによって操作することができる。つまりC言語の関数に void* + size_t で指定できるということ?
    C言語がどうとかではなくてもっと現実的な問題だったような気がする。

    うーん。デフォルトで 0 を代入するというのが定義されているのは
    配列などを初期化する際に無駄なオーバーヘッドになる。
    それを防ぐために trivial なコンストラクタを持った型として char_data を定義した可能性?

    結局思い出せないので、取り敢えず char_data の事は忘れて実装してしまって良い気がする。

  * しかし改めて考えてみると char16_t/char32_t を自分で定義するのは面倒である。

    というのも文字に必要そうな機能だけではなくて、
    掛け算や割り算、ビット演算なども提供しなければならないからである。
    というより、整数型を新しく追加するのと同じことをしなければならない。

    動作を調べてみると char32_t は何らかの算術演算に巻き込まれると通常の整数型に帰着する様だ。

    #include <iostream>
    template<typename T> void f(T) {std::cout << __PRETTY_FUNCTION__ << std::endl;}
    int main() {
      char32_t a = U'A';
      f(a);
      f(+a);
      return 0;
    }

    規格 [conv.prom]/2 によると char32_t は
    int, unsigned int, long, unsigned long, long long, unsigned long long, uint_least32_t
    の中で一番最初に char32_t の値を全て表現可能な整数型に変換される様だ。

    → mwg/bits/cxx.inttype.h に新しい整数型を定義するためのクラスを作った。


2017-07-09

* integer.nlz.h: bsr の比較。

  元々、整数の2進数での桁数を知りたかった。どうやら bsr という命令がある様だ。
  gcc の組み込み関数には __builtin_nlz (-march=native では lzcnt を用いる様だ) はあるが、
  bsr を呼び出すのに使えそうな組み込み関数は用意されていない。

  -march=native を利用しなければ __builtin_nlz が 63 - bsr の様な感じの結果を返すが、
  更に 64 - __builtin_nlz(x) と書くと 64 - (63 - bsr) の様な感じにコンパイルされてしまう。
  63 - __builtin_nlz(x) としても 63 - (63 - bsr) の様な形になる。

  そこでインラインアセンブラで書くことにした。
  gcc/icc では、インラインアセンブラは AT&T syntax で書かなければならない。
  調べてみると -masm=intel とすれば intel syntax で書くことが出来る様だ。
  しかし普通は att syntax で書くということになっているようなのでそれに従う。

  vc で言う __declspec(naked) のようなことはできないのだろうか。
  どうやらグローバル領域に直接書くようにするようだ。

  | 先ず適当に godbolt でのコンパイル結果を参考にして記述してみる。
  |
  |   __asm__(
  |     "_ndigits_impl_asmbsr: \n\
  |       xor %eax,%eax        \n\
  |       test %rdi,%rdi       \n\
  |       setne %al            \n\
  |       bsr %rdi,%rdi        \n\
  |       add 0x1,%rdi         \n\
  |       mul %rdi             \n\
  |       ret                  \n");
  |   extern "C" int ndigits_impl_asmbsr(std11::uint64_t);
  |
  | と思ったらコンパイルできない。よく考えたら今実行しているのは x86-64 ではなくて x86 だった。
  | x86 での呼び出し規約で unsigned long long を渡す方法が分からなかったので調べる。
  |
  | [1] https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/LowLevelABI/130-IA-32_Function_Calling_Conventions/IA32.html
  |
  | を見てみると、そのままスタックに置けば良いらしい。
  |
  |   __asm__(
  |     "ndigits_impl_asmbsr:  \n\
  |       xor %eax,%eax        \n\
  |       mov (%esp),%edx      \n\
  |       test %edx,%edx       \n\
  |       setne %al            \n\
  |       bsr %edx,%edx        \n\
  |       add 0x1,%edx         \n\
  |       mul %edx             \n\
  |       ret                  \n"
  |   );
  |   extern "C" int ndigits_impl_asmbsr(std11::uint64_t);
  |
  | segfault する。何を間違えたのだろう。仕方がないので naked はやめる。
  |
  |   int ndigits_impl_asmbsr(std11::uint64_t) {
  |     __asm__("\
  |       xor %eax,%eax\n\
  |       ret")
  |   }
  |
  | しかし、これはコンパイルできない。戻り値がないと言われる。やはり naked にするしかない。
  |
  |   __asm__(
  |     "ndigits_impl_asmbsr:  \n\
  |       xor %eax,%eax\n\
  |       ret");
  |   extern "C" int ndigits_impl_asmbsr(std11::uint64_t);
  |
  | これは segfault しなかった。
  | どうやら mov 0x1,%eax すると segfault する様だ。mov $0x1,%eax だと大丈夫。
  | あと、スタック上の引数の位置を間違えていた。
  | また、引数の型を 32 bit だと思って取り扱うコードになっていた…。

  インラインアセンブラで動く様になったがやはり遅い。
  インライン展開できないからである。

    __asm__(
      "ndigits_impl_asmbsr:  \n\
         xor %eax,%eax        \n\
         mov 4(%esp),%edx     \n\
         test %edx,%edx       \n\
         setne %al            \n\
         bsr %edx,%edx        \n\
         add $1,%edx          \n\
         mul %edx             \n\
         ret");
    extern "C" int ndigits_impl_asmbsr(std11::uint32_t);

  64bit 用のコードもここに残しておく。動作は未だ確認していない。

    __asm__("\
    _ndigits_impl_asmbsr: \n\
      xor %eax,%eax     \n\
      test %rdi,%rdi    \n\
      setne %al         \n\
      bsr %rdi,%rdi     \n\
      add $1,%rdi       \n\
      mul %rdi          \n\
      ret               \n");
    extern "C" int ndigits_impl_asmbsr(std11::uint64_t);

  仕方がないのでやはり naked はやめることにする。
  http://caspar.hazymoon.jp/OpenBSD/annex/gcc_inline_asm.html のページを見て、
  見よう見まねで関数にしてみる。

    // 727us
    inline int ndigits_impl_asmbsr(std11::uint32_t value) {
      int ret;
      __asm__(
        "ndigits_impl_asmbsr: \n\
          xor %0,%0           \n\
          test %1,%1          \n\
          setne %%al          \n\
          bsr %1,%1           \n\
          add $1,%1           \n\
          mul %1              \n\
          ret" : "=a" (ret), "+r" (value));
      return ret;
    }

  動作する様になった。しかし、速度は外に直接書いた場合と変わらない。
  結局インライン展開はしてくれないという事なのだろうか。
  或いは、もしかすると setne などは遅いのかもしれない。

    // 614us
    __asm__(
      "ndigits_impl_asmbsr: \n\
        xor %0,%0           \n\
        test %1,%1          \n\
        je 1f               \n\
        bsr %1,%1           \n\
        add $1,%1           \n\
        mov %1,%0           \n\
      1:\n\
        repz ret\n" : "=a" (ret), "+r" (value));

  je を使ってみたら速くなった。
  これは計測コードでは最初の1回以外はジャンプしないので、分岐予測がよく働くということと解釈して良いだろう。
  その他以下の様に修正した。これで 32 - __builtin_clz と殆ど同じ速度 (少し遅いが) になった。

    // 528us
    __asm__("\
      test %0,%0          \n\
      je 1f               \n\
      bsr %0,%0           \n\
      add $1,%0           \n\
    1:" : "+r" (value));
    return value;

  - 初めに mov %1,%0 にして %0 に対して操作すれば xor eax,eax は不要。 (572us)
  - ret = value は外で代入した方が速くなる。 (528us)
  - というか、repz ret は return とダブっている。しかし消しても速度は変わらず。 (528us)
  - そうするとそもそも ret を eax に割り当てている意味もなくなる。しかし速度は変わらず。 (528us)
  - あとラベルは要らない。
  - よく見たら x86 でも x86-64 でも動く形になっている。
    以下のように x86 かどうかを判定するディレクティブを書いたが意味がなかった。
  - add は inc にしても変化はなかった。


2017-07-08

* <algorithm> std::sample

  out が RandomAccessIterator の場合と
  in が ForwardIterator の場合。

  out が RandomAccessIterator の場合は比較的簡単。

  in が ForwardIterator の場合は negative binomial では?
  もう少し真面目に考えてみる。

  問: 残り N 升の中から K 個の升を選んで黒く塗りつぶすやり方を考える。
  一番初めの升が黒く塗りつぶされる確率は幾らか。

  一番初めの升が黒い場合は C(N-1, K-1) 通りある。
  一番初めの升が白い場合は C(N-1, K) 通りある。
  全てで C(N, K) 通りある。一番初めの升が黒い確率は

    P = C(N-1, K-1) / C(N, K)
    = (N-1)! K! (N-K)! / (K-1)! (N-K)! N!
    = K / N

  となる。馬鹿らしい程簡単だった。しかもよく考えてみれば当たり前の事である。
  全然 negative binomial ではない。

* <random>

  C++17 <algorithm> std::sample は uniform_int_distribution を作成してからにするべき?

  | typedef typename UniformRandomBitGenerator::result_type rand_t;
  | const rand_t w = UniformRandomBitGenerator::max() - UniformRandomBitGenerator::min() + 1;
  | mwg_check(
  |   i < numeric_limits<rand_t>::max(),
  |   "range of UniformRandomBitGenerator too small"); // 本当は複数の値を組み合わせてデータを生成するべき。
  | rand_t r, filter = (w / (rand_t) (i + 1)) * (rand_t) (i + 1);
  | do r = g() - UniformRandomBitGenerator::max(); while (r >= filter);
  | std::size_t index = r % (i + 1);

2017-07-04

* algorithm: 多重定義の一部を上書きするのことについて。

  実際に簡単なプログラムを書いて試してみた所、
  namespace ns2 {using ns1::f;} とすると、
  ns2::f と ns1::f たちが多重定義解決に平等に参加するようになる。
  つまり、ns2::f で ns1::f の一部の多重定義を上書きするということはこの方法ではできない。

  ではどのように解決するべきか。

  - 先ず、既存の多重定義を置き換える場合には using std::hoge してはならない。
  - 上書きしない多重定義に関してはそれぞれ std::hoge を呼び出す多重定義を記述する。

  問題を複雑にしているのは、C++ の version によって上書きするかしないか、
  どの関数を上書きするかしないかが変わるという事である。

  特に複雑なのは、例えば C++11 になる時に上書きが発生し、
  更に C++14 になる時にも上書きが発生するというような場合である。

  C++11 の polyfil で全ての上書きしない関数の多重定義を再度書いてしまうと、
  C++14 の polyfil で上書きすることができなくなってしまう。

  a 従って、C++11 の polyfil では、最終的に C++14 で上書きされると分かっている物に関しては
    std 版を呼ぶ多重定義は用意しないというように工夫する必要がある。

  b 或いは別の方法として mwg::std11, mwg::std14, mwg::std17
    というような名前空間を用意するという手もある。
    そうすれば mwg::std11 の polyfil を考える際には、
    それ以降で上書きされるかどうかを気にしなくても良い。
    実はそちらの方が整理されていてよいのかもしれない。

    しかしそうすると libmwg に対して全体的な書き換えが必要になってくる。
    また、version が上がる度にクラスのメンバが変化する様な場合に対応するのが、
    かなり始末が悪くなる。過去の規格の機能を管理するのは困難なので、
    結局最新の規格に似せた機能を提供する名前空間一つに絞った方が幸せである。

  また C++17 で上書きはしないが多重定義を追加する、という場合にも対応しなければならない。
  多重定義を追加するだけならば using すれば良い。
  しかし、もし C++11/14 の polyfil が効いているのだとしたら using してはならない。
  これらの条件判定は複雑になる。仕方がないので、
  やはり std11, std14, std17 を用意するべきだろうか。
  そして上書きするべきときは std:: を間接的に呼び出す overload を追加し、
  そして多重定義を追加するだけの時は using を使うようにする。
  これだと幾重にも forward することになって特に C++03 に優しくない。

  もうひとつの問題点は別のヘッダで同名の関数が定義されている可能性である。
  これは仕方がないので using を管理するヘッダを一つに絞る必要がある。

  [実装]

  実装の際にはどうすれば良いだろうか。
  つまり using は誰が行うのかという事である。

  a 一つの方法は各 C++ version のレベルで不足がある時に using を行う方法である。
    これだと将来的に上書きされる多重定義を含むものについては using できないので、
    将来的に上書きされるかどうかも含めて using するのか転送するのかを選択しなければならず管理が面倒である。

  b もう一つの方法は上書き・多重定義する箇所で転送・usingを行う方法である。
    この場合にはそもそも上書き・多重定義を行わない場合についての転送・using をしなくて済む
    (もしくはそのようにする管理コストがない)。
    それでも、更に後の version で上書き・多重定義する場合には using/転送 を行わないなどの管理がやはり必要になる。

  c 更にもう一つの方法はいつでも転送を行う様にするということである。
    x しかしこれは全然駄目だ。結局、将来的に上書きされる関数についてはその場で転送を書いては駄目という事になる。

  d std11, std14, std17 などの名前空間を用意した方が楽だろうか。
    実のところ実装を上書きする場合は少なくて大体の場合は多重定義の追加である。
    という事を考えれば、そんなに転送は起こらないと考えられる。
    上書きが 2 回起こる場合には転送が 2 回になるがそのようなケースは稀なので余り気にしなくて良い。
    という事にすればこの様に名前空間を分けておく事にすれば多重定義追加の場合には常に using というルールにできる。
    上書きをする時は常に転送というルールと合わせて、分かりやすい。

    問題はこの様に explicit な名前空間を作ってしまうともっと厳密に実装してしまいたくなるという事である。
    或いは、厳密に実装されていると勘違いして使おうとしてしまうかもしれないということである。

    - しかしこれに関しては勝手に使う方が悪いという様に考えれば良い様な気もする。
    - あるいは、std11_internal だとか stdm_detail_11 だとかにしても良い。
    - また将来的に各 std11/14/17 毎に提供したくなった時に、変更コストを抑えられる。

  うーん。総合的に考えるとコードの管理の観点から言って d の方法が良いような気がする。
  そして using-declaration などは多重定義追加を行う際に指定するべき。

  ExecutionPolicy に関しては多重定義追加のものと、
  C++17 で一緒に導入されるものの二種類があることに注意する。

  取り敢えず <mwg/std/algorithm> に関しては上書きしているっぽい関数については対策した。
  漏れがあるかもしれないので本当は全ての関数に対してテストを書くべきなのであるが。。

* is_permutation の実装は怪しいのでテストを追加する。

* algorithm: 全般に ForwardIterator のチェックを行う様にする。

  その時 is_permutation と同じ仕組みにするか、
  標準的なタグディスパッチにするか、
  或いは SFINAE にするかはどれが良いか考える。

  取り敢えず面倒なので現在使っている仕組みをそのまま使うことにした。
  つまり、require_forward_iterator<ForwardIterator>() を呼び出す。

  1 ただし、constexpr の関数から constexpr void require_forward_itereator を呼び出すことができるだろうか。
    どうも constexpr void は許されていない様だ → constexpr int にして 0 をダミーで返す様にした。

  2 デフォルト引数の tag オブジェクト構築は constexpr として取り扱われるだろうか。
    constepxr になってくれる気がするが自信がないので取り敢えず試してみることにする。
    →wandbox で試してみた所 constexpr になるようだ。

    // 実験1
    struct tag {};
    template<typename T> constexpr int check(T = T()) {return 0;}
    template<typename T> constexpr int test1() {check<tag>(); return 1;}
    constexpr auto a = test1<int>();

    // 実験2
    template<typename T> constexpr int check(std::forward_iterator_tag = T()) {return 0;}
    template<typename T> constexpr int test1() {check<std::bidirectional_iterator_tag>(); return 1;}
    constexpr auto a = test1<int>();

* is_permutation の実装に関して。

  同じ要素が複数含まれる場合にどのように処理するべきかは非自明である。

  % 一つの方法は一致要素が見つかった場合には一致するものを全て数え上げるという手がある。
  % これの計算量は結構あるような気がする。最悪でどれぐらいだろう。
  %
  % - 長さが一致していてかつ左にある要素が全て右にもあれば取り敢えずOKである。
  %   長さが一致しているので右にだけ余分に存在する要素というのは許されないからである。
  %   従って、左に要素が見つかったときにだけ右側を見に行けば良い。
  % - 完全に一致している場合が最大の計算量になる。
  %   何故なら一致していない場合は、不一致が判明した所で中断するからである。
  %   不一致が判明するまでは一致している場合と同じ処理になるはずだ。
  % - 先頭の自明に一致している部分を除いて長さ N だったとする。以降はこの部分に注目する。
  %
  % 1 この時、左側の先頭要素に対応する右側の要素を見つけに行く (最大で N 回比較)
  %   見つかったら左側の要素に重複するものがないか走査する (最大で N-1 回比較)
  %   それぞれについて右側に対応要素がないか確認していくことになるが、
  %   右側の要素の比較は結局合計しても最大 N である。
  % 2 左側の二つ目の要素についても調べる。この時、左側の要素については N-2 回の比較が起こる。
  %   右側の要素に関しては実は最大 N の比較が実行されることになる。
  %   このままだと N^2 に収まらない。
  %   例えば一番最後の要素に達して一致が起こったら右側の配列の長さを一つ縮めるというのは
  %   どうだろう。しかし、これは駄目だ。右側の一番最後の要素が左側の一番最後の要素と一致する場合には、
  %   結局毎回右側の要素について最大 N の比較が実行されることになるからである。
  %
  %   いや、しかし、それは本当だろうか。もしシーケンスが一致しているのだとしたら、
  %   右側の要素について毎回 N 回の比較が行われることはないのではないか。
  %   というのも必ず一致する要素の箇所で停止するはずだから、N + N-1 + N-2 + ... になるのでは。
  %   しかし、これは重複要素がある場合にはその限りではない。
  %   結局重複要素がある場合にどのように処理するのかということが鍵になるのだという気がする。
  %
  %   各左側の要素についてその要素が既に検査済みであるかどうかを、
  %   左側の要素自身に対して比較を行って確かめてから走査を開始するということにしてはどうだろう。
  %   そのようにすると、N(N-1)/2 回の余分な比較が必要になる。
  %
  %   うーん。色々工夫のしようはある気はするが…。
  %
  % 前提について再度整理する。
  %
  % + もしメモリを確保して良いのだとすれば比較は N(N-1)/2 で良い気がする。
  %   右側の集合から一致する度に要素を一個ずつ "除いて" いけば良い。
  %   除かれたかどうかの記録を別の std::vector か何かに記録すれば良い。
  %
  % + もし重複がないのだとすれば N^2 の方法が存在する。つまり総当たりの方法である。
  %   実のところ必ず途中で当たる筈だから、N(N-1)/2 で済むはずである。
  %   一致しない場合には途中で当たらないかもしれないが、もし比較回数が N(N-1)/2
  %   を超えるならば一致はしないということを意味する。
  %
  % + 重複がある可能性があるとどうだろう。
  %   重複がある場合には各要素の重複度も一致している必要がある。

  嗚呼、分かった気がする。

  先ず、"既に確認済みの要素かどうかを判定する" というのは無駄だ。
  特に重複がない場合には全く無駄な操作を N^2 程度することになる。
  むしろ既に確認済みの要素であっても盲目に何度でも判定する方が比較回数が少なくて済む。
  この時、一致場合った時に多重度を数える処理は N(N-1)/2 回になる。
  一方で、それぞれに対応する右データ列の要素を見つけるのに高々 N(N+1)/2 回必要になる。
  合計で N^2 回である→取り敢えず実装した。

  % →改めて en.cppreference.com を見てみると N^2 とは書いていなかった。O(N^2) と書いてある。
  % 例として載っているプログラムの最大比較回数は幾つだろう。
  % 先ず、既に数えたかどうかを判定するのに N(N-1)/2 回比較する。
  % 次に同じ要素が右側の列に幾つあるか判定するのに最大 N^2 回比較する (重複がない場合)。
  % 更に左側の列に幾つあるかを判定するのに最大 N(N+1)/2 回比較する (重複がない場合)。
  % 結局、重複がない場合には合計で 2N^2 回の比較を行うアルゴリズムになっている。
  %
  % あと C++14 版では長さが一致しているかどうかの判定も行わなければならない。
  % この判定は自然に本体の処理の中に入れることができるのか、
  % それとも別に判定しなければならないのかは今すぐには分からない。
  % 取り敢えず C++11 版を実装してから考えるべきだろう。

2017-06-22

* mwg/std/algorithm: mwg::stdm::rotate の実装について。

  要するに 0..m と m..n を交換する処理になる。

  % 丁度半分だけ rotate するとき (AAAABBBB → BBBBAAAA) 交換回数は m 回になる。
  % 少し前半が短い場合はどうなるか。123abcd → abcd123
  % うーん。まず 123abcd → abc123d となる。ここから最終形に持っていくには少なくとも 3 回実行する必要がある気がする。
  %
  % % もう少し真面目に考えてみることにする。
  % % rotate は並び替えなので独立な循環の組み合わせに分解できる。
  % % 今 k次の循環を考えてこれを実施するのに必要な最低の置換回数について考える。
  % % k次の循環は k-1 回の置換で自明に実行することができる。
  % % 問題はこれより少ない置換で実現する方法があるのかということである。
  % % その様な方法はないと仮定して数学的帰納法を試みる。
  % % 2次の循環は自明に 2-1 = 1 回の置換で実現するのが最短である。
  % % 3次の循環も1回の置換では絶対に実現できないので 2 回の置換が最短である。
  % % 今k次の循環があったとしてそれより小さい次数k'の循環は最短でk'-1回の置換で実施できると分かっているとする。
  % % k次の循環の最短の方法はその構成要素間の置換で閉じていると仮定する。(仮定)
  % % 最短の方法で1回目の置換の実行後に残りに必要な操作がどうなるかについて考えると
  % % (1) 1個の完了した要素と残りk-1次の循環になっている場合
  % %   →これは丁度 k 次の循環を k-1 回の置換で実現する自明な方法である。
  % % (2) a次の循環とb次の循環に別れる場合 (a+b=k) (例: 1234567a → 123a:5674 → a1234567)
  % %   →これも結局 k-1 回の置換が必要になるので変わらない。
  % %   というか実は 1次の循環 = 完了した要素 と解釈することにすればこれは (1) をも含む。
  % % (3) a次の循環とb次の循環で a+b<k となる可能性
  % %   a次側の升目の少なくとも一つは変化する必要がある。
  % %   元々必要だった k 次の循環ではその部分集合を取っても閉じていることはないからである。
  % %   同様にb次側の升目の少なくとも一つは変化する必要がある。
  % %   一回の置換で高々2升しか書き換えることができないのだから、
  % %   それ以外の升目(k-a-b 個ある)は一切書き換えることなく完了した状態にならなければならない。
  % %   そのようなことは不可能なのでこの可能性はない。
  % % 厳密な証明にはなっていないが k-1 回で実行するのが最短の方法であるというのは正しそうだ。
  % % 実のところもっと綺麗で簡単な示し方が存在する気がする。
  %
  % k次の循環を実行するのに内部で閉じた置換を行うとする。
  % 1回目の置換で置換される要素の片方を1番目と考えることにする。
  % これから 1 -> 2 -> ... -> k -> 1 という循環を実行する。
  % 1回目の置換で1番目の要素とa番目の要素が置換されるとする。
  %
  %   123...(a-1)a(a+1)...k
  %   a23...(a-1)1(a+1)...k
  %
  % この後 23...(a-1)1 の循環と、(a+1)...ka の循環を実行する必要がある。
  % つまり置換によって a-1次の循環とk-(a-1)次の循環に分かれることになる。
  % それぞれの循環について最短の方法を選択すれば良い。
  %
  % k次の循環を実行するのに外部の要素を経由する方法で最短を実現できるか考える。
  % 外部の要素を経由したとしても、内部要素の中身が外に出た後で最終的にまた戻って来なければならない。
  % うーん。どうだろう。
  % 先ず外部要素同士の間での置換は意味をなさない。
  % 外部要素の最終状態は何でも良いので、別に置換を実際に実行しなくてもラベルの張替えだと思えば良いのである。
  % だとすると、考えるべきか外部要素と内部要素の置換だけである。
  % 今、外部要素を1つ導入するとする。この時は外部要素を経由する
  % 最短の方法で1回目の置換で外部要素を巻き込むものを考えれば良い。
  % もしそうでなければ内部で閉じた置換の場合と同じ方法でより小さな次数の循環に還元できる。
  % →本当か? 実はより小さな次数の循環に還元すると外部要素の経由が劇的に減少するような組み合わせが存在するかも?
  %   しかし、そうだとしてもうーん。つまり、2つの循環を混合してもっと短くすることができる可能性を排除できない。
  % まあいいや。取り敢えず1回目の置換で外部要素を巻き込むものを考えるとする。
  % 1回置換を実行した後に、残りに必要な操作を考えると、
  %
  %   x 123...k
  %   1 x23...k
  %
  % となる。rotate を in place で実行するには x を失ってはいけないので、
  % やはりこの後も置換で全て処理しなければならない。
  % 必要な操作は 123...kx の循環である。むしろ k+1 次の循環になってしまう。
  % (しかしより高い次数の循環でより短い方法がないということは保証されていないので、
  % 結局これが本当に損をする方法になっているのかどうか分からない。)
  %
  % 微妙。あー。全体の残りの循環の数で考えれば良いのか。

  命題: 実行するべき各循環について自明な置換手法を用いればそれが最短である。

    残り実行しなければならない循環たちの集合を考える。
    単一の置換は以下のどちらかのケースに分類される。
    (1) 複数の循環を跨いでいる場合は、二つの循環を結合する。
    (2) 一つの循環の中で閉じている場合は、二つの循環に分解する。
    つまり、必ず循環の数を +1 するか -1 するかのどちらかである。
    n 要素の rotate を実行する時に最終的な状態は循環がn個ある状態である。
    最初の循環の個数が a 個である場合、最短でも必ず n-a 回は置換が必要である。
    そして、各循環について自明な方法を使うのが、その実例になっている。

  命題: 毎回1つは最終位置に来るように置換を実行していけば、それが最短である。

    aの中身の最終位置がbだとする。この時aとbは同じ循環の構成要素である。
    そしてaとbの置換は循環の個数を +1 する。
    毎回循環の個数を +1 するのが最短の方法だったので、これは最短である。

  最初の要素から順番に確定していく方針で考えるのが良い。

  - 前半と後半の長さが同じ場合 1234abcd → abcd1234
    これは壁にぶつかるまで置換をしていけばそれで完了である。
  - 前半の方が後半より短い場合 12abcd → abcd12
    壁にぶつかるまで実行すると |ab>|12>cd| という状態になる。
    このとき後ろの 12cd という部分について rotate を改めて適用すると考えれば良い。
  - 前半の方が後半より長い場合 1234ab → ab1234
    この場合は壁にぶつかるまで実行すると |ab>34|12>| という状態になる。
    やはり 34:12 に対して改めて rotate を適用すれば良い。
  - 改めて前半と後半が同じ長さの場合を考えると、
    壁にぶつかるまで実行した時 |abcd>|1234>| となる。
    この時 first==mid0 かつ mid==last である。
    ところで mid==mid0 のことはあるだろうか
    →少なくとも一つ以上の要素を交換したのであればない。

2017-06-10

* xprintf: std::string を引数に渡すとコンパイルエラーになる。

  問題が再現する最小のコードは以下になる。

  | struct A {
  |   A() {}
  |   A(A const&) {}
  | };
  |
  | void eval(...) {}
  | void eval(int) {}
  |
  | int main() {
  |   eval(A());
  |   return 0;
  | }

  最近の g++ 6.3.0 などでは文句を言われなかったが、
  g++ 4.8.5 で std::string を渡したコードをコンパイルしようとしたらエラーになった。
  non-trivially copyable type のオブジェクトは可変長引数 ... に渡せないという。
  g++-4.6.3 でもエラーになる。調べると g++-4.9.3 も同様のエラーを出す様だ。
  一方で g++-4.5.4 ではエラーにはならなかった。

  また、wandbox で様々なコンパイラを使って試してみる。g++-5.1 ではコンパイルが通る。
  clang-3.1, 4.0, 5.0 を試してみた所、全てでコンパイルエラーになった。
  つまり、これは g++-6.3 などでコンパイルできる事の方がおかしくて、
  コンパイルできない方が普通ということだろうか。
  或いは、処理系定義または未定義動作なのかもしれない。

  この場合はどの様に対処したら良いのだろうか。

  a ダミーの int 引数を ... に渡す?

    template<typename T> void eval(T const&, ...);
    template<typename T> void eval(int, int)

    この様にして見たところ eval(short, int) を呼び出そうとする時に
    多重定義解決が曖昧という警告が出る。

  b is_convertible を使用する?

    それだと C++03 での対応が怪しくなってくる。
    また eval(int), eval(int*), ... などの多重定義を追加していった時に、
    eval(...) の代替実装の SFINAE を毎回更新しなければならないし、
    どんどん長くなっていって始末が悪い。
    テンプレートで何とか工夫して管理するようにできるが、
    結局余計に問題が複雑化して管理コストが増えるだけである。

  c C++03 での is_convertible SFINAE を参考にする?

    is_convertible の SFINAE 実装を確認してみた所、
    (a) のダミー引数の方法を使用している。
    但し、eval(T const&, ...) を直接使うのではなくて、
    何からでも初期化出来るクラス C を用意して eval(C, ...) としている。

    しかしこの方法は gcc の場合にだけ使用されている。
    特に msc では使用されていない。
    msc で使用されていない理由は何だろうか。
    msc ではコンパイラ intrinsic を使って実装されている。
    コンパイラ intrinsic の方が信用できるという理由だろうか。

    しかし eval(C, ...) の方法は C++03 の範囲でも手軽にできるので良い。
    取り敢えず eval(C, ...) の方法で実装する事にする。

2017-02-13

* mwg/fun: 初期の実装メモ

  これらは元々 fun.h 内部に直接書いていたが、実装もだいたい固まってきたのでこちらに移動する。

  以下は functor_interface/functor_invoker の設計に関する考察である。

  | 最終的に呼び出す関数のシグニチャは決まっている (既知である)。
  | 複数のパターンが存在する。
  |
  | 1. 最終的に呼び出すのは `R(A...)` だが、余分な引数 `R(A..., B...)` のインターフェイスを持つ。
  |
  |    この場合は最初に受取る時は `(A... a, B... b)` で受け取って `b` は無視することになる。
  |    %%実際には最初に受け取る時点で `(A... a, ...)` で宣言しておけば良いのである?%%
  |    最初から `...` を使ってしまうと変な引数を与えても OK になってしまうので駄目だ。
  |    という訳で最初に受け取る時は矢張り `(A... a, B... b)` でなければならない。
  |
  |    最初に受け取る時に引数の数を減少させる作戦だと、
  |    何個引数を減少させるかで沢山の可能性があるから多重定義が沢山になって現実的でない。
  |    従って、最終的に呼び出される側で適宜引数を削って受け取るのが良い。
  |
  | 2. 最終的に呼び出すのは `R(A...)` で可変長の引数 `R(A..., B..., ...)` を持つ。
  | 3. 最終的に呼び出すのは `R(A..., ...)` で固定の引数 `R(A..., B...)` を持つ。
  | 4. 最終的に呼び出すのは `R(A..., ...)` で可変長の引数 `R(A..., B..., ...)` を持つ。
  |
  | どうも、受け取る時点と実行する時点で問題を分割するべきな気がする。
  | 受け取る側 (インターフェイスを公開) は二種類の可能性がある。
  |
  | A1. 固定長の引数: これは既知の引数の型で呼び出して既知の戻り値の型で返すだけ
  |
  | A2. 可変長の引数:
  |
  |     次の関数に引数をそのまま転送しなければならないので、
  |     可変長部分に関してはテンプレートで可変長長さに応じた多重定義を用意する必要がある。
  |     これが今記述していた部分である。この階層では受け取った引数を全て次の階層へ渡す。
  |
  | 実行する側では矢張り二種類の可能性がある。
  |
  | B1. 固定長の引数
  |
  |     これに関しては、余分の引数は `...` で受け取って無視してしまえば良い。
  |     というか無視する必要がある。
  |
  | B2. 可変長の引数
  |
  |     これは更に実際に実行する処理の場所へ転送しなければならない。
  |     既知の型の部分に関しては既知の型で受け取って、
  |     余分の部分に関しては `const&` または `&&` による転送を行う。
  |
  |     実は受取に用いた型は A1/A2 が知っているので、
  |     其処から貰った情報を使えば `const&` や `&&` による転送の自動判定は不要である。
  |     従って処理を簡略化出来る筈である。
  |
  | この様に考えてみると受け取り側と実行側で処理を統一するのは得策ではない。
  | 受け取り側は `functor_interface` として、
  | 実行側は `functor_invoker` などとする。

  以下は as_fun を実現する為に必要な functor_traits のメンバについての議論である。

  | 次に as_fun の実装について考える。
  | 取り敢えず関数の呼び出しは既にできるという事が分かった。
  | variant_functor についても実は呼び出しができるという事がわかった。
  | 今後の実装で何が必要になるだろうか。
  |
  | - 一つがその関数オブジェクトの自然な関数型である。
  |
  |   実際に関数呼出しを実行することができるかどうかは、
  |   この関数型を経由することによって判定できる。
  |
  |   但し、多重定義のメンバ関数などの場合には、
  |   この自然な関数型という物を取得できないが、
  |   要求する関数型を指定されればそれに適合するかどうか判定できるという種類の物もある。
  |   そう言った物に関しては別に指定を行う必要がある。
  |
  | - また functor に入れる為・adapter を生成する為には、
  |
  |   byref_holder と byval_holder を提供する必要がある。
  |   これは mwg/functor1 の ref_tr と ins_tr に対応する。
  |   但し、そんなに複雑な機能が必要になるかどうかは疑問である。
  |   結局の所、operator()() さえ提供できれば何も問題ない気がする。
  |
  |   `typedef functor_interface<Sfwd, functor_invoker<Ffwd, holder> adapter;` を定義するのは、
  |   外部で自動的にやった方が良い。`Sfwd` 及び `Ffwd` の決定は関数オブジェクトの種類とは独立である。
  |   一方で `functor_invoker` の種類は関数オブジェクトに依存する。
  |   どの種類の関数呼び出しを行うかについては整数か何かで指定できる様にしておくと便利である。
  |
  | これらをまとめた型として functor_traits を定義すれば良い。

* mwg/fun: is_constructible による SFINAE チェック [2017-02-09]

  functor_interface/functor_invoker のコンストラクタで is_constructible で
  SFINAE 選択しておかないと、誤った引数で初期化しようとした時に深い所でエラーが出て分かりにくい。

* mwg/fun: そろそろ関数オブジェクトへの対応を考える。[2017-02-11]

  functor.link.operator.pp を確認してみたが、
  これらは MWGCONF_STD_DECLTYPE の時限定で、
  operator() の多重定義が存在しないときに、
  operator() 自身のシグニチャを抜き出すのに使用する物であった。
  今回の mwg/fun 実装では要求されたシグニチャに対してどの様に適合するかしか
  判定しないこととなったので、自身のシグニチャを抜き出す必要はない。
  (勿論、抜き出す事ができれば様々の詳細な呼び出し可能レベルの判定に使えるが、
  現在のところはその判定は行わない。後で追加するかもしれないが。)
  従って、これは後回しにする。

  重要なのは寧ろ functor.link.variance.hpp の判定の方である。
  以下の二つの判定の何れかに該当すれば関手として取り扱う。

    is_variant_functor<F,S>::value
    can_be_called_as<F,S>::value

  is_variant_functor は同じファイル内に定義されていて、
  F の固有のシグニチャが S に反変・共変適合するかどうかの判定を行う。
  can_be_called_as は functor.type_traits.pp に与えられている。

  is_variant_functor に対応する物はそれぞれの functor_traits の中で判定する様にしている。
  なので結局今回対応するのは can_be_called_as の方という事になる。
  can_be_called_as については移植した。
  can_be_called_as が通ればそのまま関数オブジェクトとして良いのだろうか。
  →実際にやって見ると動くので良いのだろう。


2017-02-10

* mwg/fun: メンバ変数ポインタの場合にも、
  親のオブジェクトの値分類によってどの様に振る舞うべきかが決まる。

  先ず初めに、メンバ関数の様な qualifier は存在しない。
  つまりオブジェクトの value category によって
  メンバにアクセスできたりアクセスできなかったりという事はない。
  代わりにメンバの実効的な型が変化する。

  先ずシグニチャの引数の型としてどの様な物が考えられるか。
  参照型だとして、C&, C&&, C const&, C const&& などが考えられる。
  実の所、シグニチャで受け取った引数をシグニチャの要求する型で返却できれば問題ない。

  C& で受け取ったオブジェクトのメンバを T& で返す為には T& (C&) のシグニチャを
  持っているかの様に振る舞わなければならない。同様にして T&& (C&&) も必要である。
  それから const T& や const T&& に対しても同様にテストしなければならない。

  テストする順番はどうだろう。できるだけ多くの機能を要求するもの、つまり適用範囲の小さい物
  から順にテストして行かなければならない。C& が一番適用範囲が小さい。次が C&& であろう。
  conts C& と const C&& はどうだろう。const C& は何でも受け取れる印象があったが、
  それは C& も C&& も C const& も受け取れるという意味であって、const C&& が受け取れるかどうかは
  よく考えたら知らない。と思ったけれど、先日調べた時には const C& で全ての値分類を受け取る事が
  できていた (但し volatile がついている場合を除く)。再度先日作った表を見た。
  const C&& の方が適用範囲が狭い。const C& が最後に確認されるべきである。
  また C& と C&& は overlap はないのでどちらを先に判定しても良い。
  C& と const C&& もどちらを先に判定しても問題ない。

  結局チェックの順序は C&&, const C&&, C&, const C& の順で良い様な気がする。
  volatile も入って来た時にはどの様に判定するのが良いだろうか。
  多分同様で問題ないだろう→実装した。

* mwg/fun: というかメンバオブジェクトでも volatile は考えなければならない。

  これは上記の項目の実装に含まれている。解決した。


2017-02-10

* mwg/fun: メンバオブジェクトの呼び出し関係で C++11 のコンパイルが通らないと思ったが直っていた。
  と思ったら clang C++11 でエラーが出ている。後で直す。

2017-02-09

* mmake: 個別のテストを実行できる様にすると便利である。

  現状では余り関係のなさそうなものまで全部テストを実行する事になっている。
  これが理由で type_traits などの上流に位置するヘッダファイルを編集すると
  全体がコンパイル・チェックし直しになって時間がかかりよくない。
  (これは以前からの問題でもある。) これについては項目ごとにテストを指定できる様にすれば解決する筈である。
  或いは既にその様な方法に対応していたかもしれないが、そうだとしてもその方法を整理する必要がある。

  → "check@ファイル名" という名前で .PHONY targets を定義する事にした。

2017-02-08

* mwg/fun: member_function_pointer_traits::_switch の多重定義について

  疑問

  どの種類の signature を試すべきだろうか。
  メンバオブジェクトポインタの場合は `T& (C&)` と `T const& (C const&)` の多重定義があると見做した。
  加えてポインタにした多重定義も考えた。
  では既に ref-qualifiers の確定したメンバ関数の場合はどうだろうか。一つ試すだけで良いのだろうか。
  それとも幾つか試さなければならなかったりするのだろうか。

  目的

  ここでは `T (C::*)(...) qualifer` のメンバポインタが、
  interface S を持つと言えるのかどうかについて判定する。
  interface S を通じて呼び出されるあらゆる引数の組について、
  `T (C::*)(...) qualifer` が呼び出せるのであれば、
  interface S を持つということができる。

  考察

  以下はメンバ関数 T (C::*)(...) qualifier が
  或る value category の C に対して呼び出せるかどうかを表す。

    表1. this に対する qualifier (実際に試してみた)
    +---------------+------+-------+----+--------+----+---------+
    | arg\qualifier | none | const | &  | const& | && | const&& |
    +---------------+------+-------+----+--------+----+---------+
    | const prvalue | x    | ok    | x  | ok     | x  | ok      |
    | prvalue       | ok   | ok    | x  | ok     | ok | ok      |
    | const xvalue  | x    | ok    | x  | ok     | x  | ok      |
    | xvalue        | ok   | ok    | x  | ok     | ok | ok      |
    | const lvalue  | x    | ok    | x  | ok     | x  | x       |
    | lvalue        | ok   | ok    | ok | ok     | x  | x       |
    +---------------+------+-------+----+--------+----+---------+

  一方で以下は関数 void (C qualifier ref?) が
  それぞれの value category の C に対して呼び出せるかどうかを表す。
  これはつまり interface S の第一引数の修飾と、呼び出し可能性を表す。
  上の表と異なるところに ! をつけている。

    表2. 関数の引数に対する qualifier
    +---------------+------+-------+----+--------+----+---------+
    | arg\qualifier | none | const | &  | const& | && | const&& |
    +---------------+------+-------+----+--------+----+---------+
    | const prvalue | ok!  | ok    | x  | ok     | x  | ok      |
    | prvalue       | ok   | ok    | x  | ok     | ok | ok      |
    | const xvalue  | ok!  | ok    | x  | ok     | x  | ok      |
    | xvalue        | ok   | ok    | x  | ok     | ok | ok      |
    | const lvalue  | ok!  | ok    | x  | ok     | x  | x       |
    | lvalue        | ok   | ok    | ok | ok     | x  | x       |
    +---------------+------+-------+----+--------+----+---------+

  | 違いは qualifier を何も指定しなかった時の動作のみである。
  | ref-qualifier がついている時の動作は関数の引数と同じである。
  | 従って受け取れるか受け取れないかは is_variant_function で直接判定できる (べきである)。
  |
  |   % 例えばメンバ関数が const& の場合には、
  |   % callable(const&) ⊃ callable(&), callable(const&), callable(&&),
  |   %                     callable(const&&), callable(none), callable(const)
  |   % であるので、S はどれでも良い。これは is_variant_function で判定できるはずである。
  |   % →is_varient_function は is_covariant を使い、更にそれは is_convertible を使う。
  |   %   実際に is_convertible を試してみた所、期待通りの動作になっている様だ。
  |   %
  |   % 或いはメンバ関数が & の場合には callable(&) ⊃ callable(&) なので、
  |   % S 引数修飾子は & だけしか駄目である。
  |   %
  |   % メンバ関数が && の場合には S 引数修飾子は && しか駄目である。
  |   % と思ったら、これは is_convertible で直接比較するといけない。
  |   % S 引数修飾子が none だと何でも受け取れるのでこれは許可してはならない。
  |   % なのに is_convertble だと許可してしまう事になるのだ。
  |   % (確かに内部で forward すれば呼び出せるがこれは interface として可笑しい。)
  |   %
  |   % →引数の contravariance は再設計する必要がある。
  |   % →[Done / 2017-02-08 / "mwg/fun: is_contravariant/is_covariant 再設計"] を参照の事。
  |
  |   is_variant_function がおかしいのは取り敢えず修正した。
  |   再度考えてみる。
  |
  |   結局 ref-qualifier がついている場合には、
  |   引数に同じ ref がついている場合と同じ呼び出し可能性である。
  |   つまり、S を選択する際にはそのまま `R (C qualifier, A...)` の振りをして比較すれば良い。
  |
  | ref-qualifier がない場合には通常の引数と異なる振る舞いをする。
  |
  |   qualifier が全くない場合には const のない value からメンバ関数を呼び出す事はできない。
  |   C& と C&& に対して多重定義がある場合に等しい。
  |   qualifier として const がついている場合には、
  |   C const& と C const&& に対して多重定義があると見て良い。
  |   この辺りは統一的に取り扱える。
  |
  |   所が rvalue reference がない C++03 ではこの振る舞いを再現する方法が謎である。
  |   取り敢えず const& で受け取って const_cast する事にしておけばいつでもコンパイルはできる。
  |   const& で本当に参照である変数の値を書き換えてしまう危険性もあるが、
  |   そういったコードは C++11 に対してテストしていれば除外される。
  |   しかしもっとましな方法はないのだろうか。
  |   問題は `R const f();` の様な戻り値に対して unqualified member function は呼び出せないという事である。
  |   一方で、これを `g(f())` として別の関数の引数に指定する場合には、
  |   `R f();` か `R const f();` かで受け取れる・受け取れないを区別する方法はない。
  |   `g(R)` でどちらも受け取れるし、`g(R const)` でもどちらも受け取れる。
  |   勿論 `g(R const&)` でもどちらも受け取れる。`g(R&)` はどちらも受け取れない。
  |   `template<typename T> void g(T&)` は、というとどちらも受け取れない。
  |   というかテンプレートで頑張って区別がつけられたとしても、
  |   最終的な関数オブジェクトのインターフェイスは単純な関数型で表されるのだから、
  |   それ (或いはその多重定義) で表現できない様な区別はしても仕方がない。
  |   →結局 C++03 では permissive に行くしか無い。
  |
  | まとめる。結局テストするべきは何であろうか。
  |
  |   ref-qualifier がついている場合は
  |     is_variant_function<R(C qualifiers,A...), S> の時に interface S を持つとして良い。
  |   ref-qualifier がついていない場合は、
  |     C++03 (rvalue reference がない) では is_variant_function<R (C const&, A...), S> の時に interface S を持つとして良い。
  |     C++11 (rvalue reference がある) では
  |       is_variant_function<R (C cv&&, A...), S> の時に interface S を持つとし、さもなくば、
  |       is_variant_function<R (C cv&, A...), S> の時に interface S を持つとすれば良い。
  |
  | % add_const, add_reference の類は参照に対して実行しても何も起こらないので上記はまとめる事ができる。
  | % つまり、ref-qualifiers がついていない場合の判定法が、実はついている場合もカバーしている。
  | % →これは勘違い。add_lvalue_reference すると reference を上書きしてしまう。
  |
  | 更にポインタとしてオブジェクトを受け取る場合について考えなければならない。
  | 同様に is_variant_function で比較するとすればどの様にすれば良いだろうか。
  |
  |   ref-qualifiers として && がついている場合には、
  |   ポインタを単に dereference しても rvalue は得られないので、呼び出しは不可能である。
  |   ref-qualifiers として & がついている場合には、const& かそうでないかで違う気がする。
  |     qualifier が単に & の場合には non-const lvalue が要求される。
  |     つまり、ポインタとしては C* でなければならない。C const* はいけない。
  |     これは is_variant_function<R (C*), S> で判定すれば良い。
  |     qualifier が const& の場合には実は何でも受け取れる。
  |     つまり、ポインタとして C* もしくは C const* が受け取れる。
  |
  |     % そればかりか C volatile const* でも受け取れる気がする
  |     %   (但しその場合には一時オブジェクトが内部で導入される)。
  |     % これは is_variant_function<R (C const volatile*, A...), S> で判定すれば良い。
  |     %
  |     % →あれ、本当に const& ならば volatile でも呼び出せるの?
  |     % → 呼び出せなかった。
  |
  |     という事はやはり is_variant_function<R (C const*, A...), S> で判定すれば良い。
  |
  |   ref-qualifiers が何もない時、これは & または && と見てよいが、
  |   既に見たように今回の場合は && は呼び出せない。従って & と同じ扱いだ。
  |
  |     % 但し const& の様に C const volatile* でも受け取れる、という事はない。
  |     % volatile な変数の場合は volatile なメンバ関数しか呼び出せないのだ (本当?→確かめた)。
  |     %
  |     % const& 側でも実は C const volatile& は受け取れないという事が分かったので、
  |     % 実は気にしなくてもよいのである。
  |
  | % もう一度整理する。
  | %
  | % - ポインタを受け取る場合には volatile は気にしなくても良い。
  | %   ポインタを受け取るのと同じ要求がなされるからである。
  | %
  | % - % 参照で受け取る場合の volatile はちゃんと処理しなければならない。
  | %   % というのも、引数の反変性では const& で volatile const& も受け取れるが、
  | %   % memfun qualifiers では const& で volatile const& は受け取れないからである。
  | %
  | %   今試してみたら volatile な変数は const& でも受け取る事はできない様だ。
  | %   更に is_convertible もちゃんと受け取れないと言っている。
  | %   なので volatile と const& の兼ね合いの事は気にしなくても良さそうだ。
  | %
  | % →結局 volatile は何も気にしなくて良さそうだ。或いはあと付けの考察で充分そうだ。

  結論:

  以下の様な判定を行えば良い。

    auto functor_traits_switch() -> (bool ok, typename intrinsic_signature) {
      cv := メンバ関数に指定された cv-qualifiers;
      ref := メンバ関数に指定された ref-qualifiers;

      if (ref == 空) {
    #if (rvalue reference がある時)
        if (is_variant_function<R (C cv &&, A...), S>)
          return (interface S を持つ, R (C cv &&, A...));
        if (is_variant_function<R (C cv &, A...), S>)
          return (interface S を持つ, R (C cv &, A...));
    #elif (rvalue reference がない時)
        if (is_variant_function<R (C cv const &, A...), S>)
          return (interface S を持つ, R(C cv-qualifiers));
    #endif
      } else {
        if (is_variant_function<R (C cv ref, A...), S>)
          return (interface S を持つ, R (C cv ref, A...));
      }

      if (ref != rvalue_reference && is_variant_function<R (C cv*, A...), S>)
        return (interface S を持つ, R (C cv*, A...));

      return (interface S は持たない, void);
    }

  * 戻り値の covariance は R から const R& に変換できてはならないのではないか。
    →[Done / 2017-02-08 / "mwg/fun: is_contravariant/is_covariant 再設計"] を参照の事。

* mwg/fun: stdx::add_const_reference <mwg/std/type_traits> は && を上書きするべきかそうでないか。

  今までは type_traits の慣習に倣って上書きするようにしていた。
  然し、今回の mwg/fun の実装では上書きしてほしくない動作が多数存在する。
  そこで "add_const_reference は && を上書きしない" という動作に変更する事を考えた。

  しかし、この変更により既存のコードは影響を受けるだろうか。確かめる必要がある。

  1. 先ず使っている箇所として tuple の実装がある。
    `get<0>(const TT&& tup)` (0 番目の tuple の要素) の自然な型は何だろうか。
    0番目のメンバが参照でないならば、単に const& を付けた物になる。
    0番目のメンバが左辺値参照ならば、特に何も変化はない。
    0番目のメンバが右辺値参照の場合には、実は左辺値参照に置き換えた物になるのではないだろうか。
    というのもメンバには既に名前がついていて、左辺値だからである。
    特に、メンバの型というのは初期化の時にしか意味がなく、その後は左辺値参照も右辺値参照も関係ない。
    従って、参照で受け取ったオブジェクトのメンバの型を導出する際には add_const_reference は、
    従来の振る舞いのように右辺値参照を上書きするのが正しいのである。

  これにより add_const_reference の振る舞いは破壊しない事になった。
  今の所は、新しく add_const_reference_checked (仮名) を追加する予定である。
  さて、他の箇所でもこの振る舞いを想定した実装になっているのかは一つずつ確認していく必要がある。

  2. functor でも使われているがこれは廃止予定なので余り詳しくは見ない。
    (1) limited_storage<case_data, S> の case_data に対して const_reference を適用している。
      case_data が参照 (まして右辺値参照) という事はないのでこれは問題にならない。
    (2) T C::* について const T& を受け取った時にどの型になるのかの計算で使っている。
      これは従来の add_const_reference の振る舞いでなければならない。OK

  3. <mwg/std/utility> の forward (for C++03) で add_const_reference を使っていた。
    わざわざ add_const_reference に渡す型が参照の時に場合分けをしていたが、
    実はこの場合分けは必要なくて単に従来の add_const_reference を使っていれば良いだけだった。修正した。
    これについても従来の add_const_reference の振る舞いを支持する。

  4. tuple の他の箇所

    実は未だ tuple で使っている場所があった。
    一つは実装仕掛けのコードで今は使われていない場所。
    (std/tuple.nonvariadic_tuple.hpp:346)

    std/tuple.nonvariadic_tuple.hpp:452
    std/tuple.nonvariadic_tuple.hpp:454
    ここで使われているのも別の問題があってコメントアウトされている。

    std/tuple.nonvariadic_tuple.hpp:889
    これは tuple_cat を実装する為に、tuple の要素を毎回コピーするのではなくて、
    参照をコピーしてから初期化をするという作戦で行くために add_const_reference をしている。
    そもそも C++03 向けのコードなので余り気にしても仕方がないのかもしれないが、
    これについても右辺値参照が絡んできた時に注意深く考える必要がある。
    →ここでは移動元の tuple を const& で受け取っているから、
      その要素への参照を add_const_reference するのは自然である。
      つまり、右辺値参照は左辺値参照に置き換えなければならず、
      従来の add_const_reference の仕様でなければならない。

  5. str.h でも使っている。
    これは as_str<>::adapter に対して add_const_reference して、
    引数でコピーなしに受け取る事ができる様にしている。
    adapter が右辺値参照だということは考えにくい、
    というより右辺値参照だったとしても、
    引数で受け取るだけで破壊するというのは危険なのでこれで問題ない。

  6. 残っているのは今回書いていたコードの fun.h だけである。

    というか今までの背景を考えると add_const_reference は
    やはり右辺値参照を左辺値参照に書き換えるべきなのではないかという気がしてきた。
    今回の使用方法についてもそれが成立する可能性も含めて調べる必要がある。

  6a. 先ず is_contravariant に関して。

    これはテストで全パターン検査しているから振る舞いとしては問題はない。
    ただ、この書き方が正しいのかについては再度考える必要がありそうだ。
    →全パターン検査していると思ったがよく考えたら C++03 でしかテストしていない。
    再度 C++11 で確かめようとした所、今まで溜まっていた沢山のバグが顕になった。
    それらを修正してみると、is_contravariant が予想通り変な振る舞いをしていた。
    これは、その場で参照の時は add_const_reference しない様に判定する。

  6b. 次は forward の所で使っている。これは問題になりそうな気がする。

    改めてどの様に処理するのが良いのかについて考えなければならない。
    ここで本来したいのは完全転送である。
    しかし右辺値参照に対応していない時に完全転送をどのようにするのかという事である。
    右辺値参照が存在しない時には一般には完全転送は不可能である。
    但し、行き先の型を知っている場合に限って完全転送のような事ができるのではないか、
    と考えて書かれたのがここにおける add_const_reference なのである。

    さて、再度一から考え直してみる。
    本当に右辺値参照がない場合に考えられる引数の型は、

      T, T const, T&, T const&

    の何れかである。 T, T const に関しては、取り敢えず T const& で受け取って、
    それを渡せば良いと考える (本当は初期化が余分に増えるから完全転送にして
    避けたい気がするが、そもそも巨大な型で引数を参照にしないというの自体が駄目である。
    小さな型の場合には初期化が何回重なっても気にならないので問題ない。)。
    また T& 及び T const& に関してはそのまま受け渡しを行えば問題ない。

    右辺値参照が存在している場合には、

      T, T const, T&, T const&, T&&, T const&&

    と様々な場合がある。T, T const に渡す為のパラメータについては、
    % 勝手に move して T&& や T const&& で渡す訳には行かないから、
    % やはり T const& で受け取るしかない様に思う。
    問題は其処ではない。T, T const は普通は右辺値参照からでも
    const 左辺値参照からでも初期化できる。
    右辺値参照も左辺値参照も両方受け取れるのは T const& しかないという事である。
    但し、勿論、右辺値参照の rvalue 性は失われるが、まあ、そもそも引数が
    T, T const となっている関数の時点で何かおかしい気がするので余り気にしない
    (ひょっとすると move で受け取る前提でわざと T, T const にする可能性もある
    のかもしれないが、余りそのような使い方で便利なものが思い浮かばないので今は良い)。
    一方で、最終的な行き先が T& T const& T&& T const&& である場合には、
    そのままの引数で単に受け取って forward すれば良い。


    6b.1 <mwg/std/utility> mwg_forward_rvalue との違いは?

      一時これは mwg_forward_rvalue と同じ働きをする物なのかと考えた。
      しかし mwg_forward_rvalue に置き換えられるかというとそうとも限らない。
      というのは既に参照型や void である場合に mwg_forward_rvalue を付加するとエラーになるからだ。

      # (とは言っても void を引数の型として使用することはないし、
      # 実はテンプレート引数が参照の時には Ref const& や Ref&& としてもちゃんと処理されるべきで、
      # 一部のコンパイラ(vc9)で警告が出るかもしれないという事以外には実は問題はないのかもしれない。)

      従って同じ機能を持つ物をテンプレートで実装してみる事にした。
      そしてそれを使って記述してみる事にした。しかし何か違う気がする。
      右辺値参照がない処理系ではこれで良いが、
      右辺値参照がある処理系では本当にこれで良いのだろうか。
      これは universal reference で型推論をした結果として、
      `T` ならば右辺値参照で `T&` なら左辺値参照だという物である。
      今回の外部から指定する型というのは T または T& で右辺値参照・左辺値参照を区別する物ではない。
      外部から `T` を指定するというのは受け取り側が T で受け取るという事で、
      それはつまり右辺値参照でも左辺値参照でも何でも受け取るという意味である。
      また `T&` を指定するというのは左辺値参照しか受け取らないという意味である。
      そして `T&&` を指定するというのは右辺値参照しか受け取らないという意味である。
      意味合いが全然違う。

      結局、新しく作った `add_forward_rvalue`/`add_forward_lvalue` は廃止する事にする。
      現在使っているマクロをそのまま使うだけで良いからである。
      (将来問題が出る可能性もあるが現在のところ問題は出ていないし、
      また現在誰も使っていないのでテストの穴にもなるので後で管理が面倒になる。)
      一応以下に <mwg/std/utility> に試験的に追加したテンプレートの実装を置いておく。

      ```
      #if defined(MWGCONF_STD_RVALUE_REFERENCES)
        template<typename T> struct add_forward_lvalue: add_lvalue_reference<T> {};
        template<typename T> struct add_forward_rvalue: add_rvalue_reference<T> {};
      #else
        template<typename T> struct add_forward_lvalue: conditional<
          is_reference<T>::value, T,
          typename add_const_reference<T>::type> {};
        template<typename T> struct add_forward_rvalue: conditional<
          is_reference<T>::value, T,
          typename add_const_reference<T>::type> {};
      #endif
      ```


    何れにしても外部から `T` を指定することが何でも受け取れる事を表し、
    `T&`, `T&&` がそれぞれ右辺値参照・左辺値参照しか受け取れない事を表したい。
    これは矢張り転送に関係している気がするので <mwg/std/utility> に実装する方向で考えたい。

    6b.2 名称をどうするか

      振る舞いに関しては問題ない。特にいま問題になっているのは名称である。
      そして名称を決める際に重要なのはどの様な場合にこの機能を使う事ができるのかという事である。

      std::forward による完全転送の場合は転送元の式の value category に依存していた。
      一方で、今回考えているのは転送先の引数の許容する value category に応じて、
      対応した値を参照で受けられる様にする為の引数の型を算出することにあった。

      メールなんかの場合だと forward というのは転送元が決定権を有する。
      では転送先が決定権を有するような取り寄せはなんというのだろうか。
      取り寄せると言っても中身を見ずにそのまま転送してくれる様に手配することである。
      郵便の場合だと転居届で転送設定をするというのが対応する。
      うーん。order from (取り寄せ), accept (需要), transfer (移転・引っ越し)。
      全部違う気がする。forward_from というのが正しいのだろうか。

        例: void func(typename stdx::forward_from<Args>::type...);

      否、逆だ。目的語が異なる。from ではなくて to だ。結局そういう事になるのか。

        例: void func(typename stdx::forward_to_parameter<Args>::type...);
        例: void func(typename stdx::forward_to_argument<Args>::type...);

      うーん。forward_to_parameter の辺りが適切な気がする。
      しかし動詞というのは何か変だ。add_forward_to_parameter はどうだろう。
      でも add という訳でもないような気がする。
      厳密には type for forward to parameter もしくは forwarded type to parameter か、
      うーん。でも、std::decay 等の用例があることだし、動詞でも良い気がする。

    6b.3 実は boost::call_traits<T>::param_type で良いのでは。

      所で引数に使うといえば boost だか何処かに似たような物があったような気がする。
      これである: boost::call_traits<T>::param_type
      - [c++ - template pass by const reference - Stack Overflow](http://stackoverflow.com/questions/4875989/template-pass-by-const-reference)
      - [letsboost::call_traits](http://www.kmonos.net/alang/boost/classes/call_traits.html)
      - [boost::call_traitsを使った最適化 - ボレロ村上 - ENiyGmaA Code](http://boleros.hateblo.jp/entry/20100108/1282356478)
      記憶だともう少し違ったインターフェイスだったような気もしないでもないが、
      広く知れ渡っている様だし記憶と違うのは param_type が type で call_traits が param hoge 的な物だったのではないかという、
      名前が違うという程度の物でしか無いから、多分記憶にあるのは本当はこれだったという事で正しいだろう。

      さて、これは名前つけの参考にはならない。もしくは typename stdx::param_type<T>::type 的にすれば良いという事を示唆しているのかもしれない。
      今回の場合に当てはめて考えるのであれば typename stdx::param_forwarding_to_param<T>::type とかいう事になるのだろうか。
      結構面倒なことだ。或いは typename stdx::param<T>::type が普通の const& であって、
      typename stdx::param<T>::forward_to_parameter ん? 何か変だ。 <T> の位置を最後に持って来たいからこれは意味がない。

      ところで、よく考えてみたら boost::call_traits<T>::param_type との動作の違いは何なのだろうか。
      実は参照でない物に対して const& をつけるという意味では全く同じなのではないだろうか。
      違いがあるとすれば int などのスカラーに const& を付加するかしないかであるが、
      今回の場合には実は関係ない。スカラーに const& はつけなくても問題ないのだ。
      ただ、最適化の際の振る舞いが変わるかもしれないが。。

      この事を考えれば名前は単に typename stdx::parameter<T>::type もしくは、
      スカラー型も const& にするという事を考えれば、
      typename stdx::reference_parameter<T>::type とすれば良いのでは。

    6b.4 どの名前空間に配置するのか。どのヘッダに配置するのか。実際の名前は。

      さて、名前空間をどうするのかという問題は残っている。
      mwg::parameter はない気がする。唯の traits に parameter を使わせるのは勿体ない。
      mwg::reference_parameter も同様に勿体ない。
      mwg::stdx::parameter, mwg::stdx::reference_parameter も勿体ない。
      というか、将来衝突が起こった場合に問題になるだろう。

      従って特別の名前空間に入れたほうが良い気がする。
      そうすると mwg/std/utility に配置するのは正しいことなのだろうか。
      特に、mwg::stdx 名前空間に配置する意味はあるのだろうか。
      (実のところ mwg 名前空間に直接配置しても良いのかもしれない。)
      特にどの名前空間に配置するのが良いのかというのは微妙である。

      そもそも現段階では使うのは fun.h しかない。
      だとすれば functor_detail 名前空間の内部に utility として用意するだけで良いのではないのか。
      特に functor_detail::type_traits で良い気がしてきた。

      さて、配置場所が決まったので名前も適当に決める。

      完全に説明するには add_const_reference_to_parameter になるが、
      これだと意図がよく分からない。短くすると reference_paramter になる。
      或いは parameter でも良いかもしれない。しかし、やはり変だ。
      或いは、as_reference_parameter というのも手かもしれない。
      既に std::as_const という関数がある事を考えれば as は良くないので、
      make_signed/make_unsigned に倣って make_reference_paramter でも良いかもしれない。
      或いは make_parameter_reference でも良いかもしれない。

      実は typename call_traits::parameter<T>::type でも良いのかもしれない。
      もしくは forward_parameter<T>::type はどうだろうか。
      或いは call_traits<T>::param_type に対応する traits も一緒に導入して、
      セットで名前を決めるというのが良いような気もする。
      だとすると先にこちらの名前を決めたい。
      type_traits::parameter<T>::type もしくは type_traits::as_parameter<T>::type が良いか。
      否 type_traits::standard_parameter<T>::type もしくは canonical_parameter<T> が良い。
      (どうせこれも後で使うような気がする。)

      とすれば今回の場合も 修飾語 + parameter が良さそうな気がする。
      うーん。forwarding_paramter なんかだと矢張り perfect forward の印象が強いので良くない。
      const_reference_parameter や reference_parameter だとそのまま過ぎて意図が見えない。
      特に const_reference_parameter は右辺値参照や左辺値参照はそのまま通すという事が分からない。
      実際には、場合に応じて const& になったり & や && をそのまま通過させたりする。
      という事を考えれば実は reference_parameter で良いのではないか。。

    → type_traits::canonical_parameter/reference_parameter を実装した。
      それを使う様に修正した。

  6c. 次は fun.h (functor_traits_member_object_switch) で、
    オブジェクトを const& もしくは & で受け取った時に
    add_const_reference または add_lvalue_reference している。この使い方は正しい。

  6d. 次は fun.h (member_function_pointer_traits::_switch) である。
    これは、メンバ関数型の自然な関数型を導出するのに使われている。

    メンバ関数型が qualifier を全く持たない場合は、
    non-const rvalue 及び non-const lvalue のオブジェクトから呼び出せる。
    右辺値参照がない環境ではこれに対応する引数は存在しないので、
    仕方がなく全てを受け入れる C const& で受け取る事にする。中で const 外しをする必要がある。
    右辺値参照が存在する環境ではこれに対応するのは C&& と C& の多重定義である。
    現在は多重定義のある intrinsic_signature に対応していない。
    仕方がないので permissive に C const& を受け取る様にしておくしかないか。

    結局この場合には add_const_reference ではなくて
    新しく作った reference_parameter を使用する必要がある。

    更に、右辺値参照がない環境での signature の候補にも使われている。
    これは全く同じである。これも reference_parameter を使う様にすれば良い。

  6e. 最後に使われているのは要求されたシグニチャから、
    参照化したシグニチャを生成する場所である。
    これに関しては reference_parameter にすれば良い。


  新しく追加した reference_parameter について、
  実は volatile も追加するのが正しいのではないかという気もするが、
  下手に volatile を追加すると最適化を阻害するかもしれないので良くない。
  というかよく考えたらコピーコンストラクタを呼び出せなく成るので全然駄目である。
  というわけで reference_parameter で const volatile& を付加するという案は却下である。
  (同様に restrict 乃至は __restrict を付加するという案も却下である。)

2017-02-08

* mwg/fun: is_contravariant/is_covariant 再設計

  概要:

  is_contravariant<From, To>::value は、
  仮引数 From を仮引数 To に置き換えたインターフェイスにできる場合に true となる。
  つまり、To 型引数で受け取れる引数が常に From 型引数でも受け取れる場合に、true となる。
  その為には先ず To -> From への変換が可能であるか From が void である必要がある。
  更に To が参照でない場合には何でも受け取れてしまってこれは To const& に同じなので、
  To -> From への変換が可能であるかどうかだけの判定では緩すぎである。
  To const& -> From への変換が可能であるかどうかを見なければならない。

  追加: 戻り値の covariance

  更に戻り値の covariance にも問題がある様に思われる。
  元の関数が R を返している時にインターフェイスが const R& を返す様には変更できない筈だ。
  これはインターフェイスとして正しい正しくない以前に、
  実際に存在しないオブジェクトを指す様になり危険だ。
  この理由で以下は全て禁止されるべきである。

    R → R&
    R → R const&
    R → R&&
    R → R const&&
    const R → R&
    const R → R const&
    const R → R&&
    const R → R const&&

  或いは To が reference ならば From も reference でなければならないと言い換えられる。

    !is_reference<To>::value || is_reference<From>::value

  From が参照型の場合に To が非参照型になるのは許容できるのかというのは、
  安全であるが概念として許せるのかという話がある。
  しかし例えば int& operator[](int) から int を取り出すという需要がある事を考えれば普通である。
  或いは参照型は何れ値を取り出すか書き込むかされるのに使われるのだから、
  できる操作を取り出すのに限定する (もしくは取り出す) というのは普通である。

  From も To も非参照型の場合には単に From から To に型変換できれば良いだろう。

  という訳で追加の条件は要らない気がする。


2017-02-07

* mwg/funcsig: bug arity_pop が variadic templates で動かない。

  http://melpon.org/wandbox/permlink/M1ikUAaqJe55Lg8j

  | #include <type_traits>
  | #include <assert.h>
  |
  | template<typename S, typename Add>
  | struct push_back: std::false_type {};
  | template<typename R, typename Add, typename... A>
  | struct push_back<R (A...), Add>: std::true_type {using type = R(A..., Add);};
  |
  | template<typename S>
  | struct pop_back: std::false_type {};
  | template<typename R, typename Tail, typename... A>
  | struct pop_back<R (A..., Tail)>: std::true_type {using type = R(A...);};
  |
  | template<typename S>
  | struct pop_front: std::false_type {};
  | template<typename R, typename Head, typename... A>
  | struct pop_front<R (Head, A...)>: std::true_type {using type = R(A...);};
  |
  | int main() {
  |     assert((push_back<void (int, int), int>::value)); // ok
  |     assert((std::is_same<push_back<void(int,int),int>::type, void(int,int,int)>::value)); // ok
  |     assert((pop_front<void (int, int)>::value)); // ok
  |     assert((pop_back<void (int, int)>::value)); // fails
  |
  |     return 0;
  | }

  型パラメータを使ってもこういう一致の仕方はしない様だ。
  先頭を取り出すことはできる。末端を取り出すことはできない。

  さて arity_pop を variadic templates で一体どの様に実装すれば良いのだろうか。
  例えば arity_rotate する事はできる。


2017-02-06

* mwg/functor: functor_ref/functor の実装の再確認

  ★内部で char 配列に全てを入れて placement new を実行しているのは何故だろう。
    これは型消去に関係している。
    普通に型消去をすると別の場所に new して自身はポインタを保持することになる。
    しかし new/delete を避ける為に自身の内部にインスタンスを保持しても良い。
    その為の領域をこちらで用意しておいてその上で placement new すれば良いのだ。
    そしてそこへの functor_case* ポインタを取得して保持する。
    結局 functor は以下の様な構造になっている。

    struct {
      functor_case<S>* h;
      char buffer[3 * sizeof(void*)];
    };

    さて。疑問は本当にこの様な構造にしなければ実現できないのかという事である。
    先ず、其処にメンバとして有限のサイズを持たせるのだとしたら、
    そして内部に好きな型のメンバを定義できる様にするのだとしたら、
    特定の型を持ったメンバを其処に配置する訳には行かない。
    strict type aliasing などを考えれば結局 char 型の配列にするしかないのだ。
    そしてその様にしている以上は placement new をするしかない。

    次の疑問は placement_clone 等という物が必要なのかという事である。
    ただ単に代入演算子などでコピーするだけでは駄目なのだろうか。
    代入演算子を使う場合には代入元と代入先が一緒の型でなければならない。
    今回の場合には結局代入先を先に破壊してから、
    代入元からコピー構築をするという具合にしなければならない。
    所が、代入元の実際の型を知っているのは代入元だけである。
    結局コピー構築を実行するのを仮想関数で実現しなければならない。
    よって placement_clone という仮想関数を導入する必要がある。

    もう一つの疑問。functor_case<S>* h というポインタを別に
    保持する必要はあるのだろうか。
    buffer の内部にも vptr があるのだし何だか重複している様な気がする。
    しかし vptr が buffer の内部の何処に配置されるのかというのは実のところ不明である。
    勝手に reinterpret_cast するのも危険だろう。
    という訳で functor_case<S>* という変数を別に保持する必要があるのだ。
    しかし、これは仮想関数の仕組みを使う事に拘らずに自分で vptr 擬きを作れば良い気がする。
    則ち

      template<typename S> struct vtbl {
        ctor_func_t (*_ctor)(char*, void*);
        copy_func_t (*_copy)(char*, char*);
        dtor_func_t (*_dtor)(char*);
        S* _call;
      };
      template<typename S> struct functor {
        vtbl<S>* vptr;
        char buffer[sizeof(char) * 3]; // ← ここには非仮想クラスを構築
      };

    そして vtbl は型ごとに用意するのである。
    さて、同じ構造を何故仮想関数なしに実現できないのだろうか。
    実は、もし static_cast<functor_case<S>*>() と、
    reinterpret_cast<functor_case<S>*>() が一緒であれば、
    元々 functor_case<S>* h を省略できて何も問題は生じないのである…。

  ★ところで swap の実装は駄目なんじゃないのか?
    ポインタを単純に交換しているが、これだと互いに相手のバッファの中にある
    位置を指す様になってしまう。一方が破壊されると他方は異常な状態になる。
    それ以前に異なる型の物体を指すことになるから全然駄目である。

  ★それから functor_case の alignment がどうなっているのかは危ない。

  ★std::aligned_storage の strict type aliasing はどうなっているのか。

    色々試してみたが大丈夫の様な気がする。

    http://melpon.org/wandbox/permlink/p7AtDxtXhq2L6RHx

    1.関数 A を通じて placement new され結果のポインタ p を得、
      p を使い終わった後にまた関数 B を通じて異なる型の結果のポインタ q を得たとする。
      この時、コンパイラはちゃんと p と q が同じ位置を示しているかもしれないという事を考慮に入れなければならない。
      というのも関数 B の中で p で確保した領域を解放してから q の領域を確保するかもしれず、
      その時に p が失効する可能性を排除できないからである。
      だとすれば p から読み取るという操作を関数 B の呼び出しより後に移動することはできない。

    2.もしインライン展開されるのだとしたら、尚の事同じ位置を指しているという事は、
      コンパイラに分かってしまうので、より問題は起きにくくなる。
      同じ位置を指しているという事を検出できないのだとしたら、
      やはり結局 p がその瞬間に失効するかもしれないという可能性を排除できないので、
      結局読み取りのタイミングを変更することはできなくなる (と思われる)。


2016-04-04

* mwg/functor.h の構造について再確認すると共に整理を行う。

  現在の構造の中心となるのはやはり functor_traits である。

  | template<typename F>
  | class functor_traits{
  |   typedef F fct_t;
  |   static const bool is_functor;
  |   static const int arity;
  |   static const bool has_varargs;
  |
  |   typedef auto ret_t;
  |   typedef auto sgn_t;
  |   typedef auto arg1_t;
  |   typedef auto arg2_t;
  |   typedef auto arg3_t;
  |   ...
  |
  |   typedef auto ref_tr; // functor への参照を保持
  |   typedef auto ins_tr; // functor の複製インスタンスを保持
  |   static ret_t invoke(const fct_t& f,...){
  |     f(...);
  |   }
  | };

2016-03-27

* gcc-3.3.6 対応 → 無理。諦める

  gcc-2.95 は取り敢えず諦めたので gcc-3.3.6 について support を試す。

  1 試しにコンパイルしてみたらいきなり ICE である。
    tape_head::read の SFINAE 条件で発生している。
    どうやら条件式に ! や && 等を使えない様である。
    所謂 ice_and, ice_not, ice_or の類は gcc-3.3 のために有ったのだと今知った。

    | typename mwg::stdm::enable_if<
    |   !mwg::stdm::is_same<T,U>::value,
    |   typename rwflags_detail::rwflags_impl<T,RWFlags>::rtype>::type

  2 またバグが出た。
    依存名でない筈なのにテンプレート中だと template を付けないと呼び出せない関数が存在する様だ。

  3 更に ICE が出た。どうやらメンバおよびメンバ型は SFINAE の対象ではないようである。
    void (&X::*)(); で X = int を試すと ICE が出るし、
    &X::memfn で X = "memfn を持っていないクラス" を指定するとまた ICE が出る。
    メンバ型が判定できないとなると可成り厳しい。やはり gcc-3.3.6 はサポートの対象外とするか。

    さて今改めて調べてみると boost 1.54 は既に g++-4.0.1 以上しかサポートしない様である。
    更に、g++-4.5 未満は子ライブラリによってはサポートしなくても良いという事になっている。
    [[Installation and compatibility - 1.54.0>http://www.boost.org/doc/libs/1_54_0/libs/log/doc/html/log/installation.html]]
    boost がサポートしていないのであればまあ諦めても良いかという気がする。

* gcc-2.95 未だコンパイルが通らない。保留。

  2016-03-26: 今日検索していて気付いたのだが実は gcc-2.95 は SFINAE がないとか。
    道理で overload ができない訳である。
    エラーメッセージで SFINAE が働いていないかのように表示されていたのは寧ろ当然で、
    何となく SFINAE を使っている気になっていた部分が動いていた方が不思議なのである。

    それとは別に複雑なテンプレートを使用して
    overload を実現しようとしたコードが通らない。ICE になる。
    単純なテンプレートで overload を実現しようとすると通るのだが。。。

2016-03-24

* gcc-2.95 support

  gcc-2.95 の g++ をサポートしようとしたが gcc-2.95 には色々と問題がある。

  1. #line hoge file とすると、

    後に続く #include "..." の起点が勝手に #line で指定した物に置き換わる。
    つまり、gcc-2.95 をコンパイルする時には #line は off にしておかなければならない。

  2. そもそも簡単なプログラムが通らない。

    | 1 簡単なプログラムが通らない
    |
    |     #include <algorithm>
    |     int main(){return 0;}
    |
    |     $ /opt/gcc-2.95.3/bin/g++ stl.cpp
    |
    |   上記を単純にコンパイルしようとするだけで、大量の文法エラーになる。
    |   エラー箇所を見ても特に何も見えない。何かマクロが定義されている事によるエラーだろうか。。
    |   どうもマクロを展開して調べてみると、
    |
    |     include/g++-3/streambuf.h:91: _IO_wchar_t _fill;
    |
    |   が展開された結果として
    |
    |     include/g++-3/streambuf.h:91: _G_wchar_t _fill;
    |
    |   になるが、_G_wchar_t が定義されていない事による物の様だ。試しに、
    |
    |     $ /opt/gcc-2.95.3/bin/g++ -D_G_wchar_t=wchar_t stl.cpp
    |
    |   としてみるとコンパイルが通った。何か設定でも間違えたのだろうか。
    |
    | 2 更に検索してみると _G_wchar_t は _G_config.h というファイルで
    |
    |     typedef long int _G_wchar_t;
    |
    |   の様な感じに定義される物の様である。そして、_G_config.h は、
    |
    |     include/g++-3/stl_config.h:151:#   include <_G_config.h>
    |
    |   として読み込まれる筈である。検索してみるが、_G_config.h は見付からない。うーん。
    |
    |     $ /opt/gcc-2.95.3/bin/g++ -MD -D_G_wchar_t=wchar_t stl.cpp
    |     $ grep _G_config.h stl.d
    |     /usr/include/_G_config.h /usr/include/bits/types.h \
    |
    |   つまり、元からシステムに入っている _G_config を使おうとしているという事だ。
    |   改めて確認する。
    |
    |     $ find /opt/gcc-2.95.3/ | grep config
    |     /opt/gcc-2.95.3/include/g++-3/stl_config.h
    |
    |   やはり gcc-2.95.3 は _G_config を提供していない。
    |   仕方がないので /usr/include/_G_config.h の方を観察する。
    |   うーん。libio.h の一部のファイルのように書かれている。
    |   この libio は標準ライブラリの一部のようである。
    |   そして この _G_config.h の中身は 2012 頃に (?) 大整理された様である。
    |
    | 3 似たような問題として _G_config.h が見付からないと言っている人がいる。
    |
    |     https://gcc.gnu.org/ml/gcc-help/1999-q3n/msg00396.html
    |
    |   そこへの回答は、gcc を tarball からインストールする時は、
    |   唯単に make install するだけでは駄目なのだと書かれている。
    |   何とそうなのか。。当然 gcc-2.95.3 を入れる時には整理しかしていない。
    |   →gcc-2.95.3 の install の index.htm を観察してみたが
    |     _G_config.h については何も書かれていない。
    |
    | 4 分からないので、gcc-2.95.3 を丸まる検索してみる。どうやら
    |
    |     ./i686-pc-linux-gnu/libio/Makefile:_G_config.h: ${srcdir}/gen-params
    |
    |   とあるぐらいだから、_G_config.h は自動的に生成される筈の物のようである。
    |   仕方ないので再度 ./configure & make を試してみる事にする。
    |
    |   コンパイルできないエラーになる。gcc-5.3.1 が悪いのか?
    |
    | 5 仕方がないので gcc-4.6.3 で試す。今度は別のエラーになる。
    |
    |     /usr/include/bits/stdio-lock.h:47: #if defined _LIBC && IS_IN (libc)
    |
    |     sudo sed -i 's/defined _LIBC/defined (_LIBC)/' /usr/include/bits/stdio-lock.h
    |
    |   で無理矢理システムのヘッダを修正する。(/usr/include/bits の中で、
    |   このファイル stdio-lock.h だけタイムスタンプが古かったから
    |   何かサポートされなくなったファイルなのだろう。)
    |   でもそれでもエラーは変わらない。問題があったのは、IS_IN の方だろうか。
    |   段々諦めるしかない様な気がしてきた…。検索してみると…
    |
    |     https://sourceware.org/ml/libc-alpha/2014-08/msg00337.html
    |
    |     bits/stdio-lock.h について以下を追加する
    |
    |     +#ifndef _LIBC
    |     +# define IS_IN(lib) (0)
    |     +#endif
    |
    |   という話があるのでこれを試してみる事にする。するとこの問題は通った。
    |
    | 6 ところがまたエラーになる。今度は _G_*_t の類が定義されていないとエラーになる。
    |   そもそも _G_*_t の類を正しく定義する為にコンパイルをやり直しているのに、
    |   その途中で _G_*_t が要求されるのはおかしい。
    |
    |   もしかすると _G_config.h が正しく生成されているにも拘わらず
    |   誤った _G_config.h が読み込まれてしまっているだけなのだろうか。
    |   という事で _G_config.h を検索してみるがやはり未だ生成されている気配はない。
    |
    |   試しに以下をやってみると呆気なく _G_config.h が生成された。
    |
    |     cd i686-pc-linux-gnu/libio
    |     make _G_config.h
    |
    |   直後に make をしてみたら新しく生成された _G_config.h が読み込まれている様である。
    |
    | 7 それでも未だエラーはある。新しく作成された _G_config.h の中に、
    |
    |   34:typedef _G_fpos_t _G_fpos_t;
    |   45:typedef __sigset_t _G_sigset_t;
    |
    |   という行があるのである。先ず _G_fpos_t を定義するのに _G_fpos_t を必要としているのは変である。
    |   更に、__sigset_t も恐らく定義されていないのだろう。もう面倒なので別の場所から取ってくる。
    |
    |   https://classes.soe.ucsc.edu/cmpe202/SimpleScalar/glibc-1.09/sigset.h
    |   typedef unsigned long int __sigset_t;
    |
    |   https://fossies.org/dox/glibc-2.23/generic_2__G__config_8h_source.html
    |   typedef struct
    |   {
    |     __off_t __pos;
    |     __mbstate_t __state;
    |   } _G_fpos_t;
    |
    |   /usr/include/bits/types.h:131:__STD_TYPE __OFF_T_TYPE __off_t;  /* Type of file sizes
    |   /usr/include/bits/typesizes.h:51:#define __OFF_T_TYPE           __SYSCALL_SLONG_TYPE
    |   /usr/include/bits/typesizes.h:31:# define __SYSCALL_SLONG_TYPE  __SQUAD_TYPE
    |   /usr/include/bits/typesizes.h:34:# define __SYSCALL_SLONG_TYPE  __SLONGWORD_TYPE
    |   /usr/include/bits/types.h:96:# define __SQUAD_TYPE              __quad_t
    |   /usr/include/bits/types.h:108:# define __SQUAD_TYPE             long int
    |   /usr/include/bits/types.h:93:#define __SLONGWORD_TYPE   long int
    |
    |   うーん。libio は何とか無理矢理コンパイルが通る様になったが、
    |   結局別の物が全然コンパイルが通らない。
    |   今度は libiberty の Makefile が生成されていないと言っている。そんな。
    |
    |   _G_config.h ができたので取り敢えずこれで良しとして手でこの _G_config.h をコピーする事にした。
    |
    |   $ sudo cp -i _G_config.h /opt/gcc-2.95.3/include/
    |
    |   最初の単純なソースファイルが特別な指定無しで通るようになった。

    [まとめ]

    結局手で gcc-2.95.3 用の _G_config.h を作成して /opt/gcc-2.95.3/include に配置した。

* %%c_str() の実装。%% → fix() の実装

  const XCH* を受け取る様な他の関数に指定する為に。
  直接 c_str() で const XCH* とするのは難しい。
  というのも、実際のデータを一時オブジェクトに結びつけなければ、
  データが使用前に消えてしまうからである。
  つまり、c_str() の呼び出し側に一時オブジェクトを作成しなければならない。

  a 一つの方法は operator->() の連鎖で一時オブジェクトを呼び出し側に作成する。

    | struct tmpbuff{
    |   std::vector<char_type> data;
    |
    | public:
    |   tmpbuff(...);
    |
    |   tmpbuff* operator->(){return this;}
    |   tmpbuff const* operator->() const{return this;}
    |
    |   char_type const* c_str() const{return &data[0];}
    | };
    |
    | struct strbase{
    |   tmpbuff operator->() const{return tmpbuff(*this);}
    | };
    |
    | mwg::make_str("hello").toupper()->c_str()

    これは以下の様に解釈される。

    | mwg::make_str("hello").toupper().operator->().operator->()->c_str()
    |                                  ~~~~~~~~~~~~ ~~~~~~~~~~~~
    |                                  バッファ構築 内部ptr取得

    しかし乍ら、c_str() の時だけ -> を使ってアクセスしろ
    というのも分かりにくいインターフェイスである。これは混乱を生む。

  b 或いは、c_str() で一時オブジェクトを返し、
    そこから operator const XCH*() const でポインタに変換して貰う。

    | struct tmpbuff{
    |   std::vector<char_type> data;
    | public:
    |   tmpbuff(...);
    |
    |   operator const char_type*() const{return &data[0];}
    | };
    |
    | struct strbase{
    |   tmpbuff c_str() const{return tmpbuff(*this);}
    | };
    |
    | mwg::make_str("hello").toupper().c_str()

    この方法は記述の仕方については一番自然である。

    しかしながら、operator const char_type*() const が期待通りに呼び出されるかは不明である。

    x 例えば、printf の引数に渡したい時には (...) に適合させる為に
      const char_type* を自動的に呼び出してくれるという事はありえない。
    x また、テンプレート引数 + SFINAE みたいな構造になっている関数の場合も、
      テンプレートパラメータに tmpbuff が直接入ってしまってうまく行かない。

    やはり色々と微妙な方法である事は否めない。

  c 一番何もない方法は、ユーザに二段構えで呼び出して貰う事である。

    つまり使用時に、

    | mwg::make_str("hello").toupper().fix().c_str()

    の様に指定して貰うことである。

    というか途中で好きな時に現物バッファを作成できる、
    という点で fix() という関数は有って然るべきと思われる。

    それに、また fix() という関数を使わせる事によって、
    ユーザに対して mwg::str がどの様な動作を内部でしているのかを理解して貰う良い機会になる。
    多少学習コストは上がるかも知れないが、学習させずに隠蔽させてユーザに混乱を招くよりは良いだろう。

  これはもう殆ど fix() 関数しかまともな選択肢はない。

  Done> fix()を定義する
  Done> string に限って fix を上書きして自分自身を返す様にする

  % strsub についても fix で自分自身を返して良い気がする。
  % となると fix という関数名はどうなのか…
  % と思ったが、よく考えたら strsub は null 終端していないので
  % c_str にはできない。バッファへのポインタは取得できるが。

  なんか -> の方が良い気もしてきた…。

  a s.fix();

  b s(); // operator()();
    s.fix() と毎回書くのが面倒であれば、
    s() とだけ書けばよい様にしておいても良い。
    しかし、たかが文字列バッファ構築に () を使ってしまうのは勿体ない気がする。
    (といって、他のよりよい用途が思い付く訳ではない気がする)

  c s++; // operator++(int);
    後置演算子というのであればこれでも良いが、
    意味的に変である。却下である。

  d s->
    こうなったら -> でも良いような気がしてきた。
    後続する関数もそのまま呼び出せる。
    何も関数を呼び出すつもりがない場合には単に s.fix() としておけば良い。
    つまり、fix と operator-> を両方定義するということ。

    但し、-> についてのドキュメントは丁寧に書くのがよい。
    例えば、"メソッドチェインの途中で一旦バッファに文字列を構築するポイントを表す" 的な感じにする。

  Done> operator->() も追加する。
  Done> strfix については自身へのポインタを返す。
  Done> operator->() の説明を注意深く行う。

2016-03-23

* pointer_const_iterator はやはり単なる pointer でも良いのではないかという気がする。

  - %% const_iterator::has_index → mwg/concept.h で自動判定する様に変更。

  - const_iterator::some_type → 誰も mwg/str.h 内部では使っていない気がする。
    使っているのは std::iterator_traits だけであるが、ポインタについては特殊化されているので心配ない。

  さえ適当にテンプレートを経由して取得できる様にしてしまえば何も問題はない。

  - 但し、基底クラスにする時は、そのためだけに wrapper をかませる必要がある。
    つまり、基底クラスにする為に pointer_const_iterator が必要となる。

    →const_iterator を基底クラスにできる型にする為に
      wrap_iterator<Iter>::type を実装した。
      Iter がポインタならば wrapper として pointer_const_iterator を返す。
      それ以外の場合は Iter をそのまま返す。

* pp include したファイルも makefile で追跡できるようにする?
  前実装しようとしていたような気がするが結局現在はどのような状態か?

  →mwg_pp.awk の方にその様な機能を実装しただけで、
    実際には mmake では全くその様な物は用意されていなかった。


2016-03-22

* mwg/str: strfix の default/copy/move constructors
  と copy/move assignments は自動で生成される物では駄目なのか。

  default constructor に関しては、
  他に constructor を一つでも定義すると削除されるので、
  明示的に定義する必要がある。

  copy/move constructors/assignments に関しては、
  テンプレートで定義した別のコンストラクタと
  どちらが優先されるかという問題になる。

  C++ の仕様的にはどちらだろうか。
  分からないので取り敢えず実験してみることにする。

  [[/test/20160318.c++.implicit_copy_ctors_vs_template_ctors.cpp]]

  どうやら、テンプレートによる copy/move コンストラクタが一致するとしても、
  コンパイラが自動で定義する copy/move コンストラクタの方が優先される様である。
  従って、わざわざ strfix に明示的に copy/move コンストラクタを定義する必要はない。
  代入についても同様で、テンプレートによる copy/move 代入演算子が一致するとしても、
  コンパイラが自動で定義する copy/move 代入演算子の方が優先される様である。
  これらの振る舞いは clang 3.7 及び g++ 5.3.1, g++-2.95.3, vc++9 (VS2008) で確かめた。
  と思ったら icc14 が move assign に関してだけ別の振る舞いをすることが判明した。

  という事は注釈付きでこれらのコンストラクタを残しておいた方が安全に思われる。

  % というか改めて確認した所 template assign の実装が怪しい。
  % →いややはりOKだった。reset という関数名から shared_ptr::reset
  %   が呼び出されているのかと誤解しただけであった。

  strbuf の実装に際して暫定的に strfix のコンストラクタをそのまま流用するが、
  strfix のコンストラクタを整理するのと同時に strbuf の方も一緒に整理する必要がある。

  また別のクラスに関しても丁寧に確認する必要がある。
  →取り敢えず template constructors だけ確認した。問題無さそうである。

* mwg/bits/str.support.xprintf.h:
  strbuf_xprintf_writer が virtual であるが、
  virtual にしなくても済むような方法を考案する。

  または、xprintf_writer 自体にキャッシュ機能を付けて効率的にする。
  →取り敢えず xprintf_writer にキャッシュ機能を付ける方針で行く事にする。

  --- flush の問題 ---

  xprintf_writer にキャッシュ機能を付けるのが良いアイディアだと思ったが、
  最後の flush をどうやって行うかが問題になる。
  xprintf_writer であって派生クラスではないので flush も xprintf_writer から呼び出すのが自然である。
  愚直に考えればデストラクタで実行すればよいが xprintf_writer のデストラクタは、
  派生先で override された flush 関数を呼び出すことができない。
  何故ならデストラクタが呼び出される時には既に派生クラスは消滅して、
  virtual 関数は全てそのデストラクタを定義しているクラスで宣言した物
  (override されていない物) が呼び出されるからである。

  a 一つの方法は派生先のデストラクタで明示的に xprintf_writer::flush を呼び出させることである。
    或いは派生先から xprintf_writer::buffer の内容を直接読み取って処理する様にする。
    しかし、問題はこのルールを注意深く守って実装しなければならない事である。
    実装側でデストラクタを呼び出し忘れていても普通にコンパイルが通ってしまう。
    それでも xprintf_writer::~xprintf_writer 側でバッファが空かどうかをチェックする事はできるので、
    実装し忘れている人に注意を促すことはできるが間接的なので分かりにくい。

  b もっと別の方法で実現するしかない。例えば、xprintf_writer は抽象クラスにせず、
    xprintf_writer のメンバとして書き込みを行うクラスを保持するのである。
    書き込みを行うクラスはダックタイピングで良い。
    というか mwg::functor<void(char const*,int)> で受け取れる様にしてしまう。

  xprintf_writer は基本クラスではなく、functor をメンバに初期化するクラスに変更した。
  mwg::functor は結局仮想関数呼出になるし、
  またサイズの大きなファンクターの場合内部でメモリを確保する事になるが、
  これは仕方がないと諦める事にする。

  -- virtual にしなくても済む方法? --

  a 出力する文字列を std::vector だか std::string に溜めさせて、
    それをその都度呼び出し側で処理する様にする。

    x メモリ確保が生じるので余り速いとは思えない。
      メモリ確保が生じない程度の出力に抑えるのは実装が汚くなる。
    - メモリ確保が生じない程度に出力内容を溜めて仮想関数を呼び出す方法は、
      現状の xprintf_writer の実装に等価である。

  b ヘッダが巨大になる事を厭わないのであれば、
    実装を全て xprintf.h に読み込んでしまえばよい。

    o この様にすれば最早明示的テンプレート実体化の面倒な指定も必要ない。

    x 大して処理内容的に違いがないにも拘わらず出力先毎に
      テンプレート関数が実体化されるのは非効率にも思われる。
      また、コンパイル時間も当然長くなると予想される。

    o 事前のコンパイルが必要なくなるので、利用・移植しやすくなる。

    再度 xprintf.cpp を眺めてみたが template に為っている部分は十分小さい。
    つまり、xprintf.h に読み込んでしまっても問題ないような気がしてきた。

  上記の内やはり b がすっきりする気がする。
  コンパイル時間もそんなに気にならないだろうという結論に達する。
  コンパイル時間が気になる場合の為に、
  template の実装は別のファイルに分離して明示的実体化も一応用意する。

2016-03-20

* mwg/bits/str.support.xprintf.h テストを追加する

[整理]

* mwg/str: char_at_type を reference などに名称変更?

  今後文字列の表現として、データの要素の型と文字コードの型を分ける可能性がある。
  単に reference となっているとその時に不都合がある。
  現状の実装は寧ろデータの要素の型(の参照)ではなくて、
  文字コード(への参照)を char_at_type としている。
  この辺りは後で総合的に考える必要がある。

  →取り敢えず char_reference に名称を変更した。
    これを更に reference にまで変更するかどうかは後で考える必要がある。

* mwg/str: xprintf support

  xprintf は数を数えてから出力するという風にはなっていなくて、
  数を数えるのも文字を実際に出力するのも同程度の計算を要する。
  従って、二重の処理にならない様に内部に std::string でも構築して
  mwg::str インターフェイスを提供するのがよいように思われる。
  その為には strbuff を先に実装してしまった方が良い様に思われる。

  所で strbuff を実装するのに std::string を読み込む必要が出て来る。
  別のヘッダファイルとして実装するのがよいかも知れない。
  特に strbuff は、破壊的関数を備える必要の為に、
  今後実装が巨大になる可能性が高いのでこれでよい。
  (破壊的関数を備えるため、実際の所 std::string ではなくて
  std::vector を利用した実装に切り替える可能性もある。)

* C++: 一時オブジェクト用インスタンスのローカル変数作成を阻害する方法

  (特に mwg/str における一時文字列クラス達を想定している)

  式テンプレートを使う時、完結式評価まで一時オブジェクトの寿命が残る事を利用する。
  しかし、完結式のオブジェクトをコピーされたり、
  或いは、ユーザの手で完結式のクラスインスタンスを作成すると不正な参照・ポインタができてしまう。

  1 ユーザが明示的に一時オブジェクト用クラスインスタンスを作成できない様にするには:

    a 一番簡単な方法はそのクラスの名称を如何にも一時オブジェクトという感じにして、
      ユーザが明示的にそのクラスを使用しない様にすることである。
      例えば、foo_detail 名前空間の中に隠蔽したり、
      _tmpobj_... という名前のクラスにしたりといった事である。
      或いは、クラス名を dont_use_this_class 的な物にしても良いかも知れない。

      しかし、その様にしても文法的にはクラスインスタンスを作成できてしまう。

    b 文法的にも呼び出せない様にするためには、
      コンストラクタを隠蔽すればよい。つまり private または protected にする。

      x しかし、この様にすると外部の関数で実際にインスタンスを生成したい時には、
        その関数を friend にする必要が生じる。結構始末が悪い。
        ただ、これはクラス内に friend 関数{実装} などとしてしまっても良い?
      →それだと後からどんどん関数を追加するという事がしにくくなる。
        特にユーザがユーティリティ関数を追加する事を阻害してしまう。

  2 また、オブジェクト作成用のコンストラクタを封じたとしても、コピーはできるから、

    auto a = <expr>;

    等とされると問題になる。なので、コピーコンストラクタも封じるという手がある。

    x しかし、これも戻り値を構築する時にコピーが発生する筈なので、
      使用している箇所を一つ一つ friend にしておかないと、
      エラー (もしくは RVO でコピーが潰れれば警告) になる。

    x そればかりか、RVO が働ければコピーが消えて、
      普通にコンパイルできてしまうので、防御にならない?
      (でも、流石にコピー構築までは消えないか? 良く分からない。)

    x 更に、防御が成功したとしても単に auto a = <expr>;
      がエラーでコンパイルできないという事になる。
      自動的に (永続化のための) 適切な型を選んでくれるという事がない。

      つまり、ユーザは以下のように必ず型を記述しなければならない。

      mwg::strfix<char> a = <expr>;

      これは C++11 時代にあっては不自然だと考える人も多かろう。

  3 更に、コピーコンストラクタまで封じることができたとしても問題は未だ残る。
    参照として寿命を拡張することができる。この場合はコピーも起こらない。

    auto const& a = <expr>;

  試しに strbase に friend 指定でコンストラクタを書いてみることにする。

  | protected:
  |   template<typename P2>
  |   friend class strbase;
  |
  |   // copy/move constructor is protected
  |   strbase(strbase const& source)
  |     :data(source.data){}
  | #ifdef MWGCONF_STD_RVALUE_REFERENCES
  |   strbase(strbase&& source)
  |     :data(stdm::move(source.data)){}
  | #endif

  operator+ がコンパイルできなくなる。
  SFINAE やら SFINAE 用のクラスやらの依存性もあるし、
  friend 指定を書くのも面倒である。どうした物か。

  何れにしても今後、一時文字列を返すような関数は幾らでも作るはずである。
  その度に friend を書くのも大変であるし、
  friend を省略できるような仕組みも分からない。
  →例えばユーティリティクラスの様な物を作って、その中で実装する様にすれば良い?
    試してみたが、駄目だ。return をする為には結局コンストラクタが必要の様である。
    つまり、別の関数で実装を行ったとしても、
    friend 指定がなければ戻り値を受け渡す事ができないので駄目である。
    別の関数に実装を委譲するのだとしたら、
    委譲される鎖の全ての関数を friend にしなければならない。
  →よく考えたら使う時にそこで新しく専用の派生文字列クラスを定義して、
    その専用の派生クラスで friend に指定すれば良いだけでのことである。大した事はない。

  % 結局面倒臭くなるだけの様なのでコンストラクタで封じる案は今の所考えないことにする。

  a protected にしておいて、friend にしたければ派生クラスを作って
    其処に friend 宣言すればよいのだという事に気付いたのでそれで実装する。

  b 実は list-initializations in return statement を使えば、
    copy constructor は必要ないので、エラーには為らないという事が分かった。
    (規格を見ても不明瞭な気がするが、実際の実装ではどれもこれを受容する様である。)

    つまり、C++03 では auto v = 等とされる心配がないのでコンストラクタを封じる必要はなく、
    また C++11 では auto v = を封じる為に copy constructor を封じ、
    構築には list-initialization を用いる様にすれば良いという風に場合分けで対処すればよい。

  c 或いは…tuple を受け取る特別なコンストラクタを用意すれば、
    copy constructor を回避できるだろうか?■未確認

2016-03-07

* mwg/str: _tmpobj_arrow_operator のテストをしていない。
  →テストを追加した。まあ、動いている。OK

* mwg/str: const_iterator を BidirectionalIterator にする。

  mwg/str で実装している const_iterator を、他の STL に対応した関数に渡す時には、
  Iterator の要件を満たす様にしなければならない。

  - 特に value_type, iterator_category などのメンバには、
    std::iterator_traits<> から派生させることで対応できる。

  - iterator_category としては、特に、BidirectionalIterator に該当する。

  - 対応していない機能として、operator-> がある。

  - また、BidirectionalIterator の為に DefaultConstructible でなければならない。

  - *i の戻り値の要件

    % また、Iterator の要件で満たせない物として、
    % *i が %%dereferencable でなければならない (*i は参照である)%% という物がある。

    混乱があった。dereferencable というのは間接参照できる事である。
    つまり、*i という標記自体の事である。
    そしてドキュメントに dereferencable と書かれているのは、
    「i の現在の状態が間接参照可能な状態である場合に」という意味であった。
    (終端を表す iterator や、既定コンストラクタで作った iterator は間接参照可能な状態にない)

    この条件を改めて見てみると以下の事の様である:

      *i の戻り値の型は std::iterator_traits<Iter>::reference でなければならない。

    そして、std::iterator_traits<Iter>::reference が
    どの様な要件を満たしているべきかについては何も書かれていない気がする。
    少なくとも value_type に変換可能であれば良いようにも書かれている。
    そしてまた、OutputIterator の場合には (使用しないため)
    reference は void にして良いという事になっている。
    やはり、reference が (目的に合わせて) 多少変な型であっても良いということだろうか。

  という訳で以下の実装を行う。

  > - std::iterator<std::bidirectional_iterator_tag, char_type, std::ptrdiff_t, char_type*, char_at_type>
  > - 先ず reference は char_at_type である
  > - operator-> を追加する
  >   →char_type はどうせ整数型しか来ないのだから、
  >     operator-> を定義しても意味無いのではないだろうか。
  >
  >     何か特殊な機能を文字型に付加してその文字型を使いたいとしても、
  >     文字列の汎用 const_iterator を受け取るような関数でその機能を使う事は無い。
  >     但し、特殊な文字型を使った文字列を定義して、
  >     更にその特殊な文字型専用の関数で処理を行いたい場合には必要になる。
  >     →どうせ使わないだろうとは思うが実装しておく事にする。
  >
  > - DefaultConstructible にする
  >   →実装した。参照メンバはポインタにする。
  > - const_iterator 内部では std::ptrdiff_t の代わりに difference_type を使用する。
  > - StringPolicy 要件部分で bidirectional_iterator を要件として掲げる。

  # 余談
  #
  # ところで、std::iterator_traits<Iter>::pointer は何の為にあるのだろう?
  # iterator 要件には何処にも出てきていない様に見える。
  # そして pointer 自身、何であるか説明していないので、規格上は何の制限もない無意味な型という事になるのでは?
  # 一応 operator-> を自分で実装するとすれば pointer を内部的に使うという事は考えられるが、
  # std::iterator_traits<T*>::pointer の場合には operator-> ではなく builtin の -> なので、
  # Iterator の要件には明示的には出てこない。それに pointer とは別に勝手に operator-> を定義しても良い。

  更に後で以下の項目についても考える。

  > - pointer_const_iterator は std::random_access_iterator_tag にしたいが、これについては後で考える。
  >   →別項目で議論することにした。
  >
  > - char_at_type の名称を別の名称に変更する。
  >   というか普通に reference で良い気がする。
  >   →これも別項目で。

* mwg/str: const_iterator は std::random_access_iterator_tag にするべきか?

  然し、現在の実装を見てみるに殆ど RandomAccessIterator の機能を備えている様にも見える。
  先ず、operator+(ptrdiff_t) や operator-(ptrdiff_t) を保持している。(operator+=, operator-= も自動的に定義されるであろう。)
  更に、operator-(const_iterator) もある。一部の const_iterator は不等号演算子についても備えている。
  これに加えて operator[] を定義すれば random_access_iterator にする事ができる。

  どうせ operator+/- を定義するのであれば、要件を RandomAccessIterator にまで厳しくしてしまっても良いのではないか。

  x 調べてみたが実は operator+/- を使っている箇所は殆どない。というか、trim の中だけである。
    なので、RandomAccessIterator である事を要求するのは新しい文字列の形式を実装しにくくするだけなので良くない。
  x 特に mbcs において RandomAccess は非効率である。
    無理に RandomAccessIterator を実装してしまうと、STL 等の関数で RandomAccessIterator 用の実装が選択されてしまい、
    RandomAccess できない場合に最適化されたコードが選択されるのを阻害してしまう事になる。よくない。
  x もともとは pointer_access_iterator 等の
    RandomAccessIterator を自然に満たせる物については、
    stdm::random_access_iterator_tag にした方が効率が良いのではないかという事であった。
    しかし、これは個別に対応すれば良い話で、全ての const_iterator に対して要求する理由には為らない。

  結果、この提案は却下する事にする。

2016-03-05

* mwg/str: 実装の名前空間 (string3_detail) を公開するべきか

  ユーザが新しい文字列型を定義する為には strbase を使う必要がある。
  また、ユーザが新しく別の型からのアダプターを追加したい場合には
  adapter_traits の特殊化を定義する必要がある。

  これらの strbase や adapter_traits は現在は namespace mwg に公開していない。
  ここで、using を用いて namespace mwg に引っ張ってくるべきか、
  拡張を定義したいユーザに対しては実装の名前空間を弄って貰う事にするか、
  という選択肢が出来る。

  a string3_detail 名前空間は公開しない。

    strbase, str_adapter_traits を namespace mwg に公開する

    独自に文字列型を色々拡張をするとなると adapter_traits 等も拡張しなければならない。
    それらも公開するとなると面倒である。先ず名前を変更しなくては為らない。
    名前はより長く為るであろう。そして、その長い名前を毎回指定するのは大変だ。
    といいつつ、結局 adapter_traits を元に定義された as_str 的なクラスを
    通して使用する予定だから長くなっても余り違いはない気もする。
    うーん。それならば、拡張する人には string3_detail (後で名前は変えるとして)
    の内部を弄る事を許可してしまった方が良い気もする。

    というかよく考えたら特殊化は元々定義された名前空間で行わなければならないので、
    namespace mwg に引っ張ってきても意味がない。
    →adapter_traits 自体を初めから namespace mwg の中で定義するという手がある。

    更に、ADL が効く様にするためにはやはり string3_detail 内で関数を定義する必要がある。
    ADL で呼び出せる様な文字列用の関数を定義したいという需要もあるだろうから
    やはり string3_detail 名前空間は公開せざるを得ない気がする。
    (strbase 自体を mwg 名前空間内で定義するという場合には、
    ADL 用の関数を namespace mwg 内に書く事になる。
    これは他の関数と混ざり合う可能性があるので、これは論外である。)

  b string3_detail 名前空間を公開する。

    名前は変更する必要がある。string3_detail は変である。

  結局現実的には実装の名前空間を公開するという方法しかないように思う。
  ユーザには以下を許可する。
  - adapter_traits の特殊化を定義すること
  - strbase を文字列型の基底クラスとして利用すること
  - ADL を通して使うための文字列を受け取る関数を追加すること

  > ドキュメントに上記許可項目を追加

  [string3_detail 名称変更について]

  > string3_detail の名称を変更
  > これはヘッダファイルの名称を考えてからにする。

  ライブラリの中心関数を mwg::str (旧 mwg::make_str) と定めて、
  ヘッダファイル名を <mwg/str.h> に変更し、
  ライブラリモジュール名を mwg/str と呼ぶことにした。
  これに伴って string3_detail 名前空間をより分かりやすい名前に変更し、
  ユーザ側に拡張を許可するために公開できるようにする。

  名前は str_detail で良いだろう。
  変な省略のされ方をしている様で違和感があるかもしれないが、
  これは今迄の名前に慣れてしまっているからの様に思う。
  実際 mwg::str という関数が中心になっていると思えばこれは自然である。

* string: ヘッダファイル名 mwg/string.h の変更?

  a mwg/string.h は分かりやすい。
    しかし実際に string という型は定義していないという点で分かりにくいかも。

  b mwg/str.h
    含まれるクラスは大体 str で始まっているのでこれが良い?
    しかし mwg::str というそのものな型は存在しない。
    或いは mwg::make_str を mwg::str に変更しても良い。

  c mwg/strfix.h
    メインのクラスは何かと考えると strfix である。
    しかしながら、このライブラリは別に固定文字列 strfix だけのライブラリではない。
    ライブラリの目的的にも、実際に中にあるクラスという観点からも。

  mwg::make_str を mwg::str に変えるのが俄然良い方法の様に思えてきた。
  しかしながら問題点もある。str というのは一般的に使用される変数名である。従って、

  1. ローカル変数の str で mwg::str が隠蔽されて、変なことになる可能性がある。
    →基本的にいつも mwg::str の形で使う様にすれば問題はない。
      元々 libmwg は using namespace mwg せずに使う事を想定して設計している。
      なので、ユーザの側でも mwg::str の形で使って欲しい。
      また、mwg 名前空間の内部では str で mwg::str を参照することができるが、
      これは mwg::str として明示的に呼び出す様に規則付ければよい。

  2. 逆にローカル変数を参照しているつもりで str が出てきて、
    変なエラーメッセージが出る可能性もある。
    「ローカル変数 str が見付かりません」の代わりに
    「関数を文字列に変換できません」の様なエラーメッセージが出る様になって分かりにくい。
    まあしかしこれは仕方がない。

  まとめ

  > mwg/str.h に変更する
  > mwg::make_str -> mwg::str
  > mwg::str を呼び出す時は、例え libmwg 内部から呼び出す場合でも明示的に mwg::str と書く。
    →そもそもそんなに使用している箇所はなかった。内部使用は1箇所だけであった。
  > 上記注意点をドキュメントに追記する。

* string: enabler という用語は別の手法を想起するので変える。

* string: クラス名変更 mwg::string → mwg::strfix

  mwg::string は std::string と衝突するので別の名前にするべき
  例えば mwg::strfix など。
  この様に変更すると最早 mwg::string という名前の型すらなくなるので、
  ヘッダの名称を mwg/str.h 等に変更するべきな気もする。

  しかしそうすると mwg::make_str を mwg::str にしたくもなるが、
  そうすると、ローカル変数として str を使用した時に混乱を来す事になるので良くない。
  <mwg/str.h> は様々な文字列クラス str... の接頭辞 str を表しているとして納得して貰う事にする。

  取り敢えず mwg::string → mwg::strfix に変更した。
  ヘッダファイルの名称についての議論は別項目とする。

2016-03-04

* string: mwg::as_str 追加

  stradp 内部クラス化の項で議論したように、
  今後文字列を受け取る関数を定義する際は adapter_traits を使用する事にした。
  しかし、現状だと adapter_traits は使いにくいので、
  adapter_traits を継承して更に色々の物を提供する公開クラスを作成する。as_str である。

  先ず as_str を定義して色々な機能をつける。
  更に、今迄 adapter_traits を使って定義していた物を
  as_str を用いて定義する様に変更する。
  そして namespace mwg に公開する。

* string: stradp 内部クラス化?

  mwg::make_str を実装したので、
  寧ろ stradp が表に出て来る必要もないのではないか?

  SFINAE チェックを省略することにする。
  adapter_traits 経由でしか構築しないのであれば、
  コンストラクタのチェックを行う意味はない筈である。

  一方で、stradp はそもそもユーザが新しく文字列を受け取る様な関数を実装する際に、
  引数の型として使用できるように定義した物であった。
  しかし、現状の実装ではその役目を果たしていない。
  というか、寧ろ template<typename T> stdbase<T> と stradp<char> の二つについて
  定義を行わなければ為らず却って無意味である。それよりは、寧ろ新しく導入した
  adapter_traits の仕組みを利用して、adapter_traits<>::available だったら実装を
  提供するという方法の方が変に overload を作成しなくて済むので楽である。

  しかしながら、SFINAE の条件を書くのが面倒であるのは否定できない。
  現在自分で新しく関数を書くのだとしたら以下の様な可能性が考えられる。

  | a strbase<> しか受け取らない:
  |
  |   template<typename P> void f(strbase<P> const&);
  |
  |   変な SFINAE をしなくても自動的に文字列だけを選択してくれるので良い。
  |   mwg::str の文字列は全て strbase<P> の形をしている。
  |   問題は mwg::str 以外の文字列であるが、これについては
  |
  |     f(make_str(s));
  |
  |   等の様に呼び出し側で配慮すれば良い様に思う。
  |
  |   →しかしながら、文字列の型の種類を区別するというのは面倒である。
  |   実際に、const char* を渡すべきところに std::string を
  |   直接渡そうとしてコンパイラに怒られたりという事はよくある。
  |   また、std::string のまま渡しておけば良いのにわざわざ c_str()
  |   してしまったせいで新しい std::string インスタンスを生成していた、
  |   などという事もあるのではないかという気がする。
  |
  |
  |   また、strbase<> だけを定義することの問題ではなくて、
  |   strbase<> を使うこと自体の問題であるが、
  |   typename P::char_type について SFINAE をしたい場合に、長くなってしまう。
  |
  |   | template<typename P>
  |   | typename stdm::enable_if<stdm::is_same<char,typename P::char_type>::value,void>::type
  |   | void f(strbase<P> const&);
  |
  |   →それ専用の enabler クラスを作成すれば問題ない。
  |
  |     | template<typename P>
  |     | typename mwg::policy_enabler<P,char,void>::type
  |     | void f(strbase<P> const&);
  |
  |     というか、policy 側に enabler を附属させれば良いのではないだろうか。
  |
  |     | template<typename P>
  |     | typename P::enable_if_char_is<char,void>::type
  |     | void f(strbase<P> const&);
  |
  |     何か余り短くなっていない気もするがこちらの方が分かり易いであろう。
  |
  |   →更に他のSFINAE も混ざってくるとこの方法は使えない?
  |
  |     そういう時は、入れ子にすれば良いだけである。例えば以下のように。
  |
  |     | template<typename P>
  |     | typename P::enable_if_char_is<char,
  |     |   typename stdm::enable_if<条件式,Ret>::type
  |     | >::type
  |     | void f(strbase<P> const&);
  |
  |     というか、今迄 enabler を入れ子にするという事を考えた事がなかった。
  |     enable_if しか使わないのであれば単に && で繋げばよいが、
  |     enabler を定義して、更にそれを組み合わせる場合には、
  |     わざわざ新しいクラスを定義しなくても単に入れ子にすればよいのだ。
  |     もしかすると今迄に整理したコードの中にもこの手法で
  |     簡単に定義できる物が存在するのではないかという気がしてきた。
  |
  | b そもそも mwg::str を受け取る関数にしなくて良い?
  |
  |   標準ライブラリでも std::string を受け取る関数というのは実はほとんどない。
  |   std::string を使っていても最終的には c_str() を用いて const char* に変換して、
  |   その上で使うのである。そちらの方が分かりやすい。
  |   分かりやすさが効率を上回る例である。
  |
  |   特に C++ に関しては標準的な一つの文字列型というものが存在しないのが問題である。
  |   標準ライブラリには std::string と std::wstring があるし、
  |   更に自分で Traits や Allocator を定義して新しい文字列型を定義できる。
  |   更に、文字列の内部表現について (文字符号化方式など) 定められてもいないため、
  |   同じ文字列型であっても更に色々な様相を見せる。
  |
  |   その様な滅茶苦茶な状態に於いて一つの標準形式として
  |   const char* を採用するというのは悪くない選択肢のように思われる。
  |   どうせ、他のユーザーフレンドリーな言語に於いては、
  |   文字列と言えば必ずメモリに確保した一種類の型であるのだから、
  |   C++ においても外部の関数に渡すときぐらいは、
  |   その必然性が無くても新しくメモリに格納してもよいだろう。
  |
  |
  |   この場合には strbase<> 側に c_str 的な関数を用意する必要がある。
  |
  |   | struct _tmp_cstr{
  |   |   std::unique_ptr<const char[]> data;
  |   | public:
  |   |   operator const char*() const;
  |   | };
  |   | struct strbase{
  |   |   _tmp_cstr c_str() const;
  |   | };
  |
  | c adapter_traits を使って何でも受け取れる様にする
  |
  |   | template<typename S>
  |   | typename stdm::enable_if<mwg::as_str<S>::value,void>::type f(S const&);
  |
  |   戻り値に char_type などを使いたければ、単純に
  |
  |   | template<typename S>
  |   | typename mwg::as_str<S>::char_type f(S const&);
  |
  |   等の様にすれば良い。
  |
  |   % [SFINAE が面倒になる問題(可能性)]
  |   %
  |   % しかし更に複雑なことをしようとすると以下の様に面倒な事になるかも知れない。
  |   %
  |   % | template<typename S,bool=mwg::as_str<S>::value>
  |   % | struct enabler{};
  |   % | template<typename S>
  |   % | struct enabler<S,true>:mwg::identity< 複雑な戻り値 >{};
  |   % | template<typename S>
  |   % | typename enabler<S>::type f(S const&);
  |   %
  |   % と思ったが、現実にこの様な面倒な指定をしなければならないのは、
  |   % "enabler を作りたい" という場合だけの様な気もしてきた。
  |   %
  |   % enabler を作る場合には、内部で return_type を構築する必要がある。
  |   % しかし内部で構築する場合には SFINAE が効かない。
  |   % つまり、戻り値の型が不正な形式になるとコンパイルエラーになる。
  |   % という事で、使えるかどうかの判定部分と、実際に戻り値の型を定義する部分を分離しなければならない。
  |   % しかして、上記の様に条件と戻り値の型の定義が分かれて面倒な事になるのである。
  |   %
  |   % さて enabler ではなくても上記の様な形式を取る必要がある場合も存在する。
  |   % つまり SFINAE が効かない様な内部で型の不整合が起こる場合である。
  |   %
  |   % | template<typename P>
  |   % | struct hoge{typedef hoge_return<typename P::char_type>::type type;};
  |   % | typename hoge<P>::type
  |   %
  |   % しかしこの様な場合については hoge 側で防御をするべきである。
  |   %
  |   % [結論]
  |   % - enabler を作りたいという場合には、条件と戻り値の型を分離する必要があり面倒である
  |   % - 通常の SFINAE ならば問題ないはずである。
  |   %   呼び出した別のテンプレート内でエラーが起こるのであれば、それはそのテンプレート側で防御をするべきである。
  |
  |   [条件判定用クラスの名称]
  |   mwg::string3_detail::adapter_traits は如何にも長いのでより短くて分かりやすい名前を考えたい。
  |   例えば
  |   - adapter_traits<S>::available    → mwg::as_str<S>::value
  |   - adapter_traits<S>::adapter_type → mwg::as_str<S>::adapter
  |       これの使い方は決まって typename mwg::as_str<S>::adapter str(s) である。
  |       もっと短い書き方はない物だろうか。
  |
  |       % 実は auto str = make_str(s); でいける様な気もする。
  |       % が、auto で受け取ると _strtmp も固定する事ができてしまったりして
  |       % 初期化できてしまったりして問題が多い気がする。
  |       % といって、ユーザに使用の制限を呼びかけたとしても通じるか分からない。
  |       %
  |       % やはり標準的な使い方は adapter str(s); であろう。
  |
  |   - adapter_traits<S>::char_type → mwg::as_str<S>::char_type
  |
  |   また、他に追加するとすれば:
  |   - typename mwg::as_str<S>::const_iterator
  |
  |   % [mwg::str として受け取ると文字操作が面倒な可能性]
  |   %
  |   % 何でも受け取れる代わりに操作は限られる。ランダムアクセスできない。
  |   % mbcs の効率を考えれば iterator を使って実装しなければならないので面倒。
  |   %
  |   % それならばいっその事 c_str にでも変換してから処理した方が良い?
  |   % →×でも mbcs の場合には単に c_str にするだけだと結局処理が難しいから、
  |   %     効率良く処理する為には wint_t 配列などにしなければならない。
  |   %     そして const wint_t* の様な物を標準の交換形式にするのは考えがたい。
  |   %
  |   % 逆に言えば mbcs の処理も考えるのであれば iterator にならざるを得ず、
  |   % もしそうだとするならば strbase<> に変換して処理するのは必然である。
  |   % なので、これは別に気にすることではない。
  |   %
  |   % [結論]
  |   % - mbcs の処理効率を考えるのだとすれば iterator を使って実装するのは当然である。
  |   %   寧ろ面倒でもそれを強要する形になるのでよい。
  |   % - ランダムアクセスを用いてより効率の良い処理をしたい場合もあるが、
  |   %   それは元々、既定の実装をした後で、別に実装するべきものである。
  |
  | d strbase<> と後は stradp を受け取れる様にしておく。
  |
  |   | template<typename P> void f(strbase<P> const& str);
  |   | void f(stradp<char> const& str){return f(static_cast<strbase<mwg::strsub_policy> >(str));}
  |
  |   或いは、strbase const& strbase::to_base() const; 等という関数を定義しておけば、
  |
  |   | template<typename P> void f(strbase<P> const& str);
  |   | void f(stradp<char> const& str){return f(str.to_base());}
  |
  |   とすれば良い。
  |
  |   これは結構良さそうにも思うが、実際にやってみようとすると結構面倒だと分かった。
  |   何が面倒かというと
  |   1. 複数の引数があると 2 の累乗で定義するべきオーバーロードが増える。
  |   2. 複雑な SFINAE がある場合に、何度も同じ様な SFINAE を書くのは綺麗ではない。
  |     enabler にまとめようとすると、
  |     今度は a の所で述べたような面倒(というか見にくいコード)が発生する。
  |
  |   とにかくこの方法は良い方法だとは思えない。

  結論としては、
  - mbcs 対応や効率を考えるのであれば adapter を用いる方法 c を使う。
  - 次点として b の const XCH* で実装する方法を用いる。
    結局これが一般的なインターフェイスであるから。
    但し、c_str() を呼び出す様にするのを忘れないこと。

    (あと、c_str() は未だ実装していなかった…→これは別項目で考察する)

  これで d の様な stradp を使用する可能性は殆どなくなった。
  従って、stradp を内部オブジェクトに変更する事にする。
  また、a もしくは d の様な物を補正しない限りは strbase を使用しないので、
  strbase は今迄通り公開しなくても良い?
  →と思ったが、独自に新しい文字列型を実装する場合には strbase を使用する。
    従ってやはり strbase は公開した方が良いのではないか?
    これについては独立した項目を立てて考察する。

* string: mwg::make_str()

  わざわざ std::stradp<char> などの様に文字の型を指定しなくても、
  自然な文字の型を推論する事ができる筈である。

  これの実装に伴い adapter_traits を拡張して
  必ずしも stradp を adapter としなければならない訳ではない様にする。
  今後 adapter_traits は以下の3つを提供する。

  - adapter_traits::available    文字列(mwg::string)に変換可能か
  - adapter_traits::char_type    文字列(mwg::string)の要素の型
  - adapter_traits::adapter_type 文字列(mwg::string)の型(アダプタ文字列型)

  この変更により既存の使用箇所で不整合が起こっている可能性がある。
  > adapter_enabler の使用箇所を確認・修正
  > 特に stradp のコンストラクタの SFINAE に注意する。

  > adapter_traits に str 自身を定義する。strbase_tag を使用

  - stradp の SFINAE チェックが複雑になっている。
    stradp を private な目的のクラスにすればこのチェックは省略できる。
    stradp を内部使用のクラスにするかどうかについては、
    これについては新しく項目を立てる事にする。

* string: range_replace_enabler の switch を廃止する。
  switch 毎に処理を変えられる様にはしたが実際に処理は同じになっている様だ。

2016-03-02

* string._strtmp_sub_policy: reset_index は問題である

  reset_index することによって外から見た時の index を修正することができる様になったが、
  よく考えてみたら index が内部で使用する為に使われている物だとしたら、
  それを勝手に変更すると元文字列の内部の参照位置も影響を受けてしまう。
  つまり勝手に外部から書き換えて良い物とは限らない筈である。

  幸いに、reset_index を使用しているのは未だ _strtmp_sub_policy のみである。

  [index() の意義]

  修正を行う前に改めて何故 index が必要だったのかについて確認を行う。

  元々は _strtmp_map_policy で現在位置を把握する為に必要であった。
  もしこれだけであるならば _strtmp_map_policy の内部で index を保持すればよい。
  公開する必要はない。しかし、iterator の効率を考えると、
  各操作レベルで独立に index を管理するのは好ましくない。
  例えば、
    a.tolower().toupper().tolower()
  について const_iterator を ++ すると、
  3階層でそれぞれ定義された 3 つの index を increment する事になる。無駄な処理である。
  従って下の階層で index が既に定義されている場合にはそれを流用するという工夫が考えられる。

  では _strtmp_sub_policy の様に index にずれが生じる場合にはどの様にすれば良いのか。
  例えば、

    a.tolower().slice(1,3)

  の様な場合である。

  a この場合には、そもそも slice は index を必要としない。
    従って、_strtmp_sub_policy では has_index な const_iterator を用意しない、
    というのが一つの解である。しかしながら、更に処理を行って

      a.tolower().slice(1,3).tolower()

    等の様にした場合に、結局 index をもう一つ追加することになる。

  b もし slice が下層の index を利用して index を提供していれば、
    最上層の tolower の際に新しい index を提供する必要はなくなる。

    ここで特に、

      第三層::index = 第二層::index = 第一層::index + start

    となるので、最上層の処理で使用する index() は毎回加算 index+start
    を実行することになる。このコストについては留意する。
    一方で第二層が index を用意しなかった場合には、
    このコストが発生しない代わりにもう一つの新しい index を管理し、
    それを increment するコストが発生する。

    一方で、もし 第二層::index を参照しないのであれば、
    (この方法では) 特に特別な処理を行わなくても済むので、
    オーバーヘッドは全くない。

    と思ったが、const_iterator に offset を覚えておかなければならないので、
    それを記録する分だけ const_iterator のサイズが大きくなる。

  これはどちらの方が良いとも言い難い。
  今回は slice 層での index を実装しかけたのであるから、
  取り敢えず b の方針を考えてみる。

* string: class や struct の使用がまちまちである。

  現在の実装では class や struct が入り乱れている。
  取り敢えず、次のように使い分けを行う事にする。

  struct
    - POD な構造体
    - traits, policy などの定義用クラス
    - tag, enabler などのオーバーロード選択用クラス
    - interface

  class
    - 詳細な実装を含むクラス。特にメンバを持つ物

  これに従うと、buffer_type や const_iterator は
  struct ではなくて class であるべきだ。
  現在は大体 struct になっているのでこれらを class に書き換える。

2016-03-01

* string: trim, rtrim で j-1, --j と同じ操作を2回行っている。
  1回だけしか行わないように修正できないか?

  a const_iterator に default constructor を要求する。
    一時変数として jtmp を作って、jtmp=j-1 とする。
    後で j=jtmp とする。

    | const_iterator jtmp;
    | while(j!=i&&_f::invoke(pred,*(jtmp=j-1)))j=jtmp;

    毎回 jtmp -> j にコピーして書き込む作業が必要になる。
    また jtmp=j-1 で新しい領域にコピーする手間もある。
    更に const_iterator たちに default constructor を用意する必要もある。

  b 一時変数として const_iterator jtmp(j); とする。
    *--j 後に戻す必要が有れば j=jtmp とする。

    | while(j!=i){
    |   const_iterator jtmp(j);
    |   if(!_f::invoke(pred,*--j)){j=jtmp;break;}
    | }

    毎回コピー構築を行う。最後に一回だけ戻す。

  c そもそも一時変数に覚えて置かなくても、必要になった時に再計算すれば良い

    | while(j!=i)if(!_f::invoke(pred,*--j)){++j;break;}

    increment に関してはどの文字コードでもコストは小さいと思われる。
    毎回コピーをしなくて済むので嬉しい。実装も簡潔である。

2016-02-23

* [2011-10-26] mwg::string 構成

  mwg::string_impl1::stringbase<XCH,Alloc>
    全ての文字列クラスの基底クラス。
    基本的な非破壊的操作関数を備える。

  mwg::string_impl1::string<XCH>
    固定文字列。データを他の文字列と共有しうる。

  mwg::string_impl1::strsub<XCH>
    他の文字列、データに対する部分文字列を表現するクラス。

  mwg::string_impl1::stradp<XCH>
    アダプタ。実質的に strsub と等価。
    唯一違う点は様々なクラスインスタンスから implicit に構築できる事。
    文字列の類を受け取る関数の引数の型などに用いるのが目的。

  mwg::string_impl1::strbuff<XCH>
    編集用の文字列。参照の複製はされない。

  mwg::string_impl1::strsymb<XCH>
    インスタンスの単一性を保証するクラス
    等値比較が、ポインタを比較するだけで済むので楽。
    比較的長い文字列で同じ物が沢山現れる場合にはメモリの節約にもなるかも。

    クラス名に関しては一考の余地有り。
    ruby では symbol と呼ばれている物である。

  mwg::string_impl1::strsymb_dictionary<XCH>
    strsymb の親クラス。
    存在しているインスタンス全てをこの中に保持して管理する。
    デフォルトでグローバルに使用できるインスタンスを生成するが、
    ローカルに使いたいシンボル群を管理する為に、自分でインスタンスを生成する事も可能にする。

    内部構造は取り敢えず std::map (sorted list) で二分探索。
    将来的には trie を考えても OK

  mwg::string_impl1::strpath<XCH>
    ファイル名を管理する為の文字列

* [2011-10-26] mwg::string 実装方法

  現在の試行実装について。

    以前に少しだけ試しに実装してみて放置してあるコードについて再度整理してみる。
    先ず、この実装では各文字列クラスは基底クラス strbase から派生する。
    strbase では c_str 関数及び length 関数を抽象関数とする。
    そして c_str 及び length の戻り値に対して様々な操作を提供する。
    これによって各派生クラスは c_str 及び length 関数の実装だけに注力すれば良い事になる。
    様々な文字列に対する操作は基底クラスである strbase のレベルで提供されているからである。

    特に strbase に必要な c_str 及び length は、
    仮想関数の仕組みではなくてテンプレートによる特殊化によって実装する。
    strbase の第一テンプレート引数は単体の文字の型 (char や wchar_t など) であり、
    strbase の第二テンプレート引数が各特殊化の詳細を決める traits
    (c_str や length の実装を含む) となっている。

  c_str 関数について

    c_str という関数名は std::string の時と同様に null 終端文字列を返す事を想定させる。
    この関数の戻り値は const char* であり、それをそのまま C の通常の文字列処理の関数に渡す事ができるという事である。
    しかし、クラスによっては const char* を構築するのが容易でない場合がある。
    例えば部分文字列 strsub の場合には、既に存在している文字列の一部分を保持する物である。
    その参照先は一般に null 終端であるとは限らない。
    既に存在している文字列を勝手に書き換える事は出来ないから、
    c_str の戻り値として適切な文字列を用意する為には、
    新しく領域を確保してそこに参照先の内容をコピーして返す必要がある。
    他にも concat_string など temporary object として用意する文字列クラスでも、
    一々メモリを確保して連続メモリとして c_str の結果を用意する訳にはいかない。
    元々、concat_string などの temporary object を生成するのは、
    そういったメモリの確保を省略して、最終結果を構築する時までメモリの確保を遅延させる為である。
    この目的を達成する為に必要なのは、文字列の任意の位置の文字を取得する事であり、
    c_str 及び length 関数ではない。

    つまり必要なのは

    | interface{
    |   const char* c_str() const;
    |   std::size_t length() const;
    | }

    ではなく、

    | interface{
    |   [必須]
    |   char get_ch(int index) const;
    |   std::size_t length() const;
    | }

    である。API として c_str 等の関数が欲しいと思う事もあると思うが、
    それを用意するのは各種特殊化されたクラスの中ではなく、
    共通処理を提供する strbase の方である。

  以下特殊化の時のインターフェイスについて考察。

    | interface{
    |   [必須]
    |   char get_ch(int index) const;
    |   std::size_t length() const;
    |
    |   // c_str
    |   [必須] static const bool has_c_str;
    |   [選択] const char* c_str() const;
    |   /* 既定では get_ch の返す文字を反映して新しい文字列を構築して返す。
    |    * 直接 C 言語で使う事の出来る文字列バッファを内部に持っている場合には
    |    * わざわざコピーをしなくてもそのバッファのポインタを返せばよい。
    |    */
    |
    |   //---------------------------------------------------------------------------
    |   // 文字列比較?
    |   [選択]
    |   const_iterator begin(int index=0) const;
    |   /* これは順番に文字列を辿りながら処理をする時に必要である。
    |    * 例えば比較演算などの場合。
    |    * 例えば concat_string の場合、毎回 get_ch を用いて文字を読み出すと、
    |    * 毎回文字がどの部分文字列にいるかを判定する必要があるが、
    |    * 連続に文字を触る事が分かっていればそれらの判定を省略できる可能性がある。
    |    */
    |
    |   //---------------------------------------------------------------------------
    |   // 文字列比較?
    |   [選択 (既定の実装を提供)]
    |   void read(char* buff,std::size_t startIndex,std::size_t readLength) const;
    |   /* この関数は効率的にデータをコピーする為に必要である。
    |    * 例えば、或る程度長い文字列をコピーする場合には、
    |    * for ループで位置を回しながら get_ch を使って文字を読み出すより、
    |    * CPU の string 命令でデータをコピーしてしまった方が良い。
    |    *
    |    * そう言った処理ができない文字列の場合には、
    |    * 単に内部で for()get_ch のループを回せばよい。
    |    * この既定の動作は既定で準備しておいて、必要に応じて override する形が良い。
    |    */
    | }

    因みに。何故初めの実装で c_str/length というインターフェイスにしたか。
    →これは、既存ライブラリの文字列クラスが多くの場合、連続した領域に文字列を持っているからである。
    つまり c_str/length というインターフェイスを採用しておけば、
    他の既存ライブラリの文字列と簡単に共存できると考えたからである。
    しかし、concat_string 等を用いて文字列処理を高速化しようと考えたのにこれでは意味がなかった。

  まとめ

    次の実装では特殊化で提供するのは基本的に
      get_ch と length,
      必要に応じて iterator や read 関数を実装、
    という形にする。

  実装の形態についてより詳しく

    a. strbase から各クラスに派生
      + strbase の機能を拡張する形で文字列クラスを作成
      + 一番自然に思い付く方法
      + ○特別なコンストラクタの定義が容易
    b. strbase のテンプレート引数で詳細を指定。
      + strbase が実際の実装になる。
      + 実装する上でテンプレート引数に指定した情報を用いる。
      + std::basic_stream と std::streambuf の関係に近い。
    c. strbase の基底クラスとして使用
      + 拡張の関数などは基底クラスから使う。
      + ×strbase と同じ関数名で overload を作ろうと思っても隠蔽されてしまう
        + strbase を書き換えて using を使えば良さそうな気もするが、
        + 一つ一つの派生クラスに応じて using を追加していくのはありえない。
      + ×特別なコンストラクタの定義が難しい

  結局上記の物を組み合わせるのが一番現実的である様に思う。

* [2011-10-26] mwg::string 実装2

  namespace mwg::string_detail2 内に試験的に実装。

  > stradp
  > 比較
    > 関係演算子
    - starts_with(str)
    - ends_with(str)
    - starts_with(pat)
    - ends_with(pat)
    - match(pat)
    - match(pat)
  - 文字置換
    - replace(char_type, char_type)
    - tolower
    - toupper

* [2012-11-13] mwg::string 実装3

  関数名や構成などを考え直して再度実装する。

2015-10-19

* tuple vc10bug

  例によって vc2010 で tuple のコンパイルが通らない。

  > 先ず左辺値参照の場合でも変な所で一時オブジェクトが新しく作成されてしまう様なのでポインタに変換して保持
    (lvalue_reference_wrapper) する事にした。

    % そもそも何故 vc で左辺値も lvalue_reference_wrapper を使って実装する様に変更したのか?
    % →これは右辺値参照の時と同様に以下のエラーが出たからである。
    %   reference member is initialized to a temporary that doesn't persist after the constructor exits
    %   例えば const int& を int& で初期化すると新しい一時オブジェクトが生成されて
    %   その一時オブジェクトに対するポインタが代入されてしまう。

  > 特殊化の選択に失敗する。仕方がないので default template parameter についても特殊化で明示的に指定する。

  これでコンパイルが通る様になったが依然として結果が変である。

  > std::move が怪しい? → ここは問題なかった。

    stdm::move の中でキャストを実行しているが CV をつけたり型を変更したりといった事は何もしていないので
    一時オブジェクトが勝手に作られてしまうという事がないようである。

  どうも _get の中でアドレスが変化している様子である。どうやら

    (value_type&&)(複雑な式)

  の形でキャストすると (複雑な式) の型が value_type& であったとしても一時オブジェクトが生成される様である。
  一旦変数に代入してからキャストすれば問題ないようだ。

    value_type& ref=複雑な式;
    static_cast<value_type&&>(ref) // OK

2015-10-15

* tuple 再設計

  やはり tuple の default constructor がないのは問題である。
  is_default_constructible を使って default constructor を on/off したい。
  しかし単純な SFINAE を使う事は出来ないので構造を変える必要がある。

  構造を変える必要があるのでそれに応じて get<>() も再実装する必要がある。
  再実装しなければならない物について整理を行う。
  基本的には m_valueK を参照している箇所を書き換えれば良いはずである。
  - tuple 本体は勿論完全に書き直す。
  - get<>() は書き換える必要がある。
  - 他には m_valueK を参照している箇所はない。
  意外と compact な変更で良さそうである。

  さて default constructor をどの様に switch で実現するのか?
  これが普通のメンバ関数であれば、tuple を tuple_impl から派生する事にして、
  tuple_impl に余分なテンプレートパラメータ IsDefaultConstructible を用意する事で実現できる。
  しかしながら、default constructor の場合は基本クラスに用意しても仕方がない。
  一番最後のクラスに用意する必要がある。
  結局、tuple 自体に新しいテンプレートパラメータ bool IsDefaultConstructible を用意するしかないのか?

  > 1 get_head, get_rest を作る。
  >   1.1 戻り値の型の決定
  >     これは今迄の実装に用いた物をできるだけ流用する。
  >   1.2 実装
  >     これは単に static_cast を行うだけで良いだろう。
  >
  >   疑問点: 本当に get_head, get_rest は必要なのか?
  >     実はそのままアクセスするだけで良いような気がする…。
  >     というか、元々その様になる様に get の戻り値が設計されたのではないか?
  >
  >     get_head/get_rest の特殊化を作成する事で他の型からも初期化できるようになるとも考えたが、
  >     他の型について必ずしも get_rest に対応する物を正しく実装できるか分からない。
  >     結局個別の実装になってしまうのだとしたら、直接 m_head, m_rest を触っても問題ないのではないだろうか。
  >
  >   →取り敢えず廃止する事にした。
  >
  > 2 取り敢えずは今迄にあった機能だけを追実装する。
  >   > 1.1 多分取り敢えずは実装完了した。
  >   1.2 tuple<T> と tuple<T,U...> で似たコードが二つになっているので統合する。
  >
  > 3 get を実装する。
  > 4 従来の tuple を置き換える
  >   これは意外とすんなりとできた。問題は殆ど置きていない。

  今迄 default constructor がないことによって省略していたテストも通る様になった。
  しかし今迄に気付いていなかった問題点も浮上した。C++03 において
    template<typename T> void f(T mwg_forward_rvalue arg){}
  が完全転送の代替になっていないという事である。mwg_forward_rvalue は const & に展開される。

  const & は左辺値も右辺値も受け取ることができる。C++11 で move を特別扱いし C++03 では単純に値として使いたいときに使える。
  しかし左辺値性および右辺値性を保持して完全転送をしたい場合には使えない。

  この問題点については当初 mwg_forward_rvalue を実装したときには気付いていたが
  その後ですっかり忘れていたという様な気がする。
  というか思い出した。一つの実装でどちらも受け取れるということは左辺値ならではの処理はしないはずだから、
  左辺値を左辺値として受け取る必要はないと判断したように思う。
  しかしこの考え方は誤っている。転送するということは転送先の overload を正しく選択するということである。
  当然左辺値参照の overload と(右辺値参照の代替としての)const参照の overload を両方正しく処理できる必要がある。

  左辺値と右辺値を区別して転送するには結局 T& と T const& の両方について overload する必要がある。
  しかし転送対象の引数の数が増えてくると overload の数が爆発的に増えるので現実的でない。
  何らかの工夫が必要である。改めて可能性を洗う。template の overload resolution で T を推論させる必要があるので、
  引数の型はかなり絞られる。T, T const, T&, T const& 程度しか考えられない。
  あらゆる物から変換可能な型を用意して type erasure すれば動的に受け取った型を区別できるが、
  静的な overload の選択ができなくなる。というか、引数一つ受け取るのに virtual なオブジェクトを構築するのもおかしい。
  区別は書き換え可能 (T&) と書き換え不可能 (T const&, T const, T) の二種類である。
  今したいのは一つの定義で全てを受け取りつつ上記を区別することである。
  T& と T const& を overload として用意すれば丁度両者を区別できる。
  例えば T& だけを用意すると T& と T const& はまとめて受け取れて区別できるが T, T const を受け取れない。
  或いは T だけを用意すると全て受け取れるが区別できない上に参照渡しではなくコピーが発生し極めて効率が悪い。

2015-09-22

* mwg/xprintf.h: VC10 のバグを回避する様にしたら今度は gcc-3.4.6 で通らなくなった。

  配列の参照を変数なしに配列の参照に変換できない (実際何も変換しないはずなのだが)。不思議だ。

  参照: /note/20150923.gcc3bug.array_pointer_dereference.cpp

  &pre(!cpp){
  // gcc-3 で以下がコンパイルできない
  // a.cpp: In function `const char (& f1(const char (*)[2]))[2]':
  // a.cpp:5: error: invalid initialization of non-const reference of type 'const char (&)[2]' from a temporary of type 'const char*'
  typedef const char (&return_type)[2];
  return_type f1(const char (*p)[2]){
    return return_type(*p);
  }

  // 以下はコンパイルできる
  return_type f2(const char (*p)[2]){
    return_type ret(*p);
    return ret;
  }
  }

  色々試したがなかなかうまく行かない。
  &pre(!cpp,title=うまく行かなかったコード){
  #if defined(MWGCONF_GCC_VER)&&(MWGCONF_GCC_VER<40000)
    // gcc-3 では &配列 とすると配列へのポインタではなく
    // 先頭要素へのポインタになってしまう?
    // 結果として (value_type*)(&t.m_valueK) に失敗する。
    //
    // 本当か? 本当に (value_type*) で失敗しているのか? 実は R() に失敗しているのではないか?
    template<typename T>
    struct array_reference_wrapper{};
    template<typename T,std::size_t N>
    struct array_reference_wrapper<T[N]>{
      T* data;
      array_reference_wrapper(T* _data):data(_data){}
      T (*operator&() const)[N]{return reinterpret_cast<T(*)[N]>(data);}
    };
    template<typename T,std::size_t N>
    struct element_traits<T(&)[N]>{
      typedef array_reference_wrapper<T[N]> stored_type;
    };
  #endif
  }
  &pre(!cpp,title=うまく行かなかったコード2){
  template<typename T>
  struct element_traits{
    typedef T stored_type;
    template<typename R,typename Store>
    static R ref(Store mwg_forward_rvalue store){
      typedef typename remove_reference<R>::type value_type;
      return R(*(value_type*)&store);
    }
  }
  template<typename R,typename TT>
  struct tuple_get_impl<K,R,TT>{
    static R _get(TT t){
      typedef typename stdm::remove_cv<typename stdm::remove_reference<TT>::type>::type tuple_type;
      typedef tuple_detail::element_traits<typename tuple_element<K,tuple_type>::type> traits;
      return traits::template ref<R>(t.m_valueK);
    }
  };
  }

  VC 対応の為に拡張したコードを、古い拡張性のないコードに戻したら通る。
  仕方がないので VC 対応の為に拡張したコードは VC のみで使う事にする。

* mwg/xprintf.h, mwg/std/tuple: VC 2010 のバグで tuple が動かないので tuple を修正する事にする。

  tuple に右辺値参照を記録すると勝手に一時オブジェクトに複製されて、
  その一時オブジェクトに対する参照にすりかえられてしまう。
  →仕様がないので tuple で右辺値参照を記録する時はポインタに変換して記録する事にした。

  それでも未だ動作がおかしい。タイミングによって勝手にコピーされたりされなかったりする。
  →良く分からないが int&& の変数を int const&& に変換する等と言った操作の際に、
    新しく局所的に一時変数を作成してそれへのポインタを返している様に見える。
    これをポインタに変換してから返す様にしたら引数が一個の場合には問題なく動くようになった。

  しかし引数が複数ある場合には未だ動かない。
  引数が一個しかない場合にはちゃんと元々のポインタの値が保持されているが、
  引数が四個の場合を見てみると変な所をポインタが指しているという事が分かった。
  % →どうやらこれは tuple の move constructor でメンバ毎に get(move(rhs)) して渡しているのが行けなかった様だ。
  %   単純な get にしたところ何も起こらない様だ。しかしそれで良いのかというのはまた疑問である。
  %   例えばこの様に成っている場合 tuple<int&> で tuple<int&&> を初期化できてしまうのではないだろうか。
  %   或いは tuple<int&&> で tuple<int&&> を move construct する事ができない。
  やはり関係ない。単純に (get(rhs)) にしても同様に問題は発生している。
  というか印刷して試してみた所そもそも move constructor や copy constructor は呼び出されていない。
  (テストの為に一旦変数に代入した時に move/copy constructor が呼ばれただけの様だ。)

  forward_as_tuple で受け取った引数は大丈夫である。
  forward_as_tuple の戻り値で駄目である。
  次に forward_as_tuple 内で tuple<...> を構築するが、
  その tuple コンストラクタが受け取った値は誤っている様だ。
  forward に失敗しているという事だろうか。
  戻り値としてではなく、一旦変数として構築する場合にはコンストラクタには正しい値が渡される。

  うーん。return 式の中で構築すると駄目なのだろうか??
  →return 上で構築するのを止めるだけで期待通りに動いている。
    何故この様な事になるのか分からないが取り敢えず動いているので良しとする。
  →結局変数を伴わないコンストラクタ呼出の内、引数が二つ以上ある物で再現する様だ。

  ○参考: note/20150922.vcbug.rvalue_member_cannot_be_initialized_properly.cpp

  以下 (上からの引用) の4パターンのそれぞれで右辺値参照がずれる事が確認された:

  > - 変数に bind するとアドレスが変化する。
  > - reinterpret_cast<T&&>() するとアドレスが変化する。
  > - 右辺値参照メンバを初期化するとアドレスが変化する。
  > - (1) 複数の引数を持つ (2) コンストラクタを (3) 変数を伴わない部分式から 呼び出すと引数のアドレスが変化する。

* mcxx msc install cxxar を張り間違えている。

* mwg/xprintf.h: テンプレート明示的実体化

  今迄使っていた実体化が VC2010 のバグでエラーになって動かないので、
  改めて整理して使いやすくすることを試みる。
  クラスを通じて間接的に呼び出したりする事で、一度に複数のクラスの実体化をできるのではないかと
  思ったがなかなかうまく行かない。結局の所、手で指定した物しか実体化は保証されず、
  そこから呼び出される別の関数や別のクラスについては実体化されるかもしれないという程度の気がする。
  幸いクラスのメンバ関数だけはまとめて実体化する事が可能であるので、これを用いて実装し直す事にする。

  以下は試行錯誤の末に書いて消した物である。

  % template<typename Buff>
  % struct _instantiate_basic_convert{
  %   static void _call(Buff& buff,fmtspec const& spec){
  %     //
  %     // ここで呼び出すだけで本当にインスタンス化されるのだろうか?
  %     //
  %     // - 各関数の定義は既に与えられているので実体化可能である。
  %     //   またテンプレート関数が別の翻訳単位で実体化されるかどうか何も仮定できないので、
  %     //   ここで実体化しないと最終的にリンク時に失敗する事になる。
  %     //   従って、ここで必ず実体化されるはずである。
  %     //
  %     // - 但し、インライン化されてシンボルが割り当てられない可能性もある?
  %     //
  %     basic_convert_impl<Buff>::convert_integer(buff,spec,mwg::u8t(),bool(),int());
  %     basic_convert_impl<Buff>::convert_floating_point(buff,spec,double());
  %     basic_convert_impl<Buff>::convert_string(buff,spec,"",std::size_t());
  %   }
  % };
  %
  % // 以下どの様な条件で実体化されるか不明
  %
  % template<template<typename Buff> class InstantiateForWriter>
  % struct _instantiate_for_writers:
  %   InstantiateForWriter<xprintf_writer>,
  %   InstantiateForWriter<empty_writer>,
  %   InstantiateForWriter<cfile_writer>,
  %   InstantiateForWriter<ostream_writer>,
  %   InstantiateForWriter<string_writer>{};
  %
  % template<typename T>
  % struct _simple_xprintf_convert{
  %   template<typename Buff>
  %   struct _instantiate{
  %     static void _call(xprintf_writer& buff,fmtspec const& spec,T const& value){
  %       xprintf_convert(buff,spec,value,adl_helper());
  %     }
  %   };
  % };
  %
  % // template class _instantiate_for_writers<_simple_xprintf_convert<T>::_instantiate>;

2015-09-20

* mwg/xprintf.h: bugfix, C++11 で mwg::xputf の戻り値が構築できない。

  戻り値で受け取った tuple をコピーしようとしていたが、
  g++-4.9.2 の C++11 で tuple<int&&> はコピー不可能になる?
  "implicitly deleted because the default definition would be ill-formed"
  等と文句を言って tuple はコピーできない様である。

  仕方がないので tuple を受け取る vxputf に関しては
  Tuple const& で tuple を保持し、
  xputf に関してはその場で tuple を構築する事にして我慢する。

  →参照としてのコピーができる tuple として packed_forward<Args...> を定義した。
  更に、pack_forward 関数を定義して std::forward と同じように呼び出して、
  packed_forward<> を得られる様にした。
  現在の所コンパイルは通っているし期待通りに動いている。

  以下は関連して解決したと見做す。

  > 2015-09-18
  >
  > * mwg/xprintf: mwg::vararg::pack_forward の存在意義に疑問
  >
  >   | pack_forward
  >   |
  >   |   以下のようにして引数を捕まえるのに使う。
  >   |     void func(Args&&... _args){
  >   |       std::tuple<Args&&...> args=pack_forward<Args...>(_args...);
  >   |     }
  >   |   類似のものに std::forward_as_tuple があるがこれは使いづらい。というのも、
  >   |     void func(Args&&... _args){
  >   |       std::tuple<Args&&...> args=std::forward_as_tuple(std::forward<Args>(_args)...);
  >   |     }
  >   |   としなければならないからである。あるいは、pack_forward は
  >   |     std::forward_as_tuple(std::forward<Args>(_args)...)
  >   |   を組み合わせた物と考えれば良い。
  >
  >   上記の記述は本当だろうか? 勿論 forward_as_tuple(...) とはできないけれども、
  >   forward_as_tuple<Types...>() の様な使い方はできるのではないかという気がする。
  >
  >   また、現在の実装で pack_forward<XArgs...,YArgs...>(yargs...) となっているのは、
  >   yargs から xargs に変換できるかどうかのチェックをするためである。
  >   単純な forward_as_tuple の場合はそのチェックがないので面倒なテンプレートのエラーが発生する。
  >   しかし、今回想定している使い方の範囲内では必ず yargs → XArgs に変換出来るはずである。
  >
  >   やはり std::forward_as_tuple で駄目な理由が分からなくなった…。
  >   試しに forward_as_tuple に切り替えて見る。
  >   実際に試してみた所、以下の様になった:
  >
  >   | void func(Args&&... _args){
  >   |   std::forward_as_tuple<Args...>(_args...); // NG: 当然だが int&& arg1; の arg1 は左辺値なので (int&& param1) に渡せない。
  >   |   std::forward_as_tuple<Args...>(std::forward<Args>(_args)...); // OK
  >   |   std::forward_as_tuple(std::forward<Args>(_args)...); // OK: でも上の様に書くぐらいならば下の様に書けば良い。
  >   | }
  >
  >   結局、std::forward_as_tuple(std::forward<Args>(_args)...) と書かなければならないのが面倒だから、
  >   pack_forward という関数を作ったという解釈で良いという事である。
  >   序でに空の forward_as_tuple が許されるのかを確かめる。
  >
  > * mwg/xprintf.h: pack_forward 廃止??

* mwg/xprintf.h: interface について

  現在の interface は以下の関数である:

  - xprintf(target,fmt,args);
  - vxprintf(target,fmt,args);
  - sprintf(fmt,args);
  - vsprintf(fmt,args);

  [問題点] sprintf/vsprintf は std::sprintf/std::vsprintf を隠蔽する。

  つまり mwg 名前空間内では std:: を省略できないこと。
  更に両関数の引数が互いに可換な状況があるので using std::sprintf もできない。

  - ADL が働いて ::sprintf を呼んでいる積もりで
    mwg::sprintf が呼び出されてしまう可能性がある。
    (::sprintf は基本型しか受け取らない筈だが…例えば書き込み先に
    operator char*() をメンバ関数として持つ型を指定する場合など?)

  - 更に namespace mwg 内部で使っているから mwg::sprintf が呼び出されていると
    思っていたら #include <mwg/xprintf.h> を忘れていた所為で
    ::sprintf() の方が呼び出されるという危険性もある。

  - 他の人が使おうとした時にバグを生む可能性がある。
    特に初心者向けの文書での習慣である using namespace
    を使うものだと考えている人は多い。

  常に完全修飾名で指定すれば良いという考え方もあるが、気を抜くと忘れかねない。
  以上の理由から、一般的に std:: 名前空間内部の物と同じ名前は使わない方が良い。

  [計画] 同時に interface も改良したい。

  | 以下の様な使い方ができる様にしたい:
  |
  |   std::cout << mwg::xprintf(fmt,...);
  |   stdout << mwg::xprintf(fmt,...);
  |
  |   std::string line( mwg::xprintf(...) );
  |   line << mwg::xprintf(fmt,...);
  |   ilne = mwg::xprintf(fmt,...);
  |
  |   mwg::xprintf().str()
  |
  | でもこの interface だと出力&出力文字数取得ができない…。
  |
  |   std::tie(std::cout,count) << mwg::xprintf(fmt,...);
  |   if((std::tie(std::cout,count) << mwg::xprintf(fmt,...)).second == 0) ...;
  |
  | だと如何にも煩雑である。といって、
  |
  |   if(mwg::xprintf(fmt,...).write(std::cout) == 0)
  |
  | というのも分かりにくい。やはり従来型の interface も同時に提供するべきだろうか。
  | そうすると mwg::xprintf の関数名は従来型の interface に使用したい。
  | 新しい << による interface の関数名をどうするかが問題になる。
  | 下手に *printf などだと従来型の使い方を想像してしまうかもしれない。
  | といって全然違う関数名にすると printf にするよりは気分的に抵抗が生じる。
  |
  | 或いは、ostream 的に << で使えるという事から関数名を決められないか。
  | → boost::format は元々知っていたが、どうやら std::putf という名前で標準化の
  | 提案が為されている様である。これが標準化されるかどうかはさておきこの真似で
  |
  |   mwg::xputf
  |
  | という関数名で実装するというのが良さそうである。

  以下の interface で作る事にする:

  1 xprintf, vxprintf はそのまま。

    特に std::string に出力する時の文字列は xprintf 側でクリアする様に変更する。
    → create_xprintf_writer の第二引数に指定する様に変更した。

  2 xputf, vxputf という関数を作成して以下の使い方ができる様にする:

    std::cout << mwg::xputf(...);
    stdout << mwg::xputf(...);
    std::string() << mwg::xputf(...);

    →実装した。チェックした。

    std::string(mwg::xputf(...));
    mwg::xputf(...).str();
    mwg::xputf(...).count();

    →実装した。チェックした。

  3 sprintf/vsprintf は削除する。

  gcc のバグやら色々面倒な事はあったがどうやら終わった。

  以下は関連して解決した物である:

  > 2015-09-18
  >
  > * mwg/xprintf.h: mwg::xprintf(std::string); // 追記になっているが sprintf 等を考えると分かりにくい
  > * mwg/xprintf.h: その他の型 ... ostringstream << を用いた実装。


* mwg/xprintf.h (_vxputf_temporary_object): g++-3.4.6 friend が効かない?

  参考: libmwg/note/20150920.g++-3.4.6-bug.copyctor_required_for_cref.cpp

  色々調べた結果、コピーを禁止すると g++-3.4.6 で以下が通らないという事が分かった:

  class A{
    A(A const&){}
  public:
    A(){}
  };
  void proc(A const&){}
  void test(){proc(A());}

  proc は参照として A インスタンスを受け取ろうとしているのに、
  実際にはコピーをしようとして失敗している様子である。
  g++-3.3.6 ではコンパイルが通る。g++-2.95 でもコンパイルが通る。

  仕様がないので適当な gcc の version の範囲で constructor たちを public にする事にした。

* mwg/xprintf.h: experimental から移動

* mwg/std/type_traits

  TR1 Header からの対応がかなり不完全になっている。
  現在では TR1 Header がある場合の実装と、何もない場合の実装を別々に (ファイルの前半と後半に) 記述している。
  各クラスについて TR1 Header があるかどうかで実装を切り替える様にしないと見通しが悪い。
  更に、現在どの機能が実装されていてどの機能が実装されていないのかも分かりにくい。
  これらについても整理しながら実装を行う必要がある。

  →整理を実行した。

2015-09-20 以前

* clang -std=c++0x から GCC 4.4.7 libstdc++ を使った時の問題

  std::move が壊れているために、それを使っている std::swap や std::vector などまでも
  全てエラーに成ってしまうので救いようがない。

  また type_info が前方宣言されていないのに typeinfo の先頭で使おうとしているので
  それでもエラーに成ってしまう。これについては一応 type_info を自分で前方宣言すれば良いが…。

  これはサポートの対象外とすることにする(そもそもヘッダファイルを include しようとするだけで死ぬ)。
  workaround のために書いたコードは削除することにする。以下に残しておく。

  // from mwg/defs.h
  //------------------------------------------------------------------------------
  // clang -std=c++0x: #include <typeinfo> (gcc 4.4.7 libstdc++) がエラーになる。
  // 内部で更に呼び出したヘッダで type_info* を使っているため。
  //?mconf X -t'"std::type_info sane?"' -oMWGCONF_STD_TYPE_INFO_SANE typeinfo 'const std::type_info* ptr=0;'
  #if !defined(MWGCONF_STD_TYPE_INFO_SANE)
  namespace std{
    class type_info;
    class bad_cast;
    class bad_typeid;
  }
  #endif

  // from mwg/std/utlility
  //-----------------------------------------------------------------------------
  // clang -std=c++0x: gcc 4.4.7 libstdc++ bug workaround
  // c.f. http://lists.cs.uiuc.edu/pipermail/cfe-dev/2011-February/013216.html
  //?mconf X -t'"std::move sane?"' -oMWGCONF_STD_MOVE_SANE utlility 'int j=std::move(i)';
  # ifndef MWGCONF_STD_MOVE_SANE
  #  include <type_traits>
  namespace mwg{
  namespace stdm{
    template<typename T>
    T& move(const T& value){return const_cast<T&>(value);}
    template<typename T>
    typename enable_if<!is_const<T>::value,T&>::type
    move(T& value){return value;}

    template<typename T>
    void swap(T& a,T& b){
      T tmp(move(a));
      a=move(b);
      b=move(tmp);
    }
  }
  }
  # endif

2015-04-28

*目標: 新しいビルド管理システム

  > ***ソースコード埋め込み指定
  >
  > 以下に挙げるような様々な機能を\
  > ソースコード中に埋め込んだ指定から呼び出せる様にする。
  > - configure script (mcxx)
  > - document (lwiki)
  > - preprocess (mwg_pp.awk)
  > - check (mwg_pp.awk sub)
  >
  > 処理の手順
  > 1. mwg_pp.awk による処理
  > 2. perl による処理
  >    (lwiki 部分なども mwg_pp.txt によって生成したくなるだろうから)
  >
  > ***出力に関して
  >
  > - 出力は別のディレクトリに対して行う様にしたい
  > - ソースファイル、ヘッダファイルの文字コード変換に対応する。
  >   original の文字コードも選択できる様にする。
  > - コンパイラの種類毎の出力に対応する。
  >   コンパイラのオプション毎の出力にも対応する。
  >   mcxx の機構を使用している場合 CXXFLAGS CFLAGS 等の設定に対応した設定を行うのが難しい。
  >
  > out/src.charset
  > out/cxxprefix.option/obj
  > out/cxxprefix.option/lib
  > out/cxxprefix.option/include
  >
  > ***その他の機能
  > wx-config 的なコマンドで cxxflags 等の必要な設定を呼び出す方法も提供する
  > 簡単なプロジェクトの初期化スクリプトも用意する
  > インストール・アンインストールの対応

  取り敢えず試しに実装を行ってみる。

  このビルド管理システムでは src に置いたソースコードを起点として、
  out ディレクトリに加工したソースコード・オブジェクトファイル・結果ファイルを出力する。

  現在以下のシーケンスが用意されている。

    src/dir/file.cpp

    → mwg_pp.awk による前処理

    out/src.utf-8/dir/file.cpp

    → make_extract.pl による lwiki, mconf の抽出

    out/src.utf-8/dir%file_cpp.lwiki
    out/src.utf-8/dir%file_cpp.mconf


2015-05-15

* 問題点: Makefile 起動が遅い

  -そもそもパス区切に % を用いているのが良くない?
    % はワイルドカードである。パターンマッチングが実行されている。
    →ファイル名中の % を + に変更してみたがそんなに時間は変わらない気がする。

  -原因が分からないので問題になっている Makefile を少しずつ弄って確かめる
   先ずは all に登録されている prerequisites を空にする。
   1.374s → 1.092s まで下がった。依存性の確認に 220ms かかっている事になる。
   次に生成コマンドを全て削除する。1.092 → 1.088 全然変わらない。誤差の範囲内である。
   つまり生成コマンドの登録はゼロコストである。
   今度は hoge+= となっている物を全て削除する。
   1.090s → 0.819s になった。72項目で 0.270ms かかっていた事になる。
   変数の = を := に変えたら旧に滅茶苦茶速くなった…。
   どうやら CPPPREFIX=$(shell $(MWGCXX) +prefix) が登場した回数だけ評価されていた事による様だ…。

  結局、原因は $(shell ) の展開が毎回行われていた事に依る物と分かった。

* 問題点: 各ファイルの config 条件と更新時刻

  現在は config 関係を以下のように処理している。
  1 各ファイルに config の条件を定義してファイルが更新される度にテストを実行する。
  2 全ファイルの結果を一つのファイル mwg_config.h に結合して出力する

  依存関係の問題

  しかしこの様にすると問題なのは、全てのファイルが
  基本的に mwg_config.h を include しているという事である。
  ファイルの依存性はコンパイラオプションの -M で追跡しているので、
  mwg_config.h を更新すれば全てをコンパイルし直す羽目になる。
  つまり、全てのファイルが他の全てのファイルに依存しているという状態になるという事である。

  a 解決方法の一つは、各ファイル毎に config ファイルを生成するという事である。
    しかしこれは煩雑になる。特に最終的な結果として install する場合に沢山の環境依存ヘッダがあるのは気になる。

  b 或いは、設計中は各ファイル毎の config を使うとして install する時にはそれらを結合した物を使うという手もある。
    でも恐らく今迄の自分の使い方だと、最終的に install する段階よりも書きながら使う場合の方が多い。
    できれば普段使っている段階でも config が一つに纏まった状態で取り扱いたい。

  c もう一つの方法は出力する config の内容を記録しておいて内容に変化があった場合にのみ、
    mwg_config.h を更新するという方法である。しかしこの方法も微妙である。
    config 指定さえ弄らなければ全体をコンパイルし直す事にはならないが、
    config 指定を弄った時に結局全体のコンパイルをやり直さなければならなくなる。
    これは従来の autotools でも同じ事であるが、今回はファイル毎に指定できるようにしたので
    config 指定の依存関係が明らかであり、この事を利用して必要な物だけコンパイルする様にしたい。

  d gmake の機能で良さそうな物はないだろうか。
    どうやら A: B | C とすると C の存在だけ確認をしてタイムスタンプの比較は行わない様だ。
    然し乍ら、上記の様にルールを書き換える為には g++ -M で出力した依存性ファイルを書き換える必要がある。
    (例えば sed -i '
      s/\(^\|[[:space:]]\{1,\})mwg_config.h\([[:space:]]\{1,\}\|$\)//
      s/[^\]$/& | mwg_config.h/
    ' x.dep)
    実行するコマンドが増加するので余りこれを採用したくはない。
    また Makefile の記述が複雑になる。特にユーザ側で特別に何か記述したい時に問題になる。
    が取り敢えず第一候補である。

  e touch mwg_config.h
    これで mwg_config.h の日付が更新前と比べて変化しないようにする…。
    余り良い方法ではないかも知れないがコスト的にこれが一番楽である。

* 疑問: Makefile: タイムスタンプを見ない依存関係?

  例えば、A: X としたいが
  - X が存在しない時は X を生成するコマンドを実行し A 更新も行う。
  - X が存在する時はそのファイル時刻に関係なく A 更新は行わない。

  .SECONDARY: X 等とすると
  - A が(X 以外の依存関係に対して)最新で、X が存在しなければ何もしない
  - X が存在する時はそのファイル時刻を見て必要が有れば A 更新を行う
  の様になる。似たような特別ターゲットが存在するのでは? → 探したがない気がする。
  ファイル更新時刻を無視するという機能自体が存在しない様に思われる。

  https://lists.gnu.org/archive/html/help-gnu-utils/2007-08/msg00016.html
  にも似たような質問が投稿されている。
  一つの解決方法は、A 生成の中で X の存在の確認をして X の生成も行うという物。
  もう一つの解決方法は、A の依存関係のリストを X の存在・非存在で切り替わる様に書くという物。
  後者は興味深い方法ではあるが今回の場合には使えない。

  https://lists.gnu.org/archive/html/help-gnu-utils/2006-02/msg00034.html
  に似たような質問が投稿されている。
  order-only prerequisites として登録しろという返答が為されている。
  A: | X
  # # でもこれだと X も要求しなければ X を生成するコマンド自体が実行されないのではないか。。
  # と思ったが、Makefile の解説を読んだ所 X が存在しなければちゃんと X 生成も行われる様だ。
  # 但し、X の生成が行われた後に A の更新は実行されない。。

  まとめ:

  A: | X の場合
  - Xが存在しない場合: X が生成される。Aの更新は要求しない。
  - Xが存在して A よりも新しい場合、A は更新されない。

  .SECONDARY: X
  A: | X の場合
  - Xが存在しない場合: Aが最新でない場合 X を更新してから A を更新する。
  - Xが存在して A よりも新しい場合、何も起きない。

  .SECONDARY: X
  X:
  A: | X の場合
  - Xが存在しない場合: 何もしない
  - Xが存在して A よりも新しい場合、A を更新する。

* Makefile: 複数のファイルを生成するコマンドの管理の方法

  複数のコマンドを生成する場合

  > [[GNU Makefile rule generating a few targets from a single source file - Stack Overflow>http://stackoverflow.com/questions/2973445/gnu-makefile-rule-generating-a-few-targets-from-a-single-source-file]]
  >
  > | B1 B2: A1
  > | 	command B1 B2 < A1
  >
  > 上記の様にするとコマンドが 2 回実行されて無駄である。
  > その上 -j4 などで並列化するとコマンドが同時に起動されて出力が変になる。
  > 以下のようにする解決方法が提示されている。
  >
  > | B1: A1
  > |   command B1 B2 < A1
  > | B2: B1 A1
  >
  > 上の様にしていると、B1 の方が後に生成された場合に毎回 B2 を更新しようとするのでは?
  > と思ったが、実際に試してみると Nothing to be done となる。
  > つまり、更新用のコマンドが設定されていない場合にはファイルが存在する事だけを確認する様だ。
  >
  > また、A1 が更新された時に B2 が更新されないのではないかという懸念がある。
  > →試してみたら更新されないではないか。。
  > というか B1 A1 が存在しているだけで B2 も完了している様に見受けられる。
  > つまりこの方法は B1 が最新版であれば必ず B2 も最新版である事が保証されている場合にのみ有効である。
  >

  もっと複雑な場合はどうするか?

  現在の状況は以下の様な物である。
  - B1 も B2 も同時に生成される。
  - B1 は環境変数依存のファイル名である。B2 は環境変数に依存しない。
  - 環境変数が変化した時に B2 は既に最新版だが、B1 は未だ生成されていない(or最新版でない)という状況がある。
  - B2 に依存するルールが大量にあるのでできるだけ B2 は更新したくない。

  更新が発生するのは以下の状況のどちらかである。
  +環境変数が変更された事により B1 の更新が必要になる。
  +A1 が変更された事により B1 と B2 の両方の更新が必要になる。

  何れにしても B1 は必ず更新されるのであるから、今回の場合には
  | B2: B1
  等としておけば良いのではないだろうか。そして B1 のルールの方では
  | B1: A1
  |   command B1 B2.tmp < A1
  |   [[ B2 -nt A1 ]] || mv B2.tmp B1.tmp
  等のようにする。

  # B1: A1
  #   command B1 /dev/null < A1
  # B2: A1
  #   command /dev/null B2 < A1
  #
  # B1: A1
  #   command B1.tmp B2.tmp < A1
  #   [[ B1 -nt A1 ]] || mv B1.tmp B1
  #   -rm -rf B1.tmp B2.tmp
  # B2: A1
  #   command B1.tmp B2.tmp < A1
  #   [[ B2 -nt A1 ]] || mv B2.tmp B2
  #   -rm -rf B1.tmp B2.tmp

2011-09 頃

* mwg.functor 過去ログ (転記: 2016-04-04)

  2011-01-23 頃の mwg.functor の古い記録をここに残しておく。

  -rw-r--r--  1 murase murase  20131 2011-09-19 05:13:52 functor.hist.htm
  -rw-r--r--  1 murase murase   9290 2011-01-23 08:48:36 functor.memo2.txt

  > *<mwg/functor.h> 履歴
  > **mwg/functor.h 概要
  > ***何をする為の物か
  > このヘッダは「関数として扱う事のできる型」を統一的に扱う為の物である。
  >
  > -{関数オブジェクトのラッパクラス:
  >
  > 特定のシグニチャを持つ関数を一つの型 `mwg::functor<R(A...)>` で受け取る事ができる。
  >
  > 関数オブジェクトは二種類あって、それは `mwg::functor<R(A...)>` と `mwg::functor_ref<R(A...)>` である。\
  > 前者は初期化に使用した関数オブジェクトを値としてコピーして内部に持つ。\
  > 後者は名前から想像が付く様に、初期化に使用した関数オブジェクトの参照を保持する。\
  > 副作用 (関数を呼び出す事によって生じる関数オブジェクト内の変化) は\
  > `functor_ref` の場合、他の `functor_ref` インスタンスにも影響を与えるが、\
  > functor の場合、他の functor インスタンスには影響を与えない。\
  > 但し、関数ポインタなど内部状態を持ち得ない関数オブジェクトに関しては両者に基本的な違いはない。
  >
  > この関数オブジェクトは、引数の反変性・戻り値の共変性に対応する。つまり、\
  > `functor<void(int,int)>` に `void(double)` の関数ポインタを代入出来るし、\
  > また、`bool(int,int)` の関数ポインタを代入する事もできる。\
  > いざ呼出が実行される場合には、\
  > 前者 `void(double)` の場合は第一引数が double に変換され第二引数は単純に無視される。\
  > 後者 `bool(int,int)` の場合は引数はそのままだが関数の戻り値は単に無視される。\
  > 但し、シグニチャの変換を伴う場合は安全の為に、\
  > 明示的に functor へのキャスト・コンストラクタ呼出を書く事を要求している。
  >
  > &pre(!cpp){
  > void test1(double a){
  >   std::printf("test1: %lf\n",a);
  > }
  > bool test2(int a,int b){
  >   std::printf("test2: %d %d\n",a,b);
  > }
  >
  > mwg::functor<void(int,int)> f1=&test1;
  > f1(0,1);
  > f1(2,3);
  > f1(4,5);
  > mwg::functor<void(int,int)> f2=&test2;
  > f2(6,7);
  > f2(8,9);
  > f2(10,12);
  > }}
  > -{関数オブジェクトの判定:
  >
  > 関数オブジェクトの型を指定して、\
  > それが特定のシグニチャの関数オブジェクトに変換可能かどうかを判定するクラスを提供する。\
  > これにより、SFINAE を用いて関数オブジェクトの種類によって処理を変更する事が可能になる。\
  > 厳密にシグニチャが一致しているかどうかの判定には\
  > `mwg::is_functor<関数オブジェクト型,シグニチャ>` を用いる。\
  > 共変性と反変性を許容する場合に変換可能かどうかを判定するには、\
  > `mwg::be_functor<関数オブジェクト型,シグニチャ>` を用いる。
  >
  > &pre(!cpp){
  > template<typename F>
  > typename std::enable_if<
  >   mwg::be_functor<F,bool(std::string,double)>::value,void
  > >::type foreach_key_value(F&);
  >
  > template<typename F>
  > typename std::enable_if<
  >   !mwg::be_functor<F,bool(std::string,double)>::value
  >   &&mwg::be_functor<F,void(std::string,double)>::value,void
  > >::type foreach_key_value(F&);
  > }}
  > -{関数オブジェクトの静的かつ汎用的な呼出:
  >
  > `mwg::functor` (関数オブジェクトラッパクラス) の実装では型消去を行う為に、仮想関数を利用している。\
  > しかし、その場で関数オブジェクトを実行し以降使わない場合には、\
  > わざわざラッパインスタンスを生成し仮想関数呼出で関数を実行する必要はない。\
  > その様なコードをテンプレートで一括に定義できるように、補助関数 invoke を提供している。
  >
  > &pre(!cpp){
  > template&lt;typename F&gt;
  > typename std::enable_if&lt;
  >   mwg::be_functor&lt;F,bool(const std::string&amp;,double)&gt;::value,void
  > &gt;::type foreach_key_value(F&amp; f){
  >   for(std::vector&lt;std::string&gt;::iterator i=list.begin();i!=list.end();++i){
  >     typedef mwg::functor_traits&lt;F,bool(const std::string&amp;,double)&gt; traits_type;
  >     if(!traits_type::invoke(f,*i,atof(i-&gt;c_str())))break;
  >   }
  > }
  >
  > template&lt;typename F&gt;
  > typename std::enable_if&lt;
  >   !mwg::be_functor&lt;F,bool(const std::string&amp;,double)&gt;::value
  >   &amp;&amp;mwg::be_functor&lt;F,void(const std::string&amp;,double)&gt;::value,void
  > &gt;::type foreach_key_value(F&amp; f){
  >   for(std::vector&lt;std::string&gt;::iterator i=list.begin();i!=list.end();++i){
  >     typedef mwg::functor_traits&lt;F,bool(const std::string&amp;,double)&gt; traits_type;
  >     traits_type::invoke(f,*i,atof(i-&gt;c_str()));
  >   }
  > }
  > }}
  >
  > ***対応済関数オブジェクト
  >
  > 以下に挙げるのは、関数オブジェクトとして取り扱う事のできる物の一覧である
  >
  > -関数型・関数ポインタ
  >  -`R(A1,…,An)`
  >  -`R(A1,…,An,...)`
  >  -`R(*)(A1,…,An)`
  >  -`R(*)(A1,…,An,...)`
  >  可変長引数型は、具体的な引数の型を指定して使用。
  > -メンバポインタ
  >  -`T C::*`
  >  `T&(C&)` または `const T&(const C&)` として使用
  > -メンバ関数
  >  -`R(C::*)(A1,…,An)`
  >  -`R(C::*)(A1,…,An) const`
  > -インスタンス＋メンバ関数 [未実装]</li>
  > -関数オブジェクト
  >  -`F` with `R F::operator()(A1,…,An)`
  >  -`F` with `R F::operator()(A1,…,An) const`
  > -関数オブジェクトへのポインタ
  >  -`P` with `F& operator*() const; R F::operator()(A1,…,An)`
  >  -`P` with `F& operator*() const; R F::operator()(A1,…,An) const`
  >
  > 関数オブジェクトとして使用する事のできる型を増やす為には、\
  > `functor_traits` の特殊化を記述すればよい。\
  > `functor_traits` は、\
  > それが関数オブジェクトかどうかの情報を持ち、\
  > 関数オブジェクトである場合には引数の数や型・戻り値の型などのシグニチャ情報を提供する。\
  > 更に、関数オブジェクトとしての呼出を実行する為の関数も提供する。\
  > また、`functor_ref`/`functor` に格納するデータの定義を `ref_tr`/`ins_tr` で与える。\
  > `ref_tr`/`ins_tr` は多くの場合 `functor_case_traits<F>` の特殊化として実装すれば良い。\
  > `ret_tr`/`ins_tr` は格納するデータの形式と関数オブジェクト型の間の相互変換を提供する。
  >
  > &pre(!cpp){
  > namespace mwg{
  >
  > struct functor_traits<F1>{
  >   typedef F1 fct_t;
  >   static const bool is_functor=true;
  >   static const int arity=5;
  >   static const bool has_varargs=false;
  >
  >   // シグニチャ型
  >   typedef hoge ret_t;
  >   typedef hoge sgn_t;
  >   typedef hoge arg1_t;
  >   typedef hoge arg2_t;
  >   typedef hoge arg3_t;
  >   ...
  >
  >   typedef hoge ref_tr; // functor への参照を保持
  >   typedef hoge ins_tr; // functor の複製インスタンスを保持
  >   static ret_t invoke(const fct_t& f,...);
  > };
  >
  > struct functor_case_traits<F1>{
  >   typedef F1 fct_t;
  >   typedef functor_traits<F1> fct_tr;
  >   typedef fct_t case_data;
  >   static const fct_t& endata(const fct_t& f){return f;}
  >   static const fct_t& dedata(const fct_t& f){return f;}
  > };
  >
  > }
  > }
  >
  > これらの実装の為に使用出来る補助クラスが色々定義されている。詳しくはそれぞれの実装を見よ。
  >
  > -`mwg::functor_detail::functor_traits_signature`
  > -`mwg::functor_detail::functor_traits_impl`
  >
  > ----
  > **mwg.functor.ftypes - 2011.01.22
  >
  > 似た様なシグニチャの取り扱いをしているのに、\
  > 別々に arities で一括生成している部分があり、\
  > 管理がしにくいので統一的に扱う方法を考える。
  >
  > 型からのシグニチャの抽出を別のクラスにする。\
  > 今迄は、この機能は functor_traits が担う物と考えていたが、\
  > functor_traits の役割が多く、また、functor_traits 自体に似た様な色々の版を作らなければ行けなくなった。\
  > 従って、型からのシグニチャなどの汎用的な操作については、もっと単純なそれに特化したクラスを作成した方が良いと考える。
  >
  > 汎用的な型に対する操作のクラスは、mwg,functor.ftypes.inl に纏めた。
  >
  > ***[traits.functor]
  > &pre(!cpp,!diff) <<<EOF
  >  #ifdef _MSC_VER /* VCBUG */
  > +  template<typename F,typename S>
  > +  struct functor_invoker_functor{};
  > -  template<typename Mfp>
  > -  struct functor_traits_ftorF{};
  >    template<typename P,typename Mfp>
  >    struct functor_traits_ftorP{};
  >  #endif
  > #-------------------------------------------------------------------------------
  > # ↓ 汎用性が低いので少し書き換えてみる事に
  > -#%define 1
  > -  template<typename R,typename C %typenames%>
  > -  struct functor_traits_ftorF<R(C::*)(%types%)>
  > -    :functor_traits_impl<R(%types%),C,functor_case_traits_FunctorRef<C> >
  > -    ,functor_invoker_functor<C,R(%types%)>
  > -  {};
  > -  template<typename R,typename C %typenames%>
  > -  struct functor_traits_ftorF<R(C::*)(%types%) const>
  > -    :functor_traits_ftorF<R(C::*)(%types%)>{};
  > -#%define end
  > -#%expand mwg::functor::arities
  > #-------------------------------------------------------------------------------
  > +#%define 1
  > +  template<typename R,typename C %typenames%>
  > +  struct functor_invoker_functor<C,R(%types%)>{
  > +    static R invoke(const C& f %s_params%,...){
  > +      return R(const_cast<C&>(f)(%args%));
  > +    }
  > +  };
  > +#%define end
  > +#%expand mwg::functor::arities
  > #-------------------------------------------------------------------------------
  > # ↓ これだと何故か VC で動かない
  > -  template<typename C,typename S>
  > -  struct functor_traits_ftorF<S C::*>
  > -    :functor_traits_impl<S,C,functor_case_traits_FunctorRef<C> >
  > -    ,functor_invoker_functor<C,S>
  > -  {};
  > -#%define 1
  > -  template<typename R,typename C %typenames%>
  > -  struct functor_traits_ftorF<R(C::*)(%types%) const>
  > -    :functor_traits_ftorF<R(C::*)(%types%)>{};
  > -#%define end
  > -#%expand mwg::functor::arities
  > #-------------------------------------------------------------------------------
  > +  template<typename Mfp>
  > +  struct signature_mfp{
  > +    typedef void sgn;
  > +    typedef void obj;
  > +    typedef void sgn_t;
  > +  };
  > +#%define 1
  > +  template<typename R,typename C %typenames%>
  > +  struct signature_mfp<R(C::*)(%types%)>{
  > +    typedef C obj;
  > +    typedef R(sgn)(%types%);
  > +    typedef R(sgn_t)(C& $".sep_for|K|1|%AR%+1|AK|,");
  > +  };
  > +  template<typename R,typename C %typenames%>
  > +  struct signature_mfp<R(C::*)(%types%) const>{
  > +    typedef const C obj;
  > +    typedef R(sgn)(%types%);
  > +    typedef R(sgn_t)(const C& $".sep_for|K|1|%AR%+1|AK|,");
  > +  };
  > +#%define end
  > +#%expand mwg::functor::arities
  > +  template<typename Mfp>
  > +  struct functor_traits_ftorF
  > +    :functor_traits_impl<
  > +      typename signature_mfp<Mfp>::sgn,
  > +      typename signature_mfp<Mfp>::obj,
  > +      functor_case_traits_FunctorRef<typename signature_mfp<Mfp>::obj>
  > +    >
  > +    ,functor_invoker_functor<
  > +      typename signature_mfp<Mfp>::obj,
  > +      typename signature_mfp<Mfp>::sgn
  > +    >
  > +  {};
  > EOF
  >
  > 更に、signature_mfp は is_memfun_pointer に改名した。
  > ***[traits.vararg]
  > &pre(!cpp,!diff) <<<EOF
  > @ mwg.functor.inl @ 14:53 2011/01/22
  >    template<typename T>
  >    struct functor_traits<T>:functor_traits_switch<
  >      T,void,
  > +    is_vararg_function<T>::value?5:
  > +    is_vararg_function_pointer<T>::value?5:
  >      std::is_member_function_pointer<T>::value?3:
  >      std::is_member_object_pointer<T>::value?4:
  >      has_single_operator_functor<T>::value?1:
  >      is_pointer_to_single_operator_functor<T>::value?2:
  >      0
  >    >{};
  > @ mwg.functor.inl @ 14:53 2011/01/22
  >    template<typename F,typename S>
  >    struct functor_traits:functor_traits_switch<
  >      F,S,
  > +    is_vararg_function<F>::value?5:
  > +    is_vararg_function_pointer<F>::value?5:
  >      std::is_member_object_pointer<F>::value?4:
  >      is_variant_signature<functor_traits<F>,functor_traits<S*> >::value?1:
  >  #ifdef MWG_STD_DECLTYPE
  >      can_be_called_as<F,S>::value?2:
  >  #endif
  >      0
  > -  >{
  > -    // ■ !functor_traits<F>::is_functor の物の中からも
  > -  };
  > +  >{};
  > @ mwg.functor.varargs.inl @ 14:50 2011/01/22
  > -#%define 1
  > -  template<typename R %typenames%>
  > -  struct functor_traits<R(*)(%types...%)>
  > -    :functor_traits_signature<R(%types...%)>
  > -  {
  > -    typedef R (*fct_t)(%types...%);
  > -  };
  > -  template<typename R %typenames%>
  > -  struct functor_traits<R(%types...%)>:functor_traits<R(*)(%types...%)>{
  > -    typedef R (fct_t)(%types...%);
  > -  };
  > -#%define end
  > -#%expand mwg::functor::arities
  > +  template<typename S>
  > +  struct functor_traits_switch<S*,void,5>:functor_traits_signature<S>{
  > +    typedef S* fct_t;
  > +  };
  > +  template<typename S>
  > +  struct functor_traits_switch<S,void,5>:functor_traits_signature<S>{
  > +    typedef S fct_t;
  > +  };
  > @ mwg.functor.varargs.inl @ 14:48 2011/01/22
  > -#%define 1
  > -  template<typename S,typename R %typenames%>
  > -  struct functor_traits_switch<R(*)(%types...%),S,5>
  > -    :functor_traits_signature<S>
  > -    ,functor_traits_vaarg_invoker<R(%types...%),S>
  > -  {
  > -    typedef R (*fct_t)(%types...%);
  > -    typedef typename get_vaarg_variance<fct_t,S>::sgn_t data_sgn;
  > -    typedef struct case_tr:functor_case_traits<data_sgn*>{
  > -      using functor_case_traits<data_sgn*>::endata;
  > -      static data_sgn* endata(mwg_vc_typename functor_traits_switch::fct_t f){return reinterpret_cast<data_sgn*>(f);}
  > -    } ref_tr,ins_tr;
  > -  };
  > -  template<typename S,typename R %typenames%>
  > -  struct functor_traits_switch<R(%types...%),S,5>
  > -    :functor_traits_switch<R(*)(%types...%),S,5>
  > -  {
  > -    typedef R (fct_t)(%types...%);
  > -  };
  > -#%define end
  > -#%expand mwg::functor::arities
  > +  template<typename S,typename F>
  > +  struct functor_traits_switch<F*,S,5>
  > +    :functor_traits_signature<S>
  > +    ,functor_traits_vaarg_invoker<F,S>
  > +  {
  > +    typedef F* fct_t;
  > +    typedef typename get_vaarg_variance<fct_t,S>::sgn_t data_sgn;
  > +    typedef struct case_tr:functor_case_traits<data_sgn*>{
  > +      using functor_case_traits<data_sgn*>::endata;
  > +      static data_sgn* endata(mwg_vc_typename functor_traits_switch::fct_t f){
  > +        return reinterpret_cast<data_sgn*>(f);
  > +      }
  > +    } ref_tr,ins_tr;
  > +  };
  > +  template<typename S,typename F>
  > +  struct functor_traits_switch<F,S,5>:functor_traits_switch<F*,S,5>{
  > +    typedef F fct_t;
  > +  };
  > EOF
  >
  > ***[traits.pfunctor]
  > &pre(!cpp,!diff) <<<EOF
  > @ mwg.functor.cpp @ 15:16 2011/01/22
  >  #ifdef _MSC_VER /* VCBUG */
  > -  template<typename P,typename Mfp>
  > -  struct functor_traits_ftorP{};
  >    template<typename F,typename S>
  >    struct functor_invoker_functor{};
  >  #endif
  > @ mwg.functor.cpp @ 15:16 2011/01/22
  > +  template<typename P,typename C,typename S>
  > +  struct functor_invoker_pfunctor;
  > -#%define 1
  > +#%define 1 (
  > -  template<typename P,typename R,typename C %typenames%>
  > -  struct functor_traits_ftorP<P,R(C::*)(%types%)>
  > -    :functor_traits_impl<R(%types%),P>
  > -  {
  > +  template<typename P,typename C,typename R %typenames%>
  > +  struct functor_invoker_pfunctor<P,C,R(%types%)>{
  >      static R invoke(const P& f %s_params%,...){
  >        return R(const_cast<C&>(*f)(%args%));
  >      }
  >    };
  > -  template<typename P,typename R,typename C %typenames%>
  > -  struct functor_traits_ftorP<P,R(C::*)(%types%) const>
  > -    :functor_traits_ftorP<P,R(C::*)(%types%)>{};
  > -#%define end
  > +#%)
  >  #%expand mwg::functor::arities
  > +  template<typename P,typename SOp>
  > +  struct functor_traits_ftorP
  > +    :functor_traits_impl<typename is_memfun_pointer<SOp>::member_type,P>
  > +    ,functor_invoker_pfunctor<
  > +      P,
  > +      typename is_memfun_pointer<SOp>::object_type,
  > +      typename is_memfun_pointer<SOp>::member_type
  > +    >
  > +  {};
  > EOF
  > ----
  > **変更. mwg_concept_is_valid_expression からの独立
  > ***顛末
  >
  > mwg_concept_is_valid_expression は GCC では version 3 からでも動作するつもりでいた。\
  > 然し、実はちゃんと動作しないという事が分かった。\
  > decltype の代わりに sizeof を用いた sfinae で G++ 4.5.0 で動作確認をした様な気がするのだが、\
  > 実は sizeof のSFINAE 動作自体 decltype の導入と共に定義し直された様である。\
  > (実は C++11 になるに伴って、SFINAE に関係する部分の規格の文章が詳しくなって、\
  > C++03 までは曖昧だった部分がはっきりと定められたのである。\
  > sizeof の変更は C++11 に適合する様に更新した物であろう。)
  >
  > 今後の方針としては、
  > G++3 以前でも適用可能な SFINAE を見つけるか、
  > 或いは、他の方法を用いて実現するか…。
  >
  > -[[本の虫: has_xxxの実装方法>http://cpplover.blogspot.com/2008/10/hasxxx.html]]
  >  そもそも VC については諦めていた訳であるが、\
  >  ここには VC に対する workaround が紹介されている。\
  >  (然し、結局ここで紹介されている物も、メンバの型を決め打ちで行かないと行けない。)
  > -{型は何でもいいからメンバが存在するかどうかを確かめる方法?
  >
  > 図らずも、VC でそれを判定する方法が分かってしまった。VC9 でも OK。\
  > g++ 4.3 (decltype/sizeof SFINAE が不完全な g++4.3 でも、\
  > この方法によって判定が可能であるという事が分かった。\
  > しかし、g++3 に関しては結局駄目である…。
  > }
  >
  > ***変更
  > 結局 g++3/g++4.3/vc 等に関しては mwg_concept_is_valid_expression を信用する事ができないという事を認める。\
  > そして mwg_concept_is_valid_expression の設計方針も変更する事にした (mwg/concept.h の方を参照)。
  >
  > 更に、mwg_concept_is_valid_expression からできるだけ独立したコードに変更する事にする。

  | &pre(!txt,title=functor.memo2.txt){
  | -*- coding:utf-8 -*-
  |
  | ■mwg::function
  |
  | 何をどう実装するのか良く分からなくなってきたので、茲で、整理し直す。
  |
  | ■どんな使い方があるか? (案)
  |
  | 1. 関数型の引数 (速度重視)
  | ~~~~~~~~~~~~~~~~~~~~~~~~~~
  | 従来、以下の様にしていた物を、
  | template<typaname F>
  | int f(const F& functor);
  |
  | 次の様に書ける様にする。
  |
  | // is_functor: 厳密に int(int) のシグニチャを要求
  | template<typename F>
  | mwg_requires((mwg::is_functor<int(int),F>::value)
  | int) f(const F& functor){
  |   for(int i=0;i<10;i++)
  |     mwg::apply<int(int),F>(f,i);
  | }
  |
  | // be_functor: 共変引数・反変戻り値を許す形
  | template<typename F>
  | mwg_requires((mwg::be_functor<int(int),F>::value)
  | void) f(const F& functor);
  |
  | 利点:
  | 　この様にする事で、operator() を実装していない型でも、
  | 　functor として扱う事ができる様になる。
  | 　反変性・共変性にも対応出来る。
  |
  | 要素:
  |   template<typename SGN,typename F> struct is_functor;
  |   template<typename SGN,typename F> struct be_functor;
  |   template<typename SGN,typename F> auto apply(const F&, ...args);
  |
  |   ※三つ目の overload は可能かどうか気になったが、
  |     試しに簡単な物で実験した所、可能であった。(@ gcc3, gcc4, vc10)
  |
  | 2. 関数型の引数 (簡単定義)
  | ~~~~~~~~~~~~~~~~~~~~~~~~~~
  | 速度がそれ程気にならない場合には、
  | 仮想関数を用いて呼び出す方式が使える。
  | 次の様に書ける。
  |
  | // mwg::delegate: 厳密に int(int) のシグニチャを要求
  | int f(const mwg::delegate<int(int)>&){
  |   for(int i=0;i<10;i++)
  |     mwg::apply<int(int),F>(f,i);
  | }
  |
  | // mwg::delegate: 共変引数・反変戻り値を許す形
  | int f(const mwg::var_delegate<int(int)>&){
  |   for(int i=0;i<10;i++)
  |     mwg::apply<int(int),F>(f,i);
  | }
  |
  | 要素:
  |   template<typename SGN,typename F> struct delegate;
  |   template<typename SGN,typename F> struct var_delegate :delegate<SGN,F>;
  |   template<typename SGN,typename F> struct function;
  |   template<typename SGN,typename F> struct var_function :function<SGN,F>;
  |
  | 説明:
  |   class hogehoge
  |     ctor として int(int) 系の引数を取る
  |     explicit ctor として int(int) に共変・反変な物を取る
  |   class var_hogehoge
  |     ctor として int(int) 系の引数を取る
  |     ctor として int(int) に共変・反変な物を取る
  |     これは、hogehoge を継承してコンストラクタを上書きするだけの簡単な実装にする。
  |
  |   class function
  |     メンバ関数の場合、オブジェクトは複製を保持
  |   class delegate
  |     メンバ関数の場合、オブジェクトは参照を保持
  |     delegate よりもオブジェクトの寿命が長い必要有り
  |
  | 3. 関数オブジェクトの格納
  | ~~~~~~~~~~~~~~~~~~~~~~~~~
  | これには、2. の delegate 及び function を流用する事にすれば良い。
  |
  | ■関数として扱う物体
  |
  | 1. 関数型
  |   R (*)(params)
  |   R (*)(params,...)
  | 2. データメンバ型
  |   R C::*;
  | 3. メンバ関数型
  |   R (C::*)(params)
  |   R (C::*)(params,...)
  |   R (C::*)(params) const
  |   R (C::*)(params,...) const
  | 4. インスタンス＋メンバ関数
  |   R (C::*)(params)
  |   R (C::*)(params,...)
  |   R (C::*)(params) const
  |   R (C::*)(params,...) const
  | 5. Functor
  |   having: R operator()(params);
  |   having: R operator()(params,...);
  |   having: R operator()(params) const;
  |   having: R operator()(params,...) const;
  | 6. pointer to functor
  | 7. smart pointer to functor
  |   having: F& *operator() const; where F is functor
  |   having: const F& *operator() const; where F is functor
  |
  | <del>
  | ※可変長引数 ... を含む関数の場合、
  |   可変長引数を可変長引数の儘渡す方法がないので、
  |   関数オブジェクトに入れるのは無理である。
  |
  |   実際に利用する際には、引数の個数を固定して渡すしか方法はない。
  |   つまり、functor_traits は存在するが、その儘の ref_t ins_t は存在しない。
  |   実際に使用する時には、共変性によって具体的な引数を持つ
  |   function/delegate を初期化する形になる。
  | </del>
  |   可変長引数自体を渡す事はできないが、
  |   template で型付で複数の引数個数に対する overload は作成する事が可能である。
  |
  | ■実装の手順
  |   functor_traits
  |   ・オブジェクトのシグニチャの決定
  |     オブジェクトの型から自然に導出されるシグニチャを決定
  |   ・テンプレート用
  |     関数呼出
  |   ・仮想関数用
  |     ref_t
  |       delegate オブジェクトのデータ
  |       sizeof に上限を設定する
  |       (delegate インスタンス内に placement)
  |       仮想関数呼出
  |     holder_t <- function オブジェクトのデータ
  |       仮想関数呼出
  |
  |   fun_signature
  |     反変・共変の処理
  |
  |   反変共変処理
  |   ・functor_traits で決定出来る物
  |     ・引数の共変性   void(derived)  <- void(base)
  |     ・Arity の共変性 void(int,int)  <- void(int)
  |     ・戻り値の反変性 base()         <- derived()
  |   ・functor_traits で決定出来ない物
  |     ・複数ある operator から適合する物を選択
  |
  | --------------------------------------------------------------------------------
  | ■ VC SFINAE バグについて
  |
  |   mwg_concept_is_valid_expression が正しく動く様な方法をを探していたが、
  |   どうやら、無理な様である。(一日ぐらい時間を潰してしまった...)
  |
  |   仕方がないので、VC 専用に代替のコードを考える様にする。
  | --------------------------------------------------------------------------------
  |
  | ■現在のクラス構成
  | □型動作定義
  |   concept case_tr{
  |     typename fct_t;
  |     typename case_data;
  |     typename fct_tr;
  |       // 実行関数 static invoke を保持する functor_traits
  |     static T endata(U);
  |       // ファンクタインスタンス U を case_data に代入出来る型 T に変換する関数
  |     static V dedata(case_data);
  |       // case_data を invoke に渡せる型 V に変換する関数
  |   };
  |   実装補助: functor_case_traits<F>
  |
  |   class functor_traits<T>{
  |     型 T を関数として扱いたい時の、
  |     "既定の" シグニチャとそのシグニチャに対応した functor_case 型の提供
  |
  |     static const bool is_functor;
  |       // 既定のシグニチャを持つ functor であるか否か
  |       // (既定のシグニチャが複数ある場合には false)
  |     static const int arity;
  |       // 引数の数
  |     static const bool has_varargs;
  |       // 可変長引数を持つか否か (未使用)
  |
  |     typename sgn_t;
  |     typename ret_t;
  |     typename arg1_t;
  |     typename arg2_t;
  |     typename arg3_t;
  |     typename arg4_t;
  |     ...
  |
  |     typename ref_tr : case_tr;
  |     typename ins_tr : case_tr;
  |
  |     static ret_t invoke(T, arg_t..., ...);
  |   };
  |   実装補助: functor_traits_signature<S>
  |   実装補助: functor_traits_impl<S,F,RefTr=,InsTr=>
  |
  |   class functor_traits<T,S>{
  |     型 T をシグニチャ S として扱いたい時の、
  |     functor_case 型の提供
  |
  |     static const bool is_functor;
  |       // T をシグニチャ S として扱う事が出来るか否か
  |     typename ref_tr : case_tr;
  |     typename ins_tr : case_tr;
  |
  |     static R invoke(T, As...);
  |   };
  |
  |   is_functor<S,F>::value
  |     // 型 F が既定のシグニチャとして S を持っているかどうかを判定
  |   be_functor<S,F>::value
  |     // 型 F がシグニチャ S の関数として振る舞う事が出来るかどうかを判定
  |
  | □コンテナ
  |   interface functor_case<S>{
  |     R call(%types%) const;
  |     ~functor_case();
  |     functor_case* placement_clone(void* ptr) const;
  |   };
  |   実装補助: class functor_case_data<S,T>;
  |   実装補助: class functor_case_impl<S,Tr : case_tr>;
  |
  |   struct functor_base<S>{
  |     R operator()(As...) const;
  |   };
  |   class functor_ref<S>;
  |   class functor<S>;
  |
  |   class vfunctor_ref<S>;
  |   class vfunctor<S>;
  |     // 引数用のクラス
  |
  | ■実装
  | □拡張
  |   class functor_traits<T,S>
  |
  |   反変引数として扱う場合
  |   1. 既定のシグニチャからの共変・反変性
  |     ・型の変換 std::is_convertible [完]
  |     ・引数の数の増加 [完]
  |     ・可変長引数の具体化 [完]
  |   2. 既定以外のシグニチャの可能性
  |     ・関数オブジェクト
  |       operator() のオーバーロードの選択 [完]
  |       ※オーバーロードがない場合にのみ既定のシグニチャからの共変・反変性を考える
  |         (そうでないと、対応出来ないし、対応出来たとしても、
  |         曖昧・予期しない結果になる可能性があり問題)
  |     ・メンバ型の場合
  |       T&(C&) の他に const T&(const C&) も [完]
  |
  |
  | □可変長引数の具体化について [完 23:39 2011/01/16]
  |
  |   例: printf(const char*,...)
  |
  |     functor<int(char*,int)> f=printf;
  |     ・char* は const char* にキャストしてから渡す
  |     ・int はその儘渡す
  |
  |     functor_traits<int(const char*,...),S(*)()>
  | }
