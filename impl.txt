
------------------------------------------------------------------------------
  Note
------------------------------------------------------------------------------

* clang -std=c++0x から GCC 4.4.7 libstdc++ を使えない。これに対する対処は諦める。

* gcc-3.3.6 は &X::member, void (X::*)() の形の SFINAE が効かない。
  これにより has_member 系統が全て実装できないので <type_traits> が提供できない。
  gcc-3.3.6 の full support は諦める。

* gcc-2.95.3 はそもそも SFINAE が使えない。
  SFINAE は overload 選択に使用する物であるが、
  別の方法を用いて overload 選択をすれば対応できる可能性がある。

  但し、別の方法 (クラステンプレートによる分類) は現在不安定である。


------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------

2016-04-04

* mwg/functor.h の構造について再確認すると共に整理を行う。

  現在の構造の中心となるのはやはり functor_traits である。

  template<typename F>
  class functor_traits{
    typedef F fct_t;
    static const bool is_functor;
    static const int arity;
    static const bool has_varargs;

    typedef auto ret_t;
    typedef auto sgn_t;
    typedef auto arg1_t;
    typedef auto arg2_t;
    typedef auto arg3_t;
    ...

    typedef auto ref_tr; // functor への参照を保持
    typedef auto ins_tr; // functor の複製インスタンスを保持
    static ret_t invoke(const fct_t& f,...){
      f(...);
    }
  };

  todo: ref-qualifiers に対応する?

    C++11 → cv qualifiers 4 通り×ref-qualifiers 3通り with variadic
      多くのコンパイラで variadic templates の方を先に実装しているので、
      ref-qualifiers の対応には variadic templpates を前提として良い。
      (そうでないと大量の overload を用意しなければ為らず非現実的だ。)
    C++03 → cv qualifiers 4 通り×ARITY_MAX

  todo: invoke 周りの forward は一体どうなっているのか?

    C++11 ならば関数本体に到達するまで forward を繰り返すべきである。
    C++03 の時は、引数の型は基本的に T か T& か const T& かの3通りしかない。
    値の時は引数の型は T const& として受け取る様にすればよい。

2016-03-24

* SD-6 support

  C++ に SD-6 という recommendation ができて C++11/14/1z
  の各機能の実装状況について調べられる様になった様である。
  libmwg のテストを更新しようという事になった。

  SD-6 に関する文書は以下にある。
  [[本の虫: SD-6: 機能テスト>https://ezoeryou.github.io/blog/article/2014-12-16-feature-test.html]]
  [[SD-6: SG10 Feature Test Recommendations : Standard C++>https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations]]

  今迄 libmwg のテストの名称は clang を元にしていた。
  その為か既に記述してあるテストについては名称は全て SD-6 の物と一致していたので変更はない。
  また、SD-6 では機能の version (どの論文に従った実装なのか) に応じてマクロに値を持たせる。
  既に libmwg にあるテストで対応する SD-6 マクロが存在する物に関しては値を一致させる。

2016-03-22

* xprintf: wchar_t, etc. 対応
* xprintf: template 部分を xprintf.cpp から xprintf.h に移動
  明示的インスタンス化を省略できる様にする。
  同時に str.support.xprintf.h も xprintf_writer ではなく
  template を利用した実装に切り替える。

2016-03-18

* mwg/strbuf: strbuf のテストを追加する。■
* mwg/strbuf: strbuf の破壊的機能を実装する。■

2016-03-07

* mwg/str: char_reference 名称再考?

2016-03-03

* string: strbase::insert(char_type c,range-spec) に対応する。

  現在の replace の実装は寧ろ splice という関数名に変えた方が良いのではないか。

* find_any, find_not, その他文字集合を指定する overload は、
  CLX の様に is_any_of() predicate か何かを用意すれば解決するのではないか。
  しかし、記述が面倒になる。よく使いそうな機能についてはそれ専用の overload があっても良い気がする。

  例.  s.find_any("<>")
    -> s.find(mwg::is_any_of("<>"));
    -> s.find(mwg::glob("[<>]"));
    -> s.find(mwg::rx("[<>]",mwg::rx_glob));
    -> s.find(mwg::rx("[<>]"));
    -> s.find("[<>]"_rx);

  例. s.ltrim("<>")
    -> s.ltrim(mwg::is_any_of("<>"));
    -> s.ltrim(mwg::glob("*([<>])","k")); // ksh extension

* #include <mwg/string.interop.cstring.h>

2016-03-02

* string: 現在の文字列インターフェイス (予定)

  以下実装済

  mwg::str_detail::strbase<Policy>
    全ての文字列クラスの基底クラス。
    基本的な非破壊的操作関数を備える。

  mwg::str_detail::string<XCH>
    固定文字列。データを他の文字列と共有しうる。

  mwg::str_detail::strsub<XCH>
    他の文字列、データに対する部分文字列を表現するクラス。

  mwg::str_detail::strbuf<XCH>
    編集用の文字列。参照の複製はされない。
    自己破壊関数も備える。

  以下は廃止された

  % mwg::str_detail::stradp<XCH>
  %   アダプタ。実質的に strsub と等価。
  %   # 唯一違う点は様々なクラスインスタンスから implicit に構築できる事。
  %   # 文字列の類を受け取る関数の引数の型などに用いるのが目的。

  以下は実装予定

  mwg::str_detail::strsymb<XCH>
    インスタンスの単一性を保証するクラス
    等値比較が、ポインタを比較するだけで済むので楽。
    比較的長い文字列で同じ物が沢山現れる場合にはメモリの節約にもなるかも。

    クラス名に関しては一考の余地有り。
    ruby では symbol と呼ばれている物である。

  mwg::str_detail::strsymb_dictionary<XCH>
    strsymb の親クラス。
    存在しているインスタンス全てをこの中に保持して管理する。
    デフォルトでグローバルに使用できるインスタンスを生成するが、
    ローカルに使いたいシンボル群を管理する為に、自分でインスタンスを生成する事も可能にする。

    内部構造は取り敢えず std::map (sorted list) で二分探索。
    将来的には trie を考えても OK

  mwg::str_detail::strpath<XCH>
    ファイル名を管理する為の文字列。
    ファイル名を操作する関数を備える? operator/

2016-02-29

* string: できるだけ operator[] ではなく iterator を使って処理を行う。

  特に複数の連続した文字を取り扱う様な処理では iterator を使うべき。

  - 但し、operator[] の呼び出しに対しては operator[] を使うのは気にしなくて良い。
    つまり、次の operator[] 呼び出しを予期して位置と状態を内部にキャッシュするなどの処置はしない。
    その時の非効率性は元々の operator[] の呼び出し元が責任を持つべきである。

  従来の iterator の要件だけでは、様々な処理をするのに不十分である。
  データを連続に読み取って行う処理を一通りできる程度の機能は有するべきである。
  iterator の要件として i+offset, i-offset, i-j, --i を追加する。

  - 逆方向に辿る事ができない様な文字コードの場合、この要件を満たすのが難しいかもしれない。
    その様な文字コードがあるとしたらその文字コードがいけないのである。
    もしその様な文字コードを使用しての処理を無理にでも行うとすれば、
    iterator を生成する際に文字列全体に対するインデックスを生成する様にしてしまえば良い。

    a 例えば、index -> byte offset の様な対応を行う配列を用意する。
      データ量の節約の為、5 文字か 10 文字ごとにこの対応を覚える様にする。
      覚えていない位置へ移動したくなったら、その直前の記録位置から辿る様にする。

    多少非効率になるかもしれないが、その様な文字コードを使用するのは現代に於いては稀であるだろうし、
    その文字コードを使用した時だけの非効率性なので問題とはしない。
    何れにしても iterator として使いそうな機能は一通り要求して良いだろう。

  > trim, ends は iterator を用いて書き直した。
  > find の系統は全て書き直す必要がある
    意外と変更点は少なくて済んだ。template で書かれている御陰である。

  - default_const_iterator についても書き直す必要がある。

    現在は (buffer,index) のペアとして記述していて、
    値を読み出す時は毎回 buffer[index] として値を取り出している。
    これでは iterator にしている意味が余りない。
    本当は実際の buffer の詳細に応じて連続的にポインタを動かせる様に工夫するべきである。
    特に、multibyte に対応する時には buffer[index] の様にすると
    値を読み出すたびに文字列の先頭から文字を数えなければならず大変である。

    これを解決する為には buffer 毎に const_iterator を実装する必要が出て来る。
    現在の default_const_iterator の実装では、
    buffer 毎の処理の違いを共通インターフェイス operator[] に押し付けている。
    しかし、連続的に移動するという情報を利用して効率化する為には、
    この operator[] の実装毎に、対応する最適化が必要になるからである。

    > _strtmp_sub_policy
    > _strtmp_map_policy
    > _strtmp_ranged_map_policy
    - _strtmp_pad_policy
    - _strtmp_cat_policy<2>
    - _strtmp_cat_policy<3>
    - _strtmp_repeat_policy
    - _strtmp_reverse_policy

2016-02-27

* mwg::string multibyte character 対応

  文字の抽出と境目の判定を行う関数を用意して一般的に処理する?

  - 本来は、内部的には utf32 か utf16 を直接使うなどしたい。
    しかし乍ら可変長の文字コードのまま使用したいという需要は無視できない。
  - slice, remove, insert などは OK
  - tolower, toupper は OK だが、
    一般の map 関数については実装を変える必要がある。
    文字列の長さが変更される可能性があるので。

  多少観察してみた。基本的には buffer を弄れば何とかなりそうな気がする。

  - multibyte における文字型 char_type は
    multibyte 文字が格納できるぐらい大きな整数、
    もしくは、ベクトル型となる。
  - これは格納に用いる型 element_type とは異なる事に注意する。
  - operator[], length() などは char_type 単位の操作を提供する。
    begin, end も char_type 単位に列挙する反復子として定義する。
  －get_ptr だけは element_type 単位の操作を行う為の物とする。
    現状ではこれは strsub の定義にしか使用していない。
    この部分に関しては offset をずらす為の displacement について
    multibyte を考慮したものに書き換えれば良いだけである。

  - operator[] を直接使って処理を行っている箇所は
    できるだけ iterator を使って処理を行う様に書き換える必要がある。


  * string.multibyte: operator[] を multibyte で実装する場合には、
    終端位置と開始位置の近い方から scan を行うようにすると良い。
    但し逆方向からスキャンできない様な種類の文字コードを使っている場合は駄目である。

  * string.multibyte: JIS などの様に途中状態が存在する様な文字コードはどう取り扱うか?
    特に substr は途中からのデータの部分列を保持することになる。
    データの部分列だけを取り出しても、文字列として部分列にならないのである。
    この場合は substr に途中状態も一緒に覚えて置かなければならない。

  * 或いは substr 自体 iterator pair として実装するのが良さそう。

2016-02-25

* [2012-11-13] mwg::string: 関数名

    重要なのは分かり易くて、面倒でない関数名である。
    それぞれのライブラリで、どの機能にどの様な名前が与えられているかを調べる。

  + C++ 標準ライブラリ
    <a href="http://www.cppll.jp/cppreference/cppstring_details.html#find">C++文字列</a></li>
  + Boost String Algorithm Library
    <a href="http://www.boost.org/doc/libs/1_52_0/doc/html/string_algo/quickref.html">Quick Reference - 1.52.0</a>
    ※ Boost では基本的に破壊的操作を行う関数であり、
    _copy がついている物が新しいインスタンスを生成する関数である。

  + ATL/MFC CStringT
    [[CStringT Class>https://msdn.microsoft.com/en-us/library/5bzxfsea.aspx]]
  + CLR
    <a href="http://msdn.microsoft.com/ja-jp/library/7wtc81z6(v=vs.80).aspx">String メソッド (System)</a></li>
  + mwg-string
    <a href="../../dist/mwg-string/doc/document.htm">lib-string 更新履歴</a></li>
    初期の実装。CLR と似たような形式で関数名を決めていた。

  + Java
    <a href="http://docs.oracle.com/javase/jp/6/api/java/lang/String.html">String (Java Platform SE 6)</a></li>
  + JavaScript/ECMAScript
    <a href="https://developer.mozilla.org/ja/docs/JavaScript/Reference/Global_Objects/String/prototype#Methods">String.prototype - JavaScript | MDN</a></li>

  + ToDo: Perl
    <a href="http://www.perlplus.jp/func/string/">文字列に関する関数 - Perl関数のリファレンス</a></li>
  + ToDo: PHP
  + Ruby
    <a href="http://doc.ruby-lang.org/ja/1.9.2/class/String.html">class String</a></li>
  + CLX C++ Library
    [[CLX C++ Libraries>http://clx.cielquis.net/]]
    基本的には Ruby の命名を踏襲している様であるが、
    多用な引数を受け取る様にして hoge_if などの様な関数も追加している。

  + AWK (gawk)
    <a href="http://www.kt.rim.or.jp/~kbk/gawk/gawk_13.html">The GAWK Manual - 組込み関数</a></li>
  + Makefile

2015-10-19

* vc9 support

  - is_default_constructible for `struct Test1{Test1();};`
  - mwg/concept.h: has_add_operator 関連を正しく実現する方法を模索する。
  - mwg/std/limits: long double に対するサポート。

2015-10-15

* tuple 再設計

  % 現状の operator= の実装だと `tuple<int&> a,b; a=b` が参照ではなくて値をコピーする事になる。
  % (これは旧来の実装でも同じ問題を抱えていた。)
  %
  % 結局正しくコピーを実装する為には reference_wrapper を使用するしかないのだろうか。
  % というか標準の代入演算子は一体どの様になっているのか??
  % →参照メンバを持つクラスはそもそも代入演算子は定義されない様である。
  %   (※後述の通り、tuple では std::tie(x,y) = ... の様な使い方をする為に敢えて代入演算子を定義し、
  %   参照メンバの代入に関しては「参照先に値を書き込む」動作を行う。)
  %
  % と思ったが、寧ろ値をコピーするという動作の方が正しいのかも知れない。
  % というのも std::tie(x,y)=std::make_tuple(a,b); の様な使い方をするからである。
  % もしかしてそもそも C++ 構造体の参照メンバの代入について勘違いをしている???
  % →どうやら勘違いをしていた様である。そもそも参照メンバが存在している時はクラスの代入演算子は削除される。
  %   std::tuple の場合は代入演算子を敢えて定義して、参照先に値を代入できる様にしている事に注意する。

  →寧ろ値を参照先に書き込むという動作で正しい。

  tuple 実装上の注意:

    コピー代入演算子について

      通常参照をメンバに持つクラスはコピー代入演算子を持たない。
      tuple の場合は特別にコピー代入演算子を定義して参照先の値を書き換える動作として実装する。
      これによって std::tie(x, y) = std::make_tuple(1, 2); の様な使い方が可能になる。

  * tuple_cat は tuple_push/tuple_unshift ではなくて tuple_pop/tuple_shift を使って実装する方が自然である。

  ToDo: memberwise construction は各メンバ copy constructible である必要があるのではないか?
    何れにしても template で初期化する様にしたので、memberwise のコンストラクタを呼び出さない限りはエラーにはならない。

2015-09-23

* mwg/functor.h: functor_case の alignment は一体どうなっているのか…。

2015-09-22

* tuple のテスト達。今は #if 0 ... #endif で囲んでいる。

2015-09-21

* mmake が要求するコマンド群

  bash gawk perl iconv

* mwg/xprintf.h: xprintf_convert, create_xprintf_writer を定義する namespace を変更する?

  現在は mwg::xprintf_detail になっている。
  実は mwg でも良い様な気がする。xprintf_* という関数名なので他と混じる事もない。

  adl_helper を mwg/defs.h に移動する。xprintf_convert を mwg 名前空間に出す。

2015-09-20

* mwg/xprintf.h: 一応引数は完全 forward しているが、
  位置パラメータ N$ 等を用いると複数回引数を読み取る事が可能である。
  つまり、各関数は右辺値参照を受け取ってもそれを破壊するべきではない。

* mwg/xprintf.h: %; で std::flush, std::fflush, etc.?

2015-09-18

* mwg/std/type_traits ToDo

  is_null_pointer for C++11
    is_null_pointer は C++14 で導入された。
    C++11 未満では追加したが、C++11 はそのまま使っているので補填する必要がある。

  aligned_storage,
  aligned_union,
  underlying_type,
  result_of,
  max_align_t in <cstddef>

* mwg/xprintf.h: tuple_element_select 関連の整理。

2015-06-21

* std::tr1

  using namespace std;
  using namespace std::tr1;

  としていると両方で定義されている物を stdm:: を介して使おうとするとエラーになるということがわかった。

* mwg/bio/tape.h

  サポートされていない操作をした時の動作について整理しておいた方が良い。
  現状だと例外を投げたり投げなかったりまちまちである。
  目安としては以下のようにしたらどうだろう?
  - tape を初期化した当初からその操作を実行できないことが明らかである場合は例外を投げる
  - tape の現在の読み取り状況などの都合によって実行できなかった場合は戻り値で返す
  そうすると現状の実装ではだいたい例外を投げるのが正しい動作ということになる。

2015-06-19

* とりあえずビルドのシステムの構造に関しては現状で問題無いと思う
  現状の構造について再度まとめることにする。

  src/Makefile.pp の書き方:

    BASE=..
    source $(BASE)/mmake/
    #%x prologue
    #%x epilogue

    ■ToDo もっと説明を追加する

* 自動で mmake 初期化を実行する仕組みを作る
  (mcxx に統合して mcxx +project init などとする手もある)

* test の方法についてより様々な種類のものを提供できるようにする?
  - コンパイルテスト・実行テスト・出力テスト
  - コンパイルが失敗する事を期待するテスト
  - テストを簡単に生成する mwg_pp マクロ?

* experimental な物をいつ統合するのかについて

  exprimental な実装や他のプログラムで作成したライブラリをどの様に統合するかのルールは作っておいた方がよい様に思う。
  例えば、複数のプロジェクトで同じコードを共有したくなった時に統合を行うとする?

  しかし、統合対象となるサブライブラリの中に更に experimental で余り使われていない
  機能 (であるが実装の根幹に入り込んでしまっている) 様な物がある場合に、
  その部分をどう扱うかは微妙である。例えば tape.h から使われている
  static_flags や iprint, yield, enumerable などの物のことである。
  tape.h 自体は様々なところから利用するので便利である。
  しかし static_flags や iprint, yield, enumerable は tape.h からしか使われていない。
  つまり余り interface としても洗練されていないし本当に必要なものだったのかというのも疑問である。

2015-06-15

* CXXCFG 毎の設定 #20150620.CXXCFG

  設定切り替えに関しては CXXCFG を用いて切り替える。
  CXXCFG を用いて切り替える際にどこにそれを記述するのかについて考える必要がある。
  CXXCFG に対応するファイルを作成してその中に設定を書き込むという方法もある。
  あるいは、どこかに hoge.mk の中に CXXCFG 毎の条件分岐を記述するという手も存在する。

  →$BASE/config.mk に設定を書き込むことにした。
    config ごとにファイルを作成してそこに書き込むのは面倒すぎる。管理が面倒である。
    再利用したい設定に関しては独立したファイルとしてコピーできる様にすると便利という考え方もあるが、
    その様な複雑な設定(?)は限られていると思われるし、
    複雑といっても程度があるので取り敢えずは、
    ファイルとしてではなく設定の文字列をコピーして管理する方針で行く。

* 環境変数 CXX CC FLAGS 等の情報をどのように取り入れるべきか?

  CXXCFG に関して → [[CXXCFG 毎の設定>#20150620.CXXCFG]]

  設定の取り込みに関しては少し考える必要がある。
  基本的に通常の場合と似たような振る舞いにするのが分かりやすい。
  しかし、環境変数によって取り扱い方が異なるのでそれについて確認しておく。
  1 先ず CXX CC FLAGS CXXFLAGS 等の情報は通常は ./configure の際に指定する。
    ./configure よりも後に値を変更したりしてもコンパイルには影響されない。
    そして g++ 等の呼び出しの際に直接に引数に指定することで適用される。
  2 一方で CPLUS_INCLUDE_PATH LIBRARY_PATH 等はコンパイルの実行時の情報が参照される。
    これらは通常は ./configure & make では設定されないし消去することもない。
    つまりビルドシステムはこれらの環境変数に対しては透過的である。

  現状の管理方法についても確認しておく。
  これらの環境変数の設定に関しては現在はコンパイラ側、つまり mcxx 側で勝手に制御している。
  mcxx にコンパイラを登録する時に CXX CC FLAGS および CPLUS_INCLUDE_PATH 等も取り込む。
  そして *_PATH に関しては、コンパイラを登録した時の PATH を勝手に追加する。
  また、FLAGS 等の値に関してはコンパイラを登録した時の値で上書きする (?)。
  実際に使っているかどうかについては疑問である。
  というのも mcxx には source $(mcxx +param config) 的な
  方法で環境変数をロードする仕組みもあるからである。

  ToDo:
  - mcxx の config as env-source files の仕組みは廃止する
    本当に廃止しても大丈夫か? これは g++/cl 等と直接入力して使う方法を封じることになる。
    特に cl に特別な引数を渡したいときに困るのではないだろうか。
  - mcxx の CC・CXX・CFLAGS・CXXFLAGS・LDFLAGS・FLAGS 取り込みは行う。
  - mcxx のCPLUS_INCLUDE_PATH・C_INCLUDE_PATH・LIBRARY_PATHに関しては限定的にする。明示されなければ追加しない。
  - mcxx に上記のパラメータの一覧を表示する仕組みを作る。

2015-05-15

* 識別子の衝突の問題

  同じ識別子に複数の異なるテストが割り当てられても気付かない可能性がある。
  そうすると片方のテスト結果がもう片方の結果を上書きしてしまう事になり予期しない結果になる。
  一つの解決方法は mwg_config.h の結合時に識別子の重複がないか確認する事である。

  しかし、重複する識別子を完全に禁止した場合、
  異なるファイルに同じテスト内容が存在する場合に不本意な結果になる。
  例えば、同じテスト内容に異なる (例えばファイル名をプレフィックスとした様な) 識別子をつけるという手もある。
  しかし、折角同じテストであるのだから統合したい。テスト内容を修正する場合にもそちらの方が都合が良いだろう。
  結局、複数のファイルの間で共有する可能性のあるテストに関しては今迄通り外部のファイルに記述するというのが現実的だろうか。

* check の依存性の問題

  大量の include を含めると Makefile の読込が遅くなるのではないか、という懸念。
  -include ....mk を纏めるという事

  当初は Makefile がこれ以上重くならない為に check の依存性まで含めるのを躊躇していたが、
  Makefile が重くなる原因が判明し、これが問題にならない様であるという事が分かったので余り気にしないでよい。


------------------------------------------------------------------------------
  ChangeLog
------------------------------------------------------------------------------



------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2016-03-27

* gcc-3.3.6 対応 → 無理。諦める

  gcc-2.95 は取り敢えず諦めたので gcc-3.3.6 について support を試す。

  1 試しにコンパイルしてみたらいきなり ICE である。
    tape_head::read の SFINAE 条件で発生している。
    どうやら条件式に ! や && 等を使えない様である。
    所謂 ice_and, ice_not, ice_or の類は gcc-3.3 のために有ったのだと今知った。

    | typename mwg::stdm::enable_if<
    |   !mwg::stdm::is_same<T,U>::value,
    |   typename rwflags_detail::rwflags_impl<T,RWFlags>::rtype>::type

  2 またバグが出た。
    依存名でない筈なのにテンプレート中だと template を付けないと呼び出せない関数が存在する様だ。

  3 更に ICE が出た。どうやらメンバおよびメンバ型は SFINAE の対象ではないようである。
    void (&X::*)(); で X = int を試すと ICE が出るし、
    &X::memfn で X = "memfn を持っていないクラス" を指定するとまた ICE が出る。
    メンバ型が判定できないとなると可成り厳しい。やはり gcc-3.3.6 はサポートの対象外とするか。

    さて今改めて調べてみると boost 1.54 は既に g++-4.0.1 以上しかサポートしない様である。
    更に、g++-4.5 未満は子ライブラリによってはサポートしなくても良いという事になっている。
    [[Installation and compatibility - 1.54.0>http://www.boost.org/doc/libs/1_54_0/libs/log/doc/html/log/installation.html]]
    boost がサポートしていないのであればまあ諦めても良いかという気がする。

* gcc-2.95 未だコンパイルが通らない。保留。

  2016-03-26: 今日検索していて気付いたのだが実は gcc-2.95 は SFINAE がないとか。
    道理で overload ができない訳である。
    エラーメッセージで SFINAE が働いていないかのように表示されていたのは寧ろ当然で、
    何となく SFINAE を使っている気になっていた部分が動いていた方が不思議なのである。

    それとは別に複雑なテンプレートを使用して
    overload を実現しようとしたコードが通らない。ICE になる。
    単純なテンプレートで overload を実現しようとすると通るのだが。。。

2016-03-24

* gcc-2.95 support

  gcc-2.95 の g++ をサポートしようとしたが gcc-2.95 には色々と問題がある。

  1. #line hoge file とすると、

    後に続く #include "..." の起点が勝手に #line で指定した物に置き換わる。
    つまり、gcc-2.95 をコンパイルする時には #line は off にしておかなければならない。

  2. そもそも簡単なプログラムが通らない。

    | 1 簡単なプログラムが通らない
    |
    |     #include <algorithm>
    |     int main(){return 0;}
    |
    |     $ /opt/gcc-2.95.3/bin/g++ stl.cpp
    |
    |   上記を単純にコンパイルしようとするだけで、大量の文法エラーになる。
    |   エラー箇所を見ても特に何も見えない。何かマクロが定義されている事によるエラーだろうか。。
    |   どうもマクロを展開して調べてみると、
    |
    |     include/g++-3/streambuf.h:91: _IO_wchar_t _fill;
    |
    |   が展開された結果として
    |
    |     include/g++-3/streambuf.h:91: _G_wchar_t _fill;
    |
    |   になるが、_G_wchar_t が定義されていない事による物の様だ。試しに、
    |
    |     $ /opt/gcc-2.95.3/bin/g++ -D_G_wchar_t=wchar_t stl.cpp
    |
    |   としてみるとコンパイルが通った。何か設定でも間違えたのだろうか。
    |
    | 2 更に検索してみると _G_wchar_t は _G_config.h というファイルで
    |
    |     typedef long int _G_wchar_t;
    |
    |   の様な感じに定義される物の様である。そして、_G_config.h は、
    |
    |     include/g++-3/stl_config.h:151:#   include <_G_config.h>
    |
    |   として読み込まれる筈である。検索してみるが、_G_config.h は見付からない。うーん。
    |
    |     $ /opt/gcc-2.95.3/bin/g++ -MD -D_G_wchar_t=wchar_t stl.cpp
    |     $ grep _G_config.h stl.d
    |     /usr/include/_G_config.h /usr/include/bits/types.h \
    |
    |   つまり、元からシステムに入っている _G_config を使おうとしているという事だ。
    |   改めて確認する。
    |
    |     $ find /opt/gcc-2.95.3/ | grep config
    |     /opt/gcc-2.95.3/include/g++-3/stl_config.h
    |
    |   やはり gcc-2.95.3 は _G_config を提供していない。
    |   仕方がないので /usr/include/_G_config.h の方を観察する。
    |   うーん。libio.h の一部のファイルのように書かれている。
    |   この libio は標準ライブラリの一部のようである。
    |   そして この _G_config.h の中身は 2012 頃に (?) 大整理された様である。
    |
    | 3 似たような問題として _G_config.h が見付からないと言っている人がいる。
    |
    |     https://gcc.gnu.org/ml/gcc-help/1999-q3n/msg00396.html
    |
    |   そこへの回答は、gcc を tarball からインストールする時は、
    |   唯単に make install するだけでは駄目なのだと書かれている。
    |   何とそうなのか。。当然 gcc-2.95.3 を入れる時には整理しかしていない。
    |   →gcc-2.95.3 の install の index.htm を観察してみたが
    |     _G_config.h については何も書かれていない。
    |
    | 4 分からないので、gcc-2.95.3 を丸まる検索してみる。どうやら
    |
    |     ./i686-pc-linux-gnu/libio/Makefile:_G_config.h: ${srcdir}/gen-params
    |
    |   とあるぐらいだから、_G_config.h は自動的に生成される筈の物のようである。
    |   仕方ないので再度 ./configure & make を試してみる事にする。
    |
    |   コンパイルできないエラーになる。gcc-5.3.1 が悪いのか?
    |
    | 5 仕方がないので gcc-4.6.3 で試す。今度は別のエラーになる。
    |
    |     /usr/include/bits/stdio-lock.h:47: #if defined _LIBC && IS_IN (libc)
    |
    |     sudo sed -i 's/defined _LIBC/defined (_LIBC)/' /usr/include/bits/stdio-lock.h
    |
    |   で無理矢理システムのヘッダを修正する。(/usr/include/bits の中で、
    |   このファイル stdio-lock.h だけタイムスタンプが古かったから
    |   何かサポートされなくなったファイルなのだろう。)
    |   でもそれでもエラーは変わらない。問題があったのは、IS_IN の方だろうか。
    |   段々諦めるしかない様な気がしてきた…。検索してみると…
    |
    |     https://sourceware.org/ml/libc-alpha/2014-08/msg00337.html
    |
    |     bits/stdio-lock.h について以下を追加する
    |
    |     +#ifndef _LIBC
    |     +# define IS_IN(lib) (0)
    |     +#endif
    |
    |   という話があるのでこれを試してみる事にする。するとこの問題は通った。
    |
    | 6 ところがまたエラーになる。今度は _G_*_t の類が定義されていないとエラーになる。
    |   そもそも _G_*_t の類を正しく定義する為にコンパイルをやり直しているのに、
    |   その途中で _G_*_t が要求されるのはおかしい。
    |
    |   もしかすると _G_config.h が正しく生成されているにも拘わらず
    |   誤った _G_config.h が読み込まれてしまっているだけなのだろうか。
    |   という事で _G_config.h を検索してみるがやはり未だ生成されている気配はない。
    |
    |   試しに以下をやってみると呆気なく _G_config.h が生成された。
    |
    |     cd i686-pc-linux-gnu/libio
    |     make _G_config.h
    |
    |   直後に make をしてみたら新しく生成された _G_config.h が読み込まれている様である。
    |
    | 7 それでも未だエラーはある。新しく作成された _G_config.h の中に、
    |
    |   34:typedef _G_fpos_t _G_fpos_t;
    |   45:typedef __sigset_t _G_sigset_t;
    |
    |   という行があるのである。先ず _G_fpos_t を定義するのに _G_fpos_t を必要としているのは変である。
    |   更に、__sigset_t も恐らく定義されていないのだろう。もう面倒なので別の場所から取ってくる。
    |
    |   https://classes.soe.ucsc.edu/cmpe202/SimpleScalar/glibc-1.09/sigset.h
    |   typedef unsigned long int __sigset_t;
    |
    |   https://fossies.org/dox/glibc-2.23/generic_2__G__config_8h_source.html
    |   typedef struct
    |   {
    |     __off_t __pos;
    |     __mbstate_t __state;
    |   } _G_fpos_t;
    |
    |   /usr/include/bits/types.h:131:__STD_TYPE __OFF_T_TYPE __off_t;  /* Type of file sizes
    |   /usr/include/bits/typesizes.h:51:#define __OFF_T_TYPE           __SYSCALL_SLONG_TYPE
    |   /usr/include/bits/typesizes.h:31:# define __SYSCALL_SLONG_TYPE  __SQUAD_TYPE
    |   /usr/include/bits/typesizes.h:34:# define __SYSCALL_SLONG_TYPE  __SLONGWORD_TYPE
    |   /usr/include/bits/types.h:96:# define __SQUAD_TYPE              __quad_t
    |   /usr/include/bits/types.h:108:# define __SQUAD_TYPE             long int
    |   /usr/include/bits/types.h:93:#define __SLONGWORD_TYPE   long int
    |
    |   うーん。libio は何とか無理矢理コンパイルが通る様になったが、
    |   結局別の物が全然コンパイルが通らない。
    |   今度は libiberty の Makefile が生成されていないと言っている。そんな。
    |
    |   _G_config.h ができたので取り敢えずこれで良しとして手でこの _G_config.h をコピーする事にした。
    |
    |   $ sudo cp -i _G_config.h /opt/gcc-2.95.3/include/
    |
    |   最初の単純なソースファイルが特別な指定無しで通るようになった。

    [まとめ]

    結局手で gcc-2.95.3 用の _G_config.h を作成して /opt/gcc-2.95.3/include に配置した。

* %%c_str() の実装。%% → fix() の実装

  const XCH* を受け取る様な他の関数に指定する為に。
  直接 c_str() で const XCH* とするのは難しい。
  というのも、実際のデータを一時オブジェクトに結びつけなければ、
  データが使用前に消えてしまうからである。
  つまり、c_str() の呼び出し側に一時オブジェクトを作成しなければならない。

  a 一つの方法は operator->() の連鎖で一時オブジェクトを呼び出し側に作成する。

    | struct tmpbuff{
    |   std::vector<char_type> data;
    |
    | public:
    |   tmpbuff(...);
    |
    |   tmpbuff* operator->(){return this;}
    |   tmpbuff const* operator->() const{return this;}
    |
    |   char_type const* c_str() const{return &data[0];}
    | };
    |
    | struct strbase{
    |   tmpbuff operator->() const{return tmpbuff(*this);}
    | };
    |
    | mwg::make_str("hello").toupper()->c_str()

    これは以下の様に解釈される。

    | mwg::make_str("hello").toupper().operator->().operator->()->c_str()
    |                                  ~~~~~~~~~~~~ ~~~~~~~~~~~~
    |                                  バッファ構築 内部ptr取得

    しかし乍ら、c_str() の時だけ -> を使ってアクセスしろ
    というのも分かりにくいインターフェイスである。これは混乱を生む。

  b 或いは、c_str() で一時オブジェクトを返し、
    そこから operator const XCH*() const でポインタに変換して貰う。

    | struct tmpbuff{
    |   std::vector<char_type> data;
    | public:
    |   tmpbuff(...);
    |
    |   operator const char_type*() const{return &data[0];}
    | };
    |
    | struct strbase{
    |   tmpbuff c_str() const{return tmpbuff(*this);}
    | };
    |
    | mwg::make_str("hello").toupper().c_str()

    この方法は記述の仕方については一番自然である。

    しかしながら、operator const char_type*() const が期待通りに呼び出されるかは不明である。

    x 例えば、printf の引数に渡したい時には (...) に適合させる為に
      const char_type* を自動的に呼び出してくれるという事はありえない。
    x また、テンプレート引数 + SFINAE みたいな構造になっている関数の場合も、
      テンプレートパラメータに tmpbuff が直接入ってしまってうまく行かない。

    やはり色々と微妙な方法である事は否めない。

  c 一番何もない方法は、ユーザに二段構えで呼び出して貰う事である。

    つまり使用時に、

    | mwg::make_str("hello").toupper().fix().c_str()

    の様に指定して貰うことである。

    というか途中で好きな時に現物バッファを作成できる、
    という点で fix() という関数は有って然るべきと思われる。

    それに、また fix() という関数を使わせる事によって、
    ユーザに対して mwg::str がどの様な動作を内部でしているのかを理解して貰う良い機会になる。
    多少学習コストは上がるかも知れないが、学習させずに隠蔽させてユーザに混乱を招くよりは良いだろう。

  これはもう殆ど fix() 関数しかまともな選択肢はない。

  Done> fix()を定義する
  Done> string に限って fix を上書きして自分自身を返す様にする

  % strsub についても fix で自分自身を返して良い気がする。
  % となると fix という関数名はどうなのか…
  % と思ったが、よく考えたら strsub は null 終端していないので
  % c_str にはできない。バッファへのポインタは取得できるが。

  なんか -> の方が良い気もしてきた…。

  a s.fix();

  b s(); // operator()();
    s.fix() と毎回書くのが面倒であれば、
    s() とだけ書けばよい様にしておいても良い。
    しかし、たかが文字列バッファ構築に () を使ってしまうのは勿体ない気がする。
    (といって、他のよりよい用途が思い付く訳ではない気がする)

  c s++; // operator++(int);
    後置演算子というのであればこれでも良いが、
    意味的に変である。却下である。

  d s->
    こうなったら -> でも良いような気がしてきた。
    後続する関数もそのまま呼び出せる。
    何も関数を呼び出すつもりがない場合には単に s.fix() としておけば良い。
    つまり、fix と operator-> を両方定義するということ。

    但し、-> についてのドキュメントは丁寧に書くのがよい。
    例えば、"メソッドチェインの途中で一旦バッファに文字列を構築するポイントを表す" 的な感じにする。

  Done> operator->() も追加する。
  Done> strfix については自身へのポインタを返す。
  Done> operator->() の説明を注意深く行う。

2016-03-23

* pointer_const_iterator はやはり単なる pointer でも良いのではないかという気がする。

  - %% const_iterator::has_index → mwg/concept.h で自動判定する様に変更。

  - const_iterator::some_type → 誰も mwg/str.h 内部では使っていない気がする。
    使っているのは std::iterator_traits だけであるが、ポインタについては特殊化されているので心配ない。

  さえ適当にテンプレートを経由して取得できる様にしてしまえば何も問題はない。

  - 但し、基底クラスにする時は、そのためだけに wrapper をかませる必要がある。
    つまり、基底クラスにする為に pointer_const_iterator が必要となる。

    →const_iterator を基底クラスにできる型にする為に
      wrap_iterator<Iter>::type を実装した。
      Iter がポインタならば wrapper として pointer_const_iterator を返す。
      それ以外の場合は Iter をそのまま返す。

* pp include したファイルも makefile で追跡できるようにする?
  前実装しようとしていたような気がするが結局現在はどのような状態か?

  →mwg_pp.awk の方にその様な機能を実装しただけで、
    実際には mmake では全くその様な物は用意されていなかった。


2016-03-22

* mwg/str: strfix の default/copy/move constructors
  と copy/move assignments は自動で生成される物では駄目なのか。

  default constructor に関しては、
  他に constructor を一つでも定義すると削除されるので、
  明示的に定義する必要がある。

  copy/move constructors/assignments に関しては、
  テンプレートで定義した別のコンストラクタと
  どちらが優先されるかという問題になる。

  C++ の仕様的にはどちらだろうか。
  分からないので取り敢えず実験してみることにする。

  [[/test/20160318.c++.implicit_copy_ctors_vs_template_ctors.cpp]]

  どうやら、テンプレートによる copy/move コンストラクタが一致するとしても、
  コンパイラが自動で定義する copy/move コンストラクタの方が優先される様である。
  従って、わざわざ strfix に明示的に copy/move コンストラクタを定義する必要はない。
  代入についても同様で、テンプレートによる copy/move 代入演算子が一致するとしても、
  コンパイラが自動で定義する copy/move 代入演算子の方が優先される様である。
  これらの振る舞いは clang 3.7 及び g++ 5.3.1, g++-2.95.3, vc++9 (VS2008) で確かめた。
  と思ったら icc14 が move assign に関してだけ別の振る舞いをすることが判明した。

  という事は注釈付きでこれらのコンストラクタを残しておいた方が安全に思われる。

  % というか改めて確認した所 template assign の実装が怪しい。
  % →いややはりOKだった。reset という関数名から shared_ptr::reset
  %   が呼び出されているのかと誤解しただけであった。

  strbuf の実装に際して暫定的に strfix のコンストラクタをそのまま流用するが、
  strfix のコンストラクタを整理するのと同時に strbuf の方も一緒に整理する必要がある。

  また別のクラスに関しても丁寧に確認する必要がある。
  →取り敢えず template constructors だけ確認した。問題無さそうである。

* mwg/bits/str.support.xprintf.h:
  strbuf_xprintf_writer が virtual であるが、
  virtual にしなくても済むような方法を考案する。

  または、xprintf_writer 自体にキャッシュ機能を付けて効率的にする。
  →取り敢えず xprintf_writer にキャッシュ機能を付ける方針で行く事にする。

  --- flush の問題 ---

  xprintf_writer にキャッシュ機能を付けるのが良いアイディアだと思ったが、
  最後の flush をどうやって行うかが問題になる。
  xprintf_writer であって派生クラスではないので flush も xprintf_writer から呼び出すのが自然である。
  愚直に考えればデストラクタで実行すればよいが xprintf_writer のデストラクタは、
  派生先で override された flush 関数を呼び出すことができない。
  何故ならデストラクタが呼び出される時には既に派生クラスは消滅して、
  virtual 関数は全てそのデストラクタを定義しているクラスで宣言した物
  (override されていない物) が呼び出されるからである。

  a 一つの方法は派生先のデストラクタで明示的に xprintf_writer::flush を呼び出させることである。
    或いは派生先から xprintf_writer::buffer の内容を直接読み取って処理する様にする。
    しかし、問題はこのルールを注意深く守って実装しなければならない事である。
    実装側でデストラクタを呼び出し忘れていても普通にコンパイルが通ってしまう。
    それでも xprintf_writer::~xprintf_writer 側でバッファが空かどうかをチェックする事はできるので、
    実装し忘れている人に注意を促すことはできるが間接的なので分かりにくい。

  b もっと別の方法で実現するしかない。例えば、xprintf_writer は抽象クラスにせず、
    xprintf_writer のメンバとして書き込みを行うクラスを保持するのである。
    書き込みを行うクラスはダックタイピングで良い。
    というか mwg::functor<void(char const*,int)> で受け取れる様にしてしまう。

  xprintf_writer は基本クラスではなく、functor をメンバに初期化するクラスに変更した。
  mwg::functor は結局仮想関数呼出になるし、
  またサイズの大きなファンクターの場合内部でメモリを確保する事になるが、
  これは仕方がないと諦める事にする。

  -- virtual にしなくても済む方法? --

  a 出力する文字列を std::vector だか std::string に溜めさせて、
    それをその都度呼び出し側で処理する様にする。

    x メモリ確保が生じるので余り速いとは思えない。
      メモリ確保が生じない程度の出力に抑えるのは実装が汚くなる。
    - メモリ確保が生じない程度に出力内容を溜めて仮想関数を呼び出す方法は、
      現状の xprintf_writer の実装に等価である。

  b ヘッダが巨大になる事を厭わないのであれば、
    実装を全て xprintf.h に読み込んでしまえばよい。

    o この様にすれば最早明示的テンプレート実体化の面倒な指定も必要ない。

    x 大して処理内容的に違いがないにも拘わらず出力先毎に
      テンプレート関数が実体化されるのは非効率にも思われる。
      また、コンパイル時間も当然長くなると予想される。

    o 事前のコンパイルが必要なくなるので、利用・移植しやすくなる。

    再度 xprintf.cpp を眺めてみたが template に為っている部分は十分小さい。
    つまり、xprintf.h に読み込んでしまっても問題ないような気がしてきた。

  上記の内やはり b がすっきりする気がする。
  コンパイル時間もそんなに気にならないだろうという結論に達する。
  コンパイル時間が気になる場合の為に、
  template の実装は別のファイルに分離して明示的実体化も一応用意する。

2016-03-20

* mwg/bits/str.support.xprintf.h テストを追加する

[整理]

* mwg/str: char_at_type を reference などに名称変更?

  今後文字列の表現として、データの要素の型と文字コードの型を分ける可能性がある。
  単に reference となっているとその時に不都合がある。
  現状の実装は寧ろデータの要素の型(の参照)ではなくて、
  文字コード(への参照)を char_at_type としている。
  この辺りは後で総合的に考える必要がある。

  →取り敢えず char_reference に名称を変更した。
    これを更に reference にまで変更するかどうかは後で考える必要がある。

* mwg/str: xprintf support

  xprintf は数を数えてから出力するという風にはなっていなくて、
  数を数えるのも文字を実際に出力するのも同程度の計算を要する。
  従って、二重の処理にならない様に内部に std::string でも構築して
  mwg::str インターフェイスを提供するのがよいように思われる。
  その為には strbuff を先に実装してしまった方が良い様に思われる。

  所で strbuff を実装するのに std::string を読み込む必要が出て来る。
  別のヘッダファイルとして実装するのがよいかも知れない。
  特に strbuff は、破壊的関数を備える必要の為に、
  今後実装が巨大になる可能性が高いのでこれでよい。
  (破壊的関数を備えるため、実際の所 std::string ではなくて
  std::vector を利用した実装に切り替える可能性もある。)

* C++: 一時オブジェクト用インスタンスのローカル変数作成を阻害する方法

  (特に mwg/str における一時文字列クラス達を想定している)

  式テンプレートを使う時、完結式評価まで一時オブジェクトの寿命が残る事を利用する。
  しかし、完結式のオブジェクトをコピーされたり、
  或いは、ユーザの手で完結式のクラスインスタンスを作成すると不正な参照・ポインタができてしまう。

  1 ユーザが明示的に一時オブジェクト用クラスインスタンスを作成できない様にするには:

    a 一番簡単な方法はそのクラスの名称を如何にも一時オブジェクトという感じにして、
      ユーザが明示的にそのクラスを使用しない様にすることである。
      例えば、foo_detail 名前空間の中に隠蔽したり、
      _tmpobj_... という名前のクラスにしたりといった事である。
      或いは、クラス名を dont_use_this_class 的な物にしても良いかも知れない。

      しかし、その様にしても文法的にはクラスインスタンスを作成できてしまう。

    b 文法的にも呼び出せない様にするためには、
      コンストラクタを隠蔽すればよい。つまり private または protected にする。

      x しかし、この様にすると外部の関数で実際にインスタンスを生成したい時には、
        その関数を friend にする必要が生じる。結構始末が悪い。
        ただ、これはクラス内に friend 関数{実装} などとしてしまっても良い?
      →それだと後からどんどん関数を追加するという事がしにくくなる。
        特にユーザがユーティリティ関数を追加する事を阻害してしまう。

  2 また、オブジェクト作成用のコンストラクタを封じたとしても、コピーはできるから、

    auto a = <expr>;

    等とされると問題になる。なので、コピーコンストラクタも封じるという手がある。

    x しかし、これも戻り値を構築する時にコピーが発生する筈なので、
      使用している箇所を一つ一つ friend にしておかないと、
      エラー (もしくは RVO でコピーが潰れれば警告) になる。

    x そればかりか、RVO が働ければコピーが消えて、
      普通にコンパイルできてしまうので、防御にならない?
      (でも、流石にコピー構築までは消えないか? 良く分からない。)

    x 更に、防御が成功したとしても単に auto a = <expr>;
      がエラーでコンパイルできないという事になる。
      自動的に (永続化のための) 適切な型を選んでくれるという事がない。

      つまり、ユーザは以下のように必ず型を記述しなければならない。

      mwg::strfix<char> a = <expr>;

      これは C++11 時代にあっては不自然だと考える人も多かろう。

  3 更に、コピーコンストラクタまで封じることができたとしても問題は未だ残る。
    参照として寿命を拡張することができる。この場合はコピーも起こらない。

    auto const& a = <expr>;

  試しに strbase に friend 指定でコンストラクタを書いてみることにする。

  | protected:
  |   template<typename P2>
  |   friend class strbase;
  |
  |   // copy/move constructor is protected
  |   strbase(strbase const& source)
  |     :data(source.data){}
  | #ifdef MWGCONF_STD_RVALUE_REFERENCES
  |   strbase(strbase&& source)
  |     :data(stdm::move(source.data)){}
  | #endif

  operator+ がコンパイルできなくなる。
  SFINAE やら SFINAE 用のクラスやらの依存性もあるし、
  friend 指定を書くのも面倒である。どうした物か。

  何れにしても今後、一時文字列を返すような関数は幾らでも作るはずである。
  その度に friend を書くのも大変であるし、
  friend を省略できるような仕組みも分からない。
  →例えばユーティリティクラスの様な物を作って、その中で実装する様にすれば良い?
    試してみたが、駄目だ。return をする為には結局コンストラクタが必要の様である。
    つまり、別の関数で実装を行ったとしても、
    friend 指定がなければ戻り値を受け渡す事ができないので駄目である。
    別の関数に実装を委譲するのだとしたら、
    委譲される鎖の全ての関数を friend にしなければならない。
  →よく考えたら使う時にそこで新しく専用の派生文字列クラスを定義して、
    その専用の派生クラスで friend に指定すれば良いだけでのことである。大した事はない。

  % 結局面倒臭くなるだけの様なのでコンストラクタで封じる案は今の所考えないことにする。

  a protected にしておいて、friend にしたければ派生クラスを作って
    其処に friend 宣言すればよいのだという事に気付いたのでそれで実装する。

  b 実は list-initializations in return statement を使えば、
    copy constructor は必要ないので、エラーには為らないという事が分かった。
    (規格を見ても不明瞭な気がするが、実際の実装ではどれもこれを受容する様である。)

    つまり、C++03 では auto v = 等とされる心配がないのでコンストラクタを封じる必要はなく、
    また C++11 では auto v = を封じる為に copy constructor を封じ、
    構築には list-initialization を用いる様にすれば良いという風に場合分けで対処すればよい。

  c 或いは…tuple を受け取る特別なコンストラクタを用意すれば、
    copy constructor を回避できるだろうか?■未確認

2016-03-07

* mwg/str: _tmpobj_arrow_operator のテストをしていない。
  →テストを追加した。まあ、動いている。OK

* mwg/str: const_iterator を BidirectionalIterator にする。

  mwg/str で実装している const_iterator を、他の STL に対応した関数に渡す時には、
  Iterator の要件を満たす様にしなければならない。

  - 特に value_type, iterator_category などのメンバには、
    std::iterator_traits<> から派生させることで対応できる。

  - iterator_category としては、特に、BidirectionalIterator に該当する。

  - 対応していない機能として、operator-> がある。

  - また、BidirectionalIterator の為に DefaultConstructible でなければならない。

  - *i の戻り値の要件

    % また、Iterator の要件で満たせない物として、
    % *i が %%dereferencable でなければならない (*i は参照である)%% という物がある。

    混乱があった。dereferencable というのは間接参照できる事である。
    つまり、*i という標記自体の事である。
    そしてドキュメントに dereferencable と書かれているのは、
    「i の現在の状態が間接参照可能な状態である場合に」という意味であった。
    (終端を表す iterator や、既定コンストラクタで作った iterator は間接参照可能な状態にない)

    この条件を改めて見てみると以下の事の様である:

      *i の戻り値の型は std::iterator_traits<Iter>::reference でなければならない。

    そして、std::iterator_traits<Iter>::reference が
    どの様な要件を満たしているべきかについては何も書かれていない気がする。
    少なくとも value_type に変換可能であれば良いようにも書かれている。
    そしてまた、OutputIterator の場合には (使用しないため)
    reference は void にして良いという事になっている。
    やはり、reference が (目的に合わせて) 多少変な型であっても良いということだろうか。

  という訳で以下の実装を行う。

  > - std::iterator<std::bidirectional_iterator_tag, char_type, std::ptrdiff_t, char_type*, char_at_type>
  > - 先ず reference は char_at_type である
  > - operator-> を追加する
  >   →char_type はどうせ整数型しか来ないのだから、
  >     operator-> を定義しても意味無いのではないだろうか。
  >
  >     何か特殊な機能を文字型に付加してその文字型を使いたいとしても、
  >     文字列の汎用 const_iterator を受け取るような関数でその機能を使う事は無い。
  >     但し、特殊な文字型を使った文字列を定義して、
  >     更にその特殊な文字型専用の関数で処理を行いたい場合には必要になる。
  >     →どうせ使わないだろうとは思うが実装しておく事にする。
  >
  > - DefaultConstructible にする
  >   →実装した。参照メンバはポインタにする。
  > - const_iterator 内部では std::ptrdiff_t の代わりに difference_type を使用する。
  > - StringPolicy 要件部分で bidirectional_iterator を要件として掲げる。

  # 余談
  #
  # ところで、std::iterator_traits<Iter>::pointer は何の為にあるのだろう?
  # iterator 要件には何処にも出てきていない様に見える。
  # そして pointer 自身、何であるか説明していないので、規格上は何の制限もない無意味な型という事になるのでは?
  # 一応 operator-> を自分で実装するとすれば pointer を内部的に使うという事は考えられるが、
  # std::iterator_traits<T*>::pointer の場合には operator-> ではなく builtin の -> なので、
  # Iterator の要件には明示的には出てこない。それに pointer とは別に勝手に operator-> を定義しても良い。

  更に後で以下の項目についても考える。

  > - pointer_const_iterator は std::random_access_iterator_tag にしたいが、これについては後で考える。
  >   →別項目で議論することにした。
  >
  > - char_at_type の名称を別の名称に変更する。
  >   というか普通に reference で良い気がする。
  >   →これも別項目で。

* mwg/str: const_iterator は std::random_access_iterator_tag にするべきか?

  然し、現在の実装を見てみるに殆ど RandomAccessIterator の機能を備えている様にも見える。
  先ず、operator+(ptrdiff_t) や operator-(ptrdiff_t) を保持している。(operator+=, operator-= も自動的に定義されるであろう。)
  更に、operator-(const_iterator) もある。一部の const_iterator は不等号演算子についても備えている。
  これに加えて operator[] を定義すれば random_access_iterator にする事ができる。

  どうせ operator+/- を定義するのであれば、要件を RandomAccessIterator にまで厳しくしてしまっても良いのではないか。

  x 調べてみたが実は operator+/- を使っている箇所は殆どない。というか、trim の中だけである。
    なので、RandomAccessIterator である事を要求するのは新しい文字列の形式を実装しにくくするだけなので良くない。
  x 特に mbcs において RandomAccess は非効率である。
    無理に RandomAccessIterator を実装してしまうと、STL 等の関数で RandomAccessIterator 用の実装が選択されてしまい、
    RandomAccess できない場合に最適化されたコードが選択されるのを阻害してしまう事になる。よくない。
  x もともとは pointer_access_iterator 等の
    RandomAccessIterator を自然に満たせる物については、
    stdm::random_access_iterator_tag にした方が効率が良いのではないかという事であった。
    しかし、これは個別に対応すれば良い話で、全ての const_iterator に対して要求する理由には為らない。

  結果、この提案は却下する事にする。

2016-03-05

* mwg/str: 実装の名前空間 (string3_detail) を公開するべきか

  ユーザが新しい文字列型を定義する為には strbase を使う必要がある。
  また、ユーザが新しく別の型からのアダプターを追加したい場合には
  adapter_traits の特殊化を定義する必要がある。

  これらの strbase や adapter_traits は現在は namespace mwg に公開していない。
  ここで、using を用いて namespace mwg に引っ張ってくるべきか、
  拡張を定義したいユーザに対しては実装の名前空間を弄って貰う事にするか、
  という選択肢が出来る。

  a string3_detail 名前空間は公開しない。

    strbase, str_adapter_traits を namespace mwg に公開する

    独自に文字列型を色々拡張をするとなると adapter_traits 等も拡張しなければならない。
    それらも公開するとなると面倒である。先ず名前を変更しなくては為らない。
    名前はより長く為るであろう。そして、その長い名前を毎回指定するのは大変だ。
    といいつつ、結局 adapter_traits を元に定義された as_str 的なクラスを
    通して使用する予定だから長くなっても余り違いはない気もする。
    うーん。それならば、拡張する人には string3_detail (後で名前は変えるとして)
    の内部を弄る事を許可してしまった方が良い気もする。

    というかよく考えたら特殊化は元々定義された名前空間で行わなければならないので、
    namespace mwg に引っ張ってきても意味がない。
    →adapter_traits 自体を初めから namespace mwg の中で定義するという手がある。

    更に、ADL が効く様にするためにはやはり string3_detail 内で関数を定義する必要がある。
    ADL で呼び出せる様な文字列用の関数を定義したいという需要もあるだろうから
    やはり string3_detail 名前空間は公開せざるを得ない気がする。
    (strbase 自体を mwg 名前空間内で定義するという場合には、
    ADL 用の関数を namespace mwg 内に書く事になる。
    これは他の関数と混ざり合う可能性があるので、これは論外である。)

  b string3_detail 名前空間を公開する。

    名前は変更する必要がある。string3_detail は変である。

  結局現実的には実装の名前空間を公開するという方法しかないように思う。
  ユーザには以下を許可する。
  - adapter_traits の特殊化を定義すること
  - strbase を文字列型の基底クラスとして利用すること
  - ADL を通して使うための文字列を受け取る関数を追加すること

  > ドキュメントに上記許可項目を追加

  [string3_detail 名称変更について]

  > string3_detail の名称を変更
  > これはヘッダファイルの名称を考えてからにする。

  ライブラリの中心関数を mwg::str (旧 mwg::make_str) と定めて、
  ヘッダファイル名を <mwg/str.h> に変更し、
  ライブラリモジュール名を mwg/str と呼ぶことにした。
  これに伴って string3_detail 名前空間をより分かりやすい名前に変更し、
  ユーザ側に拡張を許可するために公開できるようにする。

  名前は str_detail で良いだろう。
  変な省略のされ方をしている様で違和感があるかもしれないが、
  これは今迄の名前に慣れてしまっているからの様に思う。
  実際 mwg::str という関数が中心になっていると思えばこれは自然である。

* string: ヘッダファイル名 mwg/string.h の変更?

  a mwg/string.h は分かりやすい。
    しかし実際に string という型は定義していないという点で分かりにくいかも。

  b mwg/str.h
    含まれるクラスは大体 str で始まっているのでこれが良い?
    しかし mwg::str というそのものな型は存在しない。
    或いは mwg::make_str を mwg::str に変更しても良い。

  c mwg/strfix.h
    メインのクラスは何かと考えると strfix である。
    しかしながら、このライブラリは別に固定文字列 strfix だけのライブラリではない。
    ライブラリの目的的にも、実際に中にあるクラスという観点からも。

  mwg::make_str を mwg::str に変えるのが俄然良い方法の様に思えてきた。
  しかしながら問題点もある。str というのは一般的に使用される変数名である。従って、

  1. ローカル変数の str で mwg::str が隠蔽されて、変なことになる可能性がある。
    →基本的にいつも mwg::str の形で使う様にすれば問題はない。
      元々 libmwg は using namespace mwg せずに使う事を想定して設計している。
      なので、ユーザの側でも mwg::str の形で使って欲しい。
      また、mwg 名前空間の内部では str で mwg::str を参照することができるが、
      これは mwg::str として明示的に呼び出す様に規則付ければよい。

  2. 逆にローカル変数を参照しているつもりで str が出てきて、
    変なエラーメッセージが出る可能性もある。
    「ローカル変数 str が見付かりません」の代わりに
    「関数を文字列に変換できません」の様なエラーメッセージが出る様になって分かりにくい。
    まあしかしこれは仕方がない。

  まとめ

  > mwg/str.h に変更する
  > mwg::make_str -> mwg::str
  > mwg::str を呼び出す時は、例え libmwg 内部から呼び出す場合でも明示的に mwg::str と書く。
    →そもそもそんなに使用している箇所はなかった。内部使用は1箇所だけであった。
  > 上記注意点をドキュメントに追記する。

* string: enabler という用語は別の手法を想起するので変える。

* string: クラス名変更 mwg::string → mwg::strfix

  mwg::string は std::string と衝突するので別の名前にするべき
  例えば mwg::strfix など。
  この様に変更すると最早 mwg::string という名前の型すらなくなるので、
  ヘッダの名称を mwg/str.h 等に変更するべきな気もする。

  しかしそうすると mwg::make_str を mwg::str にしたくもなるが、
  そうすると、ローカル変数として str を使用した時に混乱を来す事になるので良くない。
  <mwg/str.h> は様々な文字列クラス str... の接頭辞 str を表しているとして納得して貰う事にする。

  取り敢えず mwg::string → mwg::strfix に変更した。
  ヘッダファイルの名称についての議論は別項目とする。

2016-03-04

* string: mwg::as_str 追加

  stradp 内部クラス化の項で議論したように、
  今後文字列を受け取る関数を定義する際は adapter_traits を使用する事にした。
  しかし、現状だと adapter_traits は使いにくいので、
  adapter_traits を継承して更に色々の物を提供する公開クラスを作成する。as_str である。

  先ず as_str を定義して色々な機能をつける。
  更に、今迄 adapter_traits を使って定義していた物を
  as_str を用いて定義する様に変更する。
  そして namespace mwg に公開する。

* string: stradp 内部クラス化?

  mwg::make_str を実装したので、
  寧ろ stradp が表に出て来る必要もないのではないか?

  SFINAE チェックを省略することにする。
  adapter_traits 経由でしか構築しないのであれば、
  コンストラクタのチェックを行う意味はない筈である。

  一方で、stradp はそもそもユーザが新しく文字列を受け取る様な関数を実装する際に、
  引数の型として使用できるように定義した物であった。
  しかし、現状の実装ではその役目を果たしていない。
  というか、寧ろ template<typename T> stdbase<T> と stradp<char> の二つについて
  定義を行わなければ為らず却って無意味である。それよりは、寧ろ新しく導入した
  adapter_traits の仕組みを利用して、adapter_traits<>::available だったら実装を
  提供するという方法の方が変に overload を作成しなくて済むので楽である。

  しかしながら、SFINAE の条件を書くのが面倒であるのは否定できない。
  現在自分で新しく関数を書くのだとしたら以下の様な可能性が考えられる。

  | a strbase<> しか受け取らない:
  |
  |   template<typename P> void f(strbase<P> const&);
  |
  |   変な SFINAE をしなくても自動的に文字列だけを選択してくれるので良い。
  |   mwg::str の文字列は全て strbase<P> の形をしている。
  |   問題は mwg::str 以外の文字列であるが、これについては
  |
  |     f(make_str(s));
  |
  |   等の様に呼び出し側で配慮すれば良い様に思う。
  |
  |   →しかしながら、文字列の型の種類を区別するというのは面倒である。
  |   実際に、const char* を渡すべきところに std::string を
  |   直接渡そうとしてコンパイラに怒られたりという事はよくある。
  |   また、std::string のまま渡しておけば良いのにわざわざ c_str()
  |   してしまったせいで新しい std::string インスタンスを生成していた、
  |   などという事もあるのではないかという気がする。
  |
  |
  |   また、strbase<> だけを定義することの問題ではなくて、
  |   strbase<> を使うこと自体の問題であるが、
  |   typename P::char_type について SFINAE をしたい場合に、長くなってしまう。
  |
  |   | template<typename P>
  |   | typename stdm::enable_if<stdm::is_same<char,typename P::char_type>::value,void>::type
  |   | void f(strbase<P> const&);
  |
  |   →それ専用の enabler クラスを作成すれば問題ない。
  |
  |     | template<typename P>
  |     | typename mwg::policy_enabler<P,char,void>::type
  |     | void f(strbase<P> const&);
  |
  |     というか、policy 側に enabler を附属させれば良いのではないだろうか。
  |
  |     | template<typename P>
  |     | typename P::enable_if_char_is<char,void>::type
  |     | void f(strbase<P> const&);
  |
  |     何か余り短くなっていない気もするがこちらの方が分かり易いであろう。
  |
  |   →更に他のSFINAE も混ざってくるとこの方法は使えない?
  |
  |     そういう時は、入れ子にすれば良いだけである。例えば以下のように。
  |
  |     | template<typename P>
  |     | typename P::enable_if_char_is<char,
  |     |   typename stdm::enable_if<条件式,Ret>::type
  |     | >::type
  |     | void f(strbase<P> const&);
  |
  |     というか、今迄 enabler を入れ子にするという事を考えた事がなかった。
  |     enable_if しか使わないのであれば単に && で繋げばよいが、
  |     enabler を定義して、更にそれを組み合わせる場合には、
  |     わざわざ新しいクラスを定義しなくても単に入れ子にすればよいのだ。
  |     もしかすると今迄に整理したコードの中にもこの手法で
  |     簡単に定義できる物が存在するのではないかという気がしてきた。
  |
  | b そもそも mwg::str を受け取る関数にしなくて良い?
  |
  |   標準ライブラリでも std::string を受け取る関数というのは実はほとんどない。
  |   std::string を使っていても最終的には c_str() を用いて const char* に変換して、
  |   その上で使うのである。そちらの方が分かりやすい。
  |   分かりやすさが効率を上回る例である。
  |
  |   特に C++ に関しては標準的な一つの文字列型というものが存在しないのが問題である。
  |   標準ライブラリには std::string と std::wstring があるし、
  |   更に自分で Traits や Allocator を定義して新しい文字列型を定義できる。
  |   更に、文字列の内部表現について (文字符号化方式など) 定められてもいないため、
  |   同じ文字列型であっても更に色々な様相を見せる。
  |
  |   その様な滅茶苦茶な状態に於いて一つの標準形式として
  |   const char* を採用するというのは悪くない選択肢のように思われる。
  |   どうせ、他のユーザーフレンドリーな言語に於いては、
  |   文字列と言えば必ずメモリに確保した一種類の型であるのだから、
  |   C++ においても外部の関数に渡すときぐらいは、
  |   その必然性が無くても新しくメモリに格納してもよいだろう。
  |
  |
  |   この場合には strbase<> 側に c_str 的な関数を用意する必要がある。
  |
  |   | struct _tmp_cstr{
  |   |   std::unique_ptr<const char[]> data;
  |   | public:
  |   |   operator const char*() const;
  |   | };
  |   | struct strbase{
  |   |   _tmp_cstr c_str() const;
  |   | };
  |
  | c adapter_traits を使って何でも受け取れる様にする
  |
  |   | template<typename S>
  |   | typename stdm::enable_if<mwg::as_str<S>::value,void>::type f(S const&);
  |
  |   戻り値に char_type などを使いたければ、単純に
  |
  |   | template<typename S>
  |   | typename mwg::as_str<S>::char_type f(S const&);
  |
  |   等の様にすれば良い。
  |
  |   % [SFINAE が面倒になる問題(可能性)]
  |   %
  |   % しかし更に複雑なことをしようとすると以下の様に面倒な事になるかも知れない。
  |   %
  |   % | template<typename S,bool=mwg::as_str<S>::value>
  |   % | struct enabler{};
  |   % | template<typename S>
  |   % | struct enabler<S,true>:mwg::identity< 複雑な戻り値 >{};
  |   % | template<typename S>
  |   % | typename enabler<S>::type f(S const&);
  |   %
  |   % と思ったが、現実にこの様な面倒な指定をしなければならないのは、
  |   % "enabler を作りたい" という場合だけの様な気もしてきた。
  |   %
  |   % enabler を作る場合には、内部で return_type を構築する必要がある。
  |   % しかし内部で構築する場合には SFINAE が効かない。
  |   % つまり、戻り値の型が不正な形式になるとコンパイルエラーになる。
  |   % という事で、使えるかどうかの判定部分と、実際に戻り値の型を定義する部分を分離しなければならない。
  |   % しかして、上記の様に条件と戻り値の型の定義が分かれて面倒な事になるのである。
  |   %
  |   % さて enabler ではなくても上記の様な形式を取る必要がある場合も存在する。
  |   % つまり SFINAE が効かない様な内部で型の不整合が起こる場合である。
  |   %
  |   % | template<typename P>
  |   % | struct hoge{typedef hoge_return<typename P::char_type>::type type;};
  |   % | typename hoge<P>::type
  |   %
  |   % しかしこの様な場合については hoge 側で防御をするべきである。
  |   %
  |   % [結論]
  |   % - enabler を作りたいという場合には、条件と戻り値の型を分離する必要があり面倒である
  |   % - 通常の SFINAE ならば問題ないはずである。
  |   %   呼び出した別のテンプレート内でエラーが起こるのであれば、それはそのテンプレート側で防御をするべきである。
  |
  |   [条件判定用クラスの名称]
  |   mwg::string3_detail::adapter_traits は如何にも長いのでより短くて分かりやすい名前を考えたい。
  |   例えば
  |   - adapter_traits<S>::available    → mwg::as_str<S>::value
  |   - adapter_traits<S>::adapter_type → mwg::as_str<S>::adapter
  |       これの使い方は決まって typename mwg::as_str<S>::adapter str(s) である。
  |       もっと短い書き方はない物だろうか。
  |
  |       % 実は auto str = make_str(s); でいける様な気もする。
  |       % が、auto で受け取ると _strtmp も固定する事ができてしまったりして
  |       % 初期化できてしまったりして問題が多い気がする。
  |       % といって、ユーザに使用の制限を呼びかけたとしても通じるか分からない。
  |       %
  |       % やはり標準的な使い方は adapter str(s); であろう。
  |
  |   - adapter_traits<S>::char_type → mwg::as_str<S>::char_type
  |
  |   また、他に追加するとすれば:
  |   - typename mwg::as_str<S>::const_iterator
  |
  |   % [mwg::str として受け取ると文字操作が面倒な可能性]
  |   %
  |   % 何でも受け取れる代わりに操作は限られる。ランダムアクセスできない。
  |   % mbcs の効率を考えれば iterator を使って実装しなければならないので面倒。
  |   %
  |   % それならばいっその事 c_str にでも変換してから処理した方が良い?
  |   % →×でも mbcs の場合には単に c_str にするだけだと結局処理が難しいから、
  |   %     効率良く処理する為には wint_t 配列などにしなければならない。
  |   %     そして const wint_t* の様な物を標準の交換形式にするのは考えがたい。
  |   %
  |   % 逆に言えば mbcs の処理も考えるのであれば iterator にならざるを得ず、
  |   % もしそうだとするならば strbase<> に変換して処理するのは必然である。
  |   % なので、これは別に気にすることではない。
  |   %
  |   % [結論]
  |   % - mbcs の処理効率を考えるのだとすれば iterator を使って実装するのは当然である。
  |   %   寧ろ面倒でもそれを強要する形になるのでよい。
  |   % - ランダムアクセスを用いてより効率の良い処理をしたい場合もあるが、
  |   %   それは元々、既定の実装をした後で、別に実装するべきものである。
  |
  | d strbase<> と後は stradp を受け取れる様にしておく。
  |
  |   | template<typename P> void f(strbase<P> const& str);
  |   | void f(stradp<char> const& str){return f(static_cast<strbase<mwg::strsub_policy> >(str));}
  |
  |   或いは、strbase const& strbase::to_base() const; 等という関数を定義しておけば、
  |
  |   | template<typename P> void f(strbase<P> const& str);
  |   | void f(stradp<char> const& str){return f(str.to_base());}
  |
  |   とすれば良い。
  |
  |   これは結構良さそうにも思うが、実際にやってみようとすると結構面倒だと分かった。
  |   何が面倒かというと
  |   1. 複数の引数があると 2 の累乗で定義するべきオーバーロードが増える。
  |   2. 複雑な SFINAE がある場合に、何度も同じ様な SFINAE を書くのは綺麗ではない。
  |     enabler にまとめようとすると、
  |     今度は a の所で述べたような面倒(というか見にくいコード)が発生する。
  |
  |   とにかくこの方法は良い方法だとは思えない。

  結論としては、
  - mbcs 対応や効率を考えるのであれば adapter を用いる方法 c を使う。
  - 次点として b の const XCH* で実装する方法を用いる。
    結局これが一般的なインターフェイスであるから。
    但し、c_str() を呼び出す様にするのを忘れないこと。

    (あと、c_str() は未だ実装していなかった…→これは別項目で考察する)

  これで d の様な stradp を使用する可能性は殆どなくなった。
  従って、stradp を内部オブジェクトに変更する事にする。
  また、a もしくは d の様な物を補正しない限りは strbase を使用しないので、
  strbase は今迄通り公開しなくても良い?
  →と思ったが、独自に新しい文字列型を実装する場合には strbase を使用する。
    従ってやはり strbase は公開した方が良いのではないか?
    これについては独立した項目を立てて考察する。

* string: mwg::make_str()

  わざわざ std::stradp<char> などの様に文字の型を指定しなくても、
  自然な文字の型を推論する事ができる筈である。

  これの実装に伴い adapter_traits を拡張して
  必ずしも stradp を adapter としなければならない訳ではない様にする。
  今後 adapter_traits は以下の3つを提供する。

  - adapter_traits::available    文字列(mwg::string)に変換可能か
  - adapter_traits::char_type    文字列(mwg::string)の要素の型
  - adapter_traits::adapter_type 文字列(mwg::string)の型(アダプタ文字列型)

  この変更により既存の使用箇所で不整合が起こっている可能性がある。
  > adapter_enabler の使用箇所を確認・修正
  > 特に stradp のコンストラクタの SFINAE に注意する。

  > adapter_traits に str 自身を定義する。strbase_tag を使用

  - stradp の SFINAE チェックが複雑になっている。
    stradp を private な目的のクラスにすればこのチェックは省略できる。
    stradp を内部使用のクラスにするかどうかについては、
    これについては新しく項目を立てる事にする。

* string: range_replace_enabler の switch を廃止する。
  switch 毎に処理を変えられる様にはしたが実際に処理は同じになっている様だ。

2016-03-02

* string._strtmp_sub_policy: reset_index は問題である

  reset_index することによって外から見た時の index を修正することができる様になったが、
  よく考えてみたら index が内部で使用する為に使われている物だとしたら、
  それを勝手に変更すると元文字列の内部の参照位置も影響を受けてしまう。
  つまり勝手に外部から書き換えて良い物とは限らない筈である。

  幸いに、reset_index を使用しているのは未だ _strtmp_sub_policy のみである。

  [index() の意義]

  修正を行う前に改めて何故 index が必要だったのかについて確認を行う。

  元々は _strtmp_map_policy で現在位置を把握する為に必要であった。
  もしこれだけであるならば _strtmp_map_policy の内部で index を保持すればよい。
  公開する必要はない。しかし、iterator の効率を考えると、
  各操作レベルで独立に index を管理するのは好ましくない。
  例えば、
    a.tolower().toupper().tolower()
  について const_iterator を ++ すると、
  3階層でそれぞれ定義された 3 つの index を increment する事になる。無駄な処理である。
  従って下の階層で index が既に定義されている場合にはそれを流用するという工夫が考えられる。

  では _strtmp_sub_policy の様に index にずれが生じる場合にはどの様にすれば良いのか。
  例えば、

    a.tolower().slice(1,3)

  の様な場合である。

  a この場合には、そもそも slice は index を必要としない。
    従って、_strtmp_sub_policy では has_index な const_iterator を用意しない、
    というのが一つの解である。しかしながら、更に処理を行って

      a.tolower().slice(1,3).tolower()

    等の様にした場合に、結局 index をもう一つ追加することになる。

  b もし slice が下層の index を利用して index を提供していれば、
    最上層の tolower の際に新しい index を提供する必要はなくなる。

    ここで特に、

      第三層::index = 第二層::index = 第一層::index + start

    となるので、最上層の処理で使用する index() は毎回加算 index+start
    を実行することになる。このコストについては留意する。
    一方で第二層が index を用意しなかった場合には、
    このコストが発生しない代わりにもう一つの新しい index を管理し、
    それを increment するコストが発生する。

    一方で、もし 第二層::index を参照しないのであれば、
    (この方法では) 特に特別な処理を行わなくても済むので、
    オーバーヘッドは全くない。

    と思ったが、const_iterator に offset を覚えておかなければならないので、
    それを記録する分だけ const_iterator のサイズが大きくなる。

  これはどちらの方が良いとも言い難い。
  今回は slice 層での index を実装しかけたのであるから、
  取り敢えず b の方針を考えてみる。

* string: class や struct の使用がまちまちである。

  現在の実装では class や struct が入り乱れている。
  取り敢えず、次のように使い分けを行う事にする。

  struct
    - POD な構造体
    - traits, policy などの定義用クラス
    - tag, enabler などのオーバーロード選択用クラス
    - interface

  class
    - 詳細な実装を含むクラス。特にメンバを持つ物

  これに従うと、buffer_type や const_iterator は
  struct ではなくて class であるべきだ。
  現在は大体 struct になっているのでこれらを class に書き換える。

2016-03-01

* string: trim, rtrim で j-1, --j と同じ操作を2回行っている。
  1回だけしか行わないように修正できないか?

  a const_iterator に default constructor を要求する。
    一時変数として jtmp を作って、jtmp=j-1 とする。
    後で j=jtmp とする。

    | const_iterator jtmp;
    | while(j!=i&&_f::invoke(pred,*(jtmp=j-1)))j=jtmp;

    毎回 jtmp -> j にコピーして書き込む作業が必要になる。
    また jtmp=j-1 で新しい領域にコピーする手間もある。
    更に const_iterator たちに default constructor を用意する必要もある。

  b 一時変数として const_iterator jtmp(j); とする。
    *--j 後に戻す必要が有れば j=jtmp とする。

    | while(j!=i){
    |   const_iterator jtmp(j);
    |   if(!_f::invoke(pred,*--j)){j=jtmp;break;}
    | }

    毎回コピー構築を行う。最後に一回だけ戻す。

  c そもそも一時変数に覚えて置かなくても、必要になった時に再計算すれば良い

    | while(j!=i)if(!_f::invoke(pred,*--j)){++j;break;}

    increment に関してはどの文字コードでもコストは小さいと思われる。
    毎回コピーをしなくて済むので嬉しい。実装も簡潔である。

2016-02-23

* [2011-10-26] mwg::string 構成

  mwg::string_impl1::stringbase<XCH,Alloc>
    全ての文字列クラスの基底クラス。
    基本的な非破壊的操作関数を備える。

  mwg::string_impl1::string<XCH>
    固定文字列。データを他の文字列と共有しうる。

  mwg::string_impl1::strsub<XCH>
    他の文字列、データに対する部分文字列を表現するクラス。

  mwg::string_impl1::stradp<XCH>
    アダプタ。実質的に strsub と等価。
    唯一違う点は様々なクラスインスタンスから implicit に構築できる事。
    文字列の類を受け取る関数の引数の型などに用いるのが目的。

  mwg::string_impl1::strbuff<XCH>
    編集用の文字列。参照の複製はされない。

  mwg::string_impl1::strsymb<XCH>
    インスタンスの単一性を保証するクラス
    等値比較が、ポインタを比較するだけで済むので楽。
    比較的長い文字列で同じ物が沢山現れる場合にはメモリの節約にもなるかも。

    クラス名に関しては一考の余地有り。
    ruby では symbol と呼ばれている物である。

  mwg::string_impl1::strsymb_dictionary<XCH>
    strsymb の親クラス。
    存在しているインスタンス全てをこの中に保持して管理する。
    デフォルトでグローバルに使用できるインスタンスを生成するが、
    ローカルに使いたいシンボル群を管理する為に、自分でインスタンスを生成する事も可能にする。

    内部構造は取り敢えず std::map (sorted list) で二分探索。
    将来的には trie を考えても OK

  mwg::string_impl1::strpath<XCH>
    ファイル名を管理する為の文字列

* [2011-10-26] mwg::string 実装方法

  現在の試行実装について。

    以前に少しだけ試しに実装してみて放置してあるコードについて再度整理してみる。
    先ず、この実装では各文字列クラスは基底クラス strbase から派生する。
    strbase では c_str 関数及び length 関数を抽象関数とする。
    そして c_str 及び length の戻り値に対して様々な操作を提供する。
    これによって各派生クラスは c_str 及び length 関数の実装だけに注力すれば良い事になる。
    様々な文字列に対する操作は基底クラスである strbase のレベルで提供されているからである。

    特に strbase に必要な c_str 及び length は、
    仮想関数の仕組みではなくてテンプレートによる特殊化によって実装する。
    strbase の第一テンプレート引数は単体の文字の型 (char や wchar_t など) であり、
    strbase の第二テンプレート引数が各特殊化の詳細を決める traits
    (c_str や length の実装を含む) となっている。

  c_str 関数について

    c_str という関数名は std::string の時と同様に null 終端文字列を返す事を想定させる。
    この関数の戻り値は const char* であり、それをそのまま C の通常の文字列処理の関数に渡す事ができるという事である。
    しかし、クラスによっては const char* を構築するのが容易でない場合がある。
    例えば部分文字列 strsub の場合には、既に存在している文字列の一部分を保持する物である。
    その参照先は一般に null 終端であるとは限らない。
    既に存在している文字列を勝手に書き換える事は出来ないから、
    c_str の戻り値として適切な文字列を用意する為には、
    新しく領域を確保してそこに参照先の内容をコピーして返す必要がある。
    他にも concat_string など temporary object として用意する文字列クラスでも、
    一々メモリを確保して連続メモリとして c_str の結果を用意する訳にはいかない。
    元々、concat_string などの temporary object を生成するのは、
    そういったメモリの確保を省略して、最終結果を構築する時までメモリの確保を遅延させる為である。
    この目的を達成する為に必要なのは、文字列の任意の位置の文字を取得する事であり、
    c_str 及び length 関数ではない。

    つまり必要なのは

    | interface{
    |   const char* c_str() const;
    |   std::size_t length() const;
    | }

    ではなく、

    | interface{
    |   [必須]
    |   char get_ch(int index) const;
    |   std::size_t length() const;
    | }

    である。API として c_str 等の関数が欲しいと思う事もあると思うが、
    それを用意するのは各種特殊化されたクラスの中ではなく、
    共通処理を提供する strbase の方である。

  以下特殊化の時のインターフェイスについて考察。

    | interface{
    |   [必須]
    |   char get_ch(int index) const;
    |   std::size_t length() const;
    |
    |   // c_str
    |   [必須] static const bool has_c_str;
    |   [選択] const char* c_str() const;
    |   /* 既定では get_ch の返す文字を反映して新しい文字列を構築して返す。
    |    * 直接 C 言語で使う事の出来る文字列バッファを内部に持っている場合には
    |    * わざわざコピーをしなくてもそのバッファのポインタを返せばよい。
    |    */
    |
    |   //---------------------------------------------------------------------------
    |   // 文字列比較?
    |   [選択]
    |   const_iterator begin(int index=0) const;
    |   /* これは順番に文字列を辿りながら処理をする時に必要である。
    |    * 例えば比較演算などの場合。
    |    * 例えば concat_string の場合、毎回 get_ch を用いて文字を読み出すと、
    |    * 毎回文字がどの部分文字列にいるかを判定する必要があるが、
    |    * 連続に文字を触る事が分かっていればそれらの判定を省略できる可能性がある。
    |    */
    |
    |   //---------------------------------------------------------------------------
    |   // 文字列比較?
    |   [選択 (既定の実装を提供)]
    |   void read(char* buff,std::size_t startIndex,std::size_t readLength) const;
    |   /* この関数は効率的にデータをコピーする為に必要である。
    |    * 例えば、或る程度長い文字列をコピーする場合には、
    |    * for ループで位置を回しながら get_ch を使って文字を読み出すより、
    |    * CPU の string 命令でデータをコピーしてしまった方が良い。
    |    *
    |    * そう言った処理ができない文字列の場合には、
    |    * 単に内部で for()get_ch のループを回せばよい。
    |    * この既定の動作は既定で準備しておいて、必要に応じて override する形が良い。
    |    */
    | }

    因みに。何故初めの実装で c_str/length というインターフェイスにしたか。
    →これは、既存ライブラリの文字列クラスが多くの場合、連続した領域に文字列を持っているからである。
    つまり c_str/length というインターフェイスを採用しておけば、
    他の既存ライブラリの文字列と簡単に共存できると考えたからである。
    しかし、concat_string 等を用いて文字列処理を高速化しようと考えたのにこれでは意味がなかった。

  まとめ

    次の実装では特殊化で提供するのは基本的に
      get_ch と length,
      必要に応じて iterator や read 関数を実装、
    という形にする。

  実装の形態についてより詳しく

    a. strbase から各クラスに派生
      + strbase の機能を拡張する形で文字列クラスを作成
      + 一番自然に思い付く方法
      + ○特別なコンストラクタの定義が容易
    b. strbase のテンプレート引数で詳細を指定。
      + strbase が実際の実装になる。
      + 実装する上でテンプレート引数に指定した情報を用いる。
      + std::basic_stream と std::streambuf の関係に近い。
    c. strbase の基底クラスとして使用
      + 拡張の関数などは基底クラスから使う。
      + ×strbase と同じ関数名で overload を作ろうと思っても隠蔽されてしまう
        + strbase を書き換えて using を使えば良さそうな気もするが、
        + 一つ一つの派生クラスに応じて using を追加していくのはありえない。
      + ×特別なコンストラクタの定義が難しい

  結局上記の物を組み合わせるのが一番現実的である様に思う。

* [2011-10-26] mwg::string 実装2

  namespace mwg::string_detail2 内に試験的に実装。

  > stradp
  > 比較
    > 関係演算子
    - starts_with(str)
    - ends_with(str)
    - starts_with(pat)
    - ends_with(pat)
    - match(pat)
    - match(pat)
  - 文字置換
    - replace(char_type, char_type)
    - tolower
    - toupper

* [2012-11-13] mwg::string 実装3

  関数名や構成などを考え直して再度実装する。

2015-10-19

* tuple vc10bug

  例によって vc2010 で tuple のコンパイルが通らない。

  > 先ず左辺値参照の場合でも変な所で一時オブジェクトが新しく作成されてしまう様なのでポインタに変換して保持
    (lvalue_reference_wrapper) する事にした。

    % そもそも何故 vc で左辺値も lvalue_reference_wrapper を使って実装する様に変更したのか?
    % →これは右辺値参照の時と同様に以下のエラーが出たからである。
    %   reference member is initialized to a temporary that doesn't persist after the constructor exits
    %   例えば const int& を int& で初期化すると新しい一時オブジェクトが生成されて
    %   その一時オブジェクトに対するポインタが代入されてしまう。

  > 特殊化の選択に失敗する。仕方がないので default template parameter についても特殊化で明示的に指定する。

  これでコンパイルが通る様になったが依然として結果が変である。

  > std::move が怪しい? → ここは問題なかった。

    stdm::move の中でキャストを実行しているが CV をつけたり型を変更したりといった事は何もしていないので
    一時オブジェクトが勝手に作られてしまうという事がないようである。

  どうも _get の中でアドレスが変化している様子である。どうやら

    (value_type&&)(複雑な式)

  の形でキャストすると (複雑な式) の型が value_type& であったとしても一時オブジェクトが生成される様である。
  一旦変数に代入してからキャストすれば問題ないようだ。

    value_type& ref=複雑な式;
    static_cast<value_type&&>(ref) // OK

2015-10-15

* tuple 再設計

  やはり tuple の default constructor がないのは問題である。
  is_default_constructible を使って default constructor を on/off したい。
  しかし単純な SFINAE を使う事は出来ないので構造を変える必要がある。

  構造を変える必要があるのでそれに応じて get<>() も再実装する必要がある。
  再実装しなければならない物について整理を行う。
  基本的には m_valueK を参照している箇所を書き換えれば良いはずである。
  - tuple 本体は勿論完全に書き直す。
  - get<>() は書き換える必要がある。
  - 他には m_valueK を参照している箇所はない。
  意外と compact な変更で良さそうである。

  さて default constructor をどの様に switch で実現するのか?
  これが普通のメンバ関数であれば、tuple を tuple_impl から派生する事にして、
  tuple_impl に余分なテンプレートパラメータ IsDefaultConstructible を用意する事で実現できる。
  しかしながら、default constructor の場合は基本クラスに用意しても仕方がない。
  一番最後のクラスに用意する必要がある。
  結局、tuple 自体に新しいテンプレートパラメータ bool IsDefaultConstructible を用意するしかないのか?

  > 1 get_head, get_rest を作る。
  >   1.1 戻り値の型の決定
  >     これは今迄の実装に用いた物をできるだけ流用する。
  >   1.2 実装
  >     これは単に static_cast を行うだけで良いだろう。
  >
  >   疑問点: 本当に get_head, get_rest は必要なのか?
  >     実はそのままアクセスするだけで良いような気がする…。
  >     というか、元々その様になる様に get の戻り値が設計されたのではないか?
  >
  >     get_head/get_rest の特殊化を作成する事で他の型からも初期化できるようになるとも考えたが、
  >     他の型について必ずしも get_rest に対応する物を正しく実装できるか分からない。
  >     結局個別の実装になってしまうのだとしたら、直接 m_head, m_rest を触っても問題ないのではないだろうか。
  >
  >   →取り敢えず廃止する事にした。
  >
  > 2 取り敢えずは今迄にあった機能だけを追実装する。
  >   > 1.1 多分取り敢えずは実装完了した。
  >   1.2 tuple<T> と tuple<T,U...> で似たコードが二つになっているので統合する。
  >
  > 3 get を実装する。
  > 4 従来の tuple を置き換える
  >   これは意外とすんなりとできた。問題は殆ど置きていない。

  今迄 default constructor がないことによって省略していたテストも通る様になった。
  しかし今迄に気付いていなかった問題点も浮上した。C++03 において
    template<typename T> void f(T mwg_forward_rvalue arg){}
  が完全転送の代替になっていないという事である。mwg_forward_rvalue は const & に展開される。

  const & は左辺値も右辺値も受け取ることができる。C++11 で move を特別扱いし C++03 では単純に値として使いたいときに使える。
  しかし左辺値性および右辺値性を保持して完全転送をしたい場合には使えない。

  この問題点については当初 mwg_forward_rvalue を実装したときには気付いていたが
  その後ですっかり忘れていたという様な気がする。
  というか思い出した。一つの実装でどちらも受け取れるということは左辺値ならではの処理はしないはずだから、
  左辺値を左辺値として受け取る必要はないと判断したように思う。
  しかしこの考え方は誤っている。転送するということは転送先の overload を正しく選択するということである。
  当然左辺値参照の overload と(右辺値参照の代替としての)const参照の overload を両方正しく処理できる必要がある。

  左辺値と右辺値を区別して転送するには結局 T& と T const& の両方について overload する必要がある。
  しかし転送対象の引数の数が増えてくると overload の数が爆発的に増えるので現実的でない。
  何らかの工夫が必要である。改めて可能性を洗う。template の overload resolution で T を推論させる必要があるので、
  引数の型はかなり絞られる。T, T const, T&, T const& 程度しか考えられない。
  あらゆる物から変換可能な型を用意して type erasure すれば動的に受け取った型を区別できるが、
  静的な overload の選択ができなくなる。というか、引数一つ受け取るのに virtual なオブジェクトを構築するのもおかしい。
  区別は書き換え可能 (T&) と書き換え不可能 (T const&, T const, T) の二種類である。
  今したいのは一つの定義で全てを受け取りつつ上記を区別することである。
  T& と T const& を overload として用意すれば丁度両者を区別できる。
  例えば T& だけを用意すると T& と T const& はまとめて受け取れて区別できるが T, T const を受け取れない。
  或いは T だけを用意すると全て受け取れるが区別できない上に参照渡しではなくコピーが発生し極めて効率が悪い。

2015-09-22

* mwg/xprintf.h: VC10 のバグを回避する様にしたら今度は gcc-3.4.6 で通らなくなった。

  配列の参照を変数なしに配列の参照に変換できない (実際何も変換しないはずなのだが)。不思議だ。

  参照: /note/20150923.gcc3bug.array_pointer_dereference.cpp

  &pre(!cpp){
  // gcc-3 で以下がコンパイルできない
  // a.cpp: In function `const char (& f1(const char (*)[2]))[2]':
  // a.cpp:5: error: invalid initialization of non-const reference of type 'const char (&)[2]' from a temporary of type 'const char*'
  typedef const char (&return_type)[2];
  return_type f1(const char (*p)[2]){
    return return_type(*p);
  }

  // 以下はコンパイルできる
  return_type f2(const char (*p)[2]){
    return_type ret(*p);
    return ret;
  }
  }

  色々試したがなかなかうまく行かない。
  &pre(!cpp,title=うまく行かなかったコード){
  #if defined(MWGCONF_GCC_VER)&&(MWGCONF_GCC_VER<40000)
    // gcc-3 では &配列 とすると配列へのポインタではなく
    // 先頭要素へのポインタになってしまう?
    // 結果として (value_type*)(&t.m_valueK) に失敗する。
    //
    // 本当か? 本当に (value_type*) で失敗しているのか? 実は R() に失敗しているのではないか?
    template<typename T>
    struct array_reference_wrapper{};
    template<typename T,std::size_t N>
    struct array_reference_wrapper<T[N]>{
      T* data;
      array_reference_wrapper(T* _data):data(_data){}
      T (*operator&() const)[N]{return reinterpret_cast<T(*)[N]>(data);}
    };
    template<typename T,std::size_t N>
    struct element_traits<T(&)[N]>{
      typedef array_reference_wrapper<T[N]> stored_type;
    };
  #endif
  }
  &pre(!cpp,title=うまく行かなかったコード2){
  template<typename T>
  struct element_traits{
    typedef T stored_type;
    template<typename R,typename Store>
    static R ref(Store mwg_forward_rvalue store){
      typedef typename remove_reference<R>::type value_type;
      return R(*(value_type*)&store);
    }
  }
  template<typename R,typename TT>
  struct tuple_get_impl<K,R,TT>{
    static R _get(TT t){
      typedef typename stdm::remove_cv<typename stdm::remove_reference<TT>::type>::type tuple_type;
      typedef tuple_detail::element_traits<typename tuple_element<K,tuple_type>::type> traits;
      return traits::template ref<R>(t.m_valueK);
    }
  };
  }

  VC 対応の為に拡張したコードを、古い拡張性のないコードに戻したら通る。
  仕方がないので VC 対応の為に拡張したコードは VC のみで使う事にする。

* mwg/xprintf.h, mwg/std/tuple: VC 2010 のバグで tuple が動かないので tuple を修正する事にする。

  tuple に右辺値参照を記録すると勝手に一時オブジェクトに複製されて、
  その一時オブジェクトに対する参照にすりかえられてしまう。
  →仕様がないので tuple で右辺値参照を記録する時はポインタに変換して記録する事にした。

  それでも未だ動作がおかしい。タイミングによって勝手にコピーされたりされなかったりする。
  →良く分からないが int&& の変数を int const&& に変換する等と言った操作の際に、
    新しく局所的に一時変数を作成してそれへのポインタを返している様に見える。
    これをポインタに変換してから返す様にしたら引数が一個の場合には問題なく動くようになった。

  しかし引数が複数ある場合には未だ動かない。
  引数が一個しかない場合にはちゃんと元々のポインタの値が保持されているが、
  引数が四個の場合を見てみると変な所をポインタが指しているという事が分かった。
  % →どうやらこれは tuple の move constructor でメンバ毎に get(move(rhs)) して渡しているのが行けなかった様だ。
  %   単純な get にしたところ何も起こらない様だ。しかしそれで良いのかというのはまた疑問である。
  %   例えばこの様に成っている場合 tuple<int&> で tuple<int&&> を初期化できてしまうのではないだろうか。
  %   或いは tuple<int&&> で tuple<int&&> を move construct する事ができない。
  やはり関係ない。単純に (get(rhs)) にしても同様に問題は発生している。
  というか印刷して試してみた所そもそも move constructor や copy constructor は呼び出されていない。
  (テストの為に一旦変数に代入した時に move/copy constructor が呼ばれただけの様だ。)

  forward_as_tuple で受け取った引数は大丈夫である。
  forward_as_tuple の戻り値で駄目である。
  次に forward_as_tuple 内で tuple<...> を構築するが、
  その tuple コンストラクタが受け取った値は誤っている様だ。
  forward に失敗しているという事だろうか。
  戻り値としてではなく、一旦変数として構築する場合にはコンストラクタには正しい値が渡される。

  うーん。return 式の中で構築すると駄目なのだろうか??
  →return 上で構築するのを止めるだけで期待通りに動いている。
    何故この様な事になるのか分からないが取り敢えず動いているので良しとする。
  →結局変数を伴わないコンストラクタ呼出の内、引数が二つ以上ある物で再現する様だ。

  ○参考: note/20150922.vcbug.rvalue_member_cannot_be_initialized_properly.cpp

  以下 (上からの引用) の4パターンのそれぞれで右辺値参照がずれる事が確認された:

  > - 変数に bind するとアドレスが変化する。
  > - reinterpret_cast<T&&>() するとアドレスが変化する。
  > - 右辺値参照メンバを初期化するとアドレスが変化する。
  > - (1) 複数の引数を持つ (2) コンストラクタを (3) 変数を伴わない部分式から 呼び出すと引数のアドレスが変化する。

* mcxx msc install cxxar を張り間違えている。

* mwg/xprintf.h: テンプレート明示的実体化

  今迄使っていた実体化が VC2010 のバグでエラーになって動かないので、
  改めて整理して使いやすくすることを試みる。
  クラスを通じて間接的に呼び出したりする事で、一度に複数のクラスの実体化をできるのではないかと
  思ったがなかなかうまく行かない。結局の所、手で指定した物しか実体化は保証されず、
  そこから呼び出される別の関数や別のクラスについては実体化されるかもしれないという程度の気がする。
  幸いクラスのメンバ関数だけはまとめて実体化する事が可能であるので、これを用いて実装し直す事にする。

  以下は試行錯誤の末に書いて消した物である。

  % template<typename Buff>
  % struct _instantiate_basic_convert{
  %   static void _call(Buff& buff,fmtspec const& spec){
  %     //
  %     // ここで呼び出すだけで本当にインスタンス化されるのだろうか?
  %     //
  %     // - 各関数の定義は既に与えられているので実体化可能である。
  %     //   またテンプレート関数が別の翻訳単位で実体化されるかどうか何も仮定できないので、
  %     //   ここで実体化しないと最終的にリンク時に失敗する事になる。
  %     //   従って、ここで必ず実体化されるはずである。
  %     //
  %     // - 但し、インライン化されてシンボルが割り当てられない可能性もある?
  %     //
  %     basic_convert_impl<Buff>::convert_integer(buff,spec,mwg::u8t(),bool(),int());
  %     basic_convert_impl<Buff>::convert_floating_point(buff,spec,double());
  %     basic_convert_impl<Buff>::convert_string(buff,spec,"",std::size_t());
  %   }
  % };
  %
  % // 以下どの様な条件で実体化されるか不明
  %
  % template<template<typename Buff> class InstantiateForWriter>
  % struct _instantiate_for_writers:
  %   InstantiateForWriter<xprintf_writer>,
  %   InstantiateForWriter<empty_writer>,
  %   InstantiateForWriter<cfile_writer>,
  %   InstantiateForWriter<ostream_writer>,
  %   InstantiateForWriter<string_writer>{};
  %
  % template<typename T>
  % struct _simple_xprintf_convert{
  %   template<typename Buff>
  %   struct _instantiate{
  %     static void _call(xprintf_writer& buff,fmtspec const& spec,T const& value){
  %       xprintf_convert(buff,spec,value,adl_helper());
  %     }
  %   };
  % };
  %
  % // template class _instantiate_for_writers<_simple_xprintf_convert<T>::_instantiate>;

2015-09-20

* mwg/xprintf.h: bugfix, C++11 で mwg::xputf の戻り値が構築できない。

  戻り値で受け取った tuple をコピーしようとしていたが、
  g++-4.9.2 の C++11 で tuple<int&&> はコピー不可能になる?
  "implicitly deleted because the default definition would be ill-formed"
  等と文句を言って tuple はコピーできない様である。

  仕方がないので tuple を受け取る vxputf に関しては
  Tuple const& で tuple を保持し、
  xputf に関してはその場で tuple を構築する事にして我慢する。

  →参照としてのコピーができる tuple として packed_forward<Args...> を定義した。
  更に、pack_forward 関数を定義して std::forward と同じように呼び出して、
  packed_forward<> を得られる様にした。
  現在の所コンパイルは通っているし期待通りに動いている。

  以下は関連して解決したと見做す。

  > 2015-09-18
  >
  > * mwg/xprintf: mwg::vararg::pack_forward の存在意義に疑問
  >
  >   | pack_forward
  >   |
  >   |   以下のようにして引数を捕まえるのに使う。
  >   |     void func(Args&&... _args){
  >   |       std::tuple<Args&&...> args=pack_forward<Args...>(_args...);
  >   |     }
  >   |   類似のものに std::forward_as_tuple があるがこれは使いづらい。というのも、
  >   |     void func(Args&&... _args){
  >   |       std::tuple<Args&&...> args=std::forward_as_tuple(std::forward<Args>(_args)...);
  >   |     }
  >   |   としなければならないからである。あるいは、pack_forward は
  >   |     std::forward_as_tuple(std::forward<Args>(_args)...)
  >   |   を組み合わせた物と考えれば良い。
  >
  >   上記の記述は本当だろうか? 勿論 forward_as_tuple(...) とはできないけれども、
  >   forward_as_tuple<Types...>() の様な使い方はできるのではないかという気がする。
  >
  >   また、現在の実装で pack_forward<XArgs...,YArgs...>(yargs...) となっているのは、
  >   yargs から xargs に変換できるかどうかのチェックをするためである。
  >   単純な forward_as_tuple の場合はそのチェックがないので面倒なテンプレートのエラーが発生する。
  >   しかし、今回想定している使い方の範囲内では必ず yargs → XArgs に変換出来るはずである。
  >
  >   やはり std::forward_as_tuple で駄目な理由が分からなくなった…。
  >   試しに forward_as_tuple に切り替えて見る。
  >   実際に試してみた所、以下の様になった:
  >
  >   | void func(Args&&... _args){
  >   |   std::forward_as_tuple<Args...>(_args...); // NG: 当然だが int&& arg1; の arg1 は左辺値なので (int&& param1) に渡せない。
  >   |   std::forward_as_tuple<Args...>(std::forward<Args>(_args)...); // OK
  >   |   std::forward_as_tuple(std::forward<Args>(_args)...); // OK: でも上の様に書くぐらいならば下の様に書けば良い。
  >   | }
  >
  >   結局、std::forward_as_tuple(std::forward<Args>(_args)...) と書かなければならないのが面倒だから、
  >   pack_forward という関数を作ったという解釈で良いという事である。
  >   序でに空の forward_as_tuple が許されるのかを確かめる。
  >
  > * mwg/xprintf.h: pack_forward 廃止??

* mwg/xprintf.h: interface について

  現在の interface は以下の関数である:

  - xprintf(target,fmt,args);
  - vxprintf(target,fmt,args);
  - sprintf(fmt,args);
  - vsprintf(fmt,args);

  [問題点] sprintf/vsprintf は std::sprintf/std::vsprintf を隠蔽する。

  つまり mwg 名前空間内では std:: を省略できないこと。
  更に両関数の引数が互いに可換な状況があるので using std::sprintf もできない。

  - ADL が働いて ::sprintf を呼んでいる積もりで
    mwg::sprintf が呼び出されてしまう可能性がある。
    (::sprintf は基本型しか受け取らない筈だが…例えば書き込み先に
    operator char*() をメンバ関数として持つ型を指定する場合など?)

  - 更に namespace mwg 内部で使っているから mwg::sprintf が呼び出されていると
    思っていたら #include <mwg/xprintf.h> を忘れていた所為で
    ::sprintf() の方が呼び出されるという危険性もある。

  - 他の人が使おうとした時にバグを生む可能性がある。
    特に初心者向けの文書での習慣である using namespace
    を使うものだと考えている人は多い。

  常に完全修飾名で指定すれば良いという考え方もあるが、気を抜くと忘れかねない。
  以上の理由から、一般的に std:: 名前空間内部の物と同じ名前は使わない方が良い。

  [計画] 同時に interface も改良したい。

  | 以下の様な使い方ができる様にしたい:
  |
  |   std::cout << mwg::xprintf(fmt,...);
  |   stdout << mwg::xprintf(fmt,...);
  |
  |   std::string line( mwg::xprintf(...) );
  |   line << mwg::xprintf(fmt,...);
  |   ilne = mwg::xprintf(fmt,...);
  |
  |   mwg::xprintf().str()
  |
  | でもこの interface だと出力&出力文字数取得ができない…。
  |
  |   std::tie(std::cout,count) << mwg::xprintf(fmt,...);
  |   if((std::tie(std::cout,count) << mwg::xprintf(fmt,...)).second == 0) ...;
  |
  | だと如何にも煩雑である。といって、
  |
  |   if(mwg::xprintf(fmt,...).write(std::cout) == 0)
  |
  | というのも分かりにくい。やはり従来型の interface も同時に提供するべきだろうか。
  | そうすると mwg::xprintf の関数名は従来型の interface に使用したい。
  | 新しい << による interface の関数名をどうするかが問題になる。
  | 下手に *printf などだと従来型の使い方を想像してしまうかもしれない。
  | といって全然違う関数名にすると printf にするよりは気分的に抵抗が生じる。
  |
  | 或いは、ostream 的に << で使えるという事から関数名を決められないか。
  | → boost::format は元々知っていたが、どうやら std::putf という名前で標準化の
  | 提案が為されている様である。これが標準化されるかどうかはさておきこの真似で
  |
  |   mwg::xputf
  |
  | という関数名で実装するというのが良さそうである。

  以下の interface で作る事にする:

  1 xprintf, vxprintf はそのまま。

    特に std::string に出力する時の文字列は xprintf 側でクリアする様に変更する。
    → create_xprintf_writer の第二引数に指定する様に変更した。

  2 xputf, vxputf という関数を作成して以下の使い方ができる様にする:

    std::cout << mwg::xputf(...);
    stdout << mwg::xputf(...);
    std::string() << mwg::xputf(...);

    →実装した。チェックした。

    std::string(mwg::xputf(...));
    mwg::xputf(...).str();
    mwg::xputf(...).count();

    →実装した。チェックした。

  3 sprintf/vsprintf は削除する。

  gcc のバグやら色々面倒な事はあったがどうやら終わった。

  以下は関連して解決した物である:

  > 2015-09-18
  >
  > * mwg/xprintf.h: mwg::xprintf(std::string); // 追記になっているが sprintf 等を考えると分かりにくい
  > * mwg/xprintf.h: その他の型 ... ostringstream << を用いた実装。


* mwg/xprintf.h (_vxputf_temporary_object): g++-3.4.6 friend が効かない?

  参考: libmwg/note/20150920.g++-3.4.6-bug.copyctor_required_for_cref.cpp

  色々調べた結果、コピーを禁止すると g++-3.4.6 で以下が通らないという事が分かった:

  class A{
    A(A const&){}
  public:
    A(){}
  };
  void proc(A const&){}
  void test(){proc(A());}

  proc は参照として A インスタンスを受け取ろうとしているのに、
  実際にはコピーをしようとして失敗している様子である。
  g++-3.3.6 ではコンパイルが通る。g++-2.95 でもコンパイルが通る。

  仕様がないので適当な gcc の version の範囲で constructor たちを public にする事にした。

* mwg/xprintf.h: experimental から移動

* mwg/std/type_traits

  TR1 Header からの対応がかなり不完全になっている。
  現在では TR1 Header がある場合の実装と、何もない場合の実装を別々に (ファイルの前半と後半に) 記述している。
  各クラスについて TR1 Header があるかどうかで実装を切り替える様にしないと見通しが悪い。
  更に、現在どの機能が実装されていてどの機能が実装されていないのかも分かりにくい。
  これらについても整理しながら実装を行う必要がある。

  →整理を実行した。

2015-09-20 以前

* clang -std=c++0x から GCC 4.4.7 libstdc++ を使った時の問題

  std::move が壊れているために、それを使っている std::swap や std::vector などまでも
  全てエラーに成ってしまうので救いようがない。

  また type_info が前方宣言されていないのに typeinfo の先頭で使おうとしているので
  それでもエラーに成ってしまう。これについては一応 type_info を自分で前方宣言すれば良いが…。

  これはサポートの対象外とすることにする(そもそもヘッダファイルを include しようとするだけで死ぬ)。
  workaround のために書いたコードは削除することにする。以下に残しておく。

  // from mwg/defs.h
  //------------------------------------------------------------------------------
  // clang -std=c++0x: #include <typeinfo> (gcc 4.4.7 libstdc++) がエラーになる。
  // 内部で更に呼び出したヘッダで type_info* を使っているため。
  //?mconf X -t'"std::type_info sane?"' -oMWGCONF_STD_TYPE_INFO_SANE typeinfo 'const std::type_info* ptr=0;'
  #if !defined(MWGCONF_STD_TYPE_INFO_SANE)
  namespace std{
    class type_info;
    class bad_cast;
    class bad_typeid;
  }
  #endif

  // from mwg/std/utlility
  //-----------------------------------------------------------------------------
  // clang -std=c++0x: gcc 4.4.7 libstdc++ bug workaround
  // c.f. http://lists.cs.uiuc.edu/pipermail/cfe-dev/2011-February/013216.html
  //?mconf X -t'"std::move sane?"' -oMWGCONF_STD_MOVE_SANE utlility 'int j=std::move(i)';
  # ifndef MWGCONF_STD_MOVE_SANE
  #  include <type_traits>
  namespace mwg{
  namespace stdm{
    template<typename T>
    T& move(const T& value){return const_cast<T&>(value);}
    template<typename T>
    typename enable_if<!is_const<T>::value,T&>::type
    move(T& value){return value;}

    template<typename T>
    void swap(T& a,T& b){
      T tmp(move(a));
      a=move(b);
      b=move(tmp);
    }
  }
  }
  # endif

2015-04-28

*目標: 新しいビルド管理システム

  > ***ソースコード埋め込み指定
  >
  > 以下に挙げるような様々な機能を\
  > ソースコード中に埋め込んだ指定から呼び出せる様にする。
  > - configure script (mcxx)
  > - document (lwiki)
  > - preprocess (mwg_pp.awk)
  > - check (mwg_pp.awk sub)
  >
  > 処理の手順
  > 1. mwg_pp.awk による処理
  > 2. perl による処理
  >    (lwiki 部分なども mwg_pp.txt によって生成したくなるだろうから)
  >
  > ***出力に関して
  >
  > - 出力は別のディレクトリに対して行う様にしたい
  > - ソースファイル、ヘッダファイルの文字コード変換に対応する。
  >   original の文字コードも選択できる様にする。
  > - コンパイラの種類毎の出力に対応する。
  >   コンパイラのオプション毎の出力にも対応する。
  >   mcxx の機構を使用している場合 CXXFLAGS CFLAGS 等の設定に対応した設定を行うのが難しい。
  >
  > out/src.charset
  > out/cxxprefix.option/obj
  > out/cxxprefix.option/lib
  > out/cxxprefix.option/include
  >
  > ***その他の機能
  > wx-config 的なコマンドで cxxflags 等の必要な設定を呼び出す方法も提供する
  > 簡単なプロジェクトの初期化スクリプトも用意する
  > インストール・アンインストールの対応

  取り敢えず試しに実装を行ってみる。

  このビルド管理システムでは src に置いたソースコードを起点として、
  out ディレクトリに加工したソースコード・オブジェクトファイル・結果ファイルを出力する。

  現在以下のシーケンスが用意されている。

    src/dir/file.cpp

    → mwg_pp.awk による前処理

    out/src.utf-8/dir/file.cpp

    → make_extract.pl による lwiki, mconf の抽出

    out/src.utf-8/dir%file_cpp.lwiki
    out/src.utf-8/dir%file_cpp.mconf


2015-05-15

* 問題点: Makefile 起動が遅い

  -そもそもパス区切に % を用いているのが良くない?
    % はワイルドカードである。パターンマッチングが実行されている。
    →ファイル名中の % を + に変更してみたがそんなに時間は変わらない気がする。

  -原因が分からないので問題になっている Makefile を少しずつ弄って確かめる
   先ずは all に登録されている prerequisites を空にする。
   1.374s → 1.092s まで下がった。依存性の確認に 220ms かかっている事になる。
   次に生成コマンドを全て削除する。1.092 → 1.088 全然変わらない。誤差の範囲内である。
   つまり生成コマンドの登録はゼロコストである。
   今度は hoge+= となっている物を全て削除する。
   1.090s → 0.819s になった。72項目で 0.270ms かかっていた事になる。
   変数の = を := に変えたら旧に滅茶苦茶速くなった…。
   どうやら CPPPREFIX=$(shell $(MWGCXX) +prefix) が登場した回数だけ評価されていた事による様だ…。

  結局、原因は $(shell ) の展開が毎回行われていた事に依る物と分かった。

* 問題点: 各ファイルの config 条件と更新時刻

  現在は config 関係を以下のように処理している。
  1 各ファイルに config の条件を定義してファイルが更新される度にテストを実行する。
  2 全ファイルの結果を一つのファイル mwg_config.h に結合して出力する

  依存関係の問題

  しかしこの様にすると問題なのは、全てのファイルが
  基本的に mwg_config.h を include しているという事である。
  ファイルの依存性はコンパイラオプションの -M で追跡しているので、
  mwg_config.h を更新すれば全てをコンパイルし直す羽目になる。
  つまり、全てのファイルが他の全てのファイルに依存しているという状態になるという事である。

  a 解決方法の一つは、各ファイル毎に config ファイルを生成するという事である。
    しかしこれは煩雑になる。特に最終的な結果として install する場合に沢山の環境依存ヘッダがあるのは気になる。

  b 或いは、設計中は各ファイル毎の config を使うとして install する時にはそれらを結合した物を使うという手もある。
    でも恐らく今迄の自分の使い方だと、最終的に install する段階よりも書きながら使う場合の方が多い。
    できれば普段使っている段階でも config が一つに纏まった状態で取り扱いたい。

  c もう一つの方法は出力する config の内容を記録しておいて内容に変化があった場合にのみ、
    mwg_config.h を更新するという方法である。しかしこの方法も微妙である。
    config 指定さえ弄らなければ全体をコンパイルし直す事にはならないが、
    config 指定を弄った時に結局全体のコンパイルをやり直さなければならなくなる。
    これは従来の autotools でも同じ事であるが、今回はファイル毎に指定できるようにしたので
    config 指定の依存関係が明らかであり、この事を利用して必要な物だけコンパイルする様にしたい。

  d gmake の機能で良さそうな物はないだろうか。
    どうやら A: B | C とすると C の存在だけ確認をしてタイムスタンプの比較は行わない様だ。
    然し乍ら、上記の様にルールを書き換える為には g++ -M で出力した依存性ファイルを書き換える必要がある。
    (例えば sed -i '
      s/\(^\|[[:space:]]\{1,\})mwg_config.h\([[:space:]]\{1,\}\|$\)//
      s/[^\]$/& | mwg_config.h/
    ' x.dep)
    実行するコマンドが増加するので余りこれを採用したくはない。
    また Makefile の記述が複雑になる。特にユーザ側で特別に何か記述したい時に問題になる。
    が取り敢えず第一候補である。

  e touch mwg_config.h
    これで mwg_config.h の日付が更新前と比べて変化しないようにする…。
    余り良い方法ではないかも知れないがコスト的にこれが一番楽である。

* 疑問: Makefile: タイムスタンプを見ない依存関係?

  例えば、A: X としたいが
  - X が存在しない時は X を生成するコマンドを実行し A 更新も行う。
  - X が存在する時はそのファイル時刻に関係なく A 更新は行わない。

  .SECONDARY: X 等とすると
  - A が(X 以外の依存関係に対して)最新で、X が存在しなければ何もしない
  - X が存在する時はそのファイル時刻を見て必要が有れば A 更新を行う
  の様になる。似たような特別ターゲットが存在するのでは? → 探したがない気がする。
  ファイル更新時刻を無視するという機能自体が存在しない様に思われる。

  https://lists.gnu.org/archive/html/help-gnu-utils/2007-08/msg00016.html
  にも似たような質問が投稿されている。
  一つの解決方法は、A 生成の中で X の存在の確認をして X の生成も行うという物。
  もう一つの解決方法は、A の依存関係のリストを X の存在・非存在で切り替わる様に書くという物。
  後者は興味深い方法ではあるが今回の場合には使えない。

  https://lists.gnu.org/archive/html/help-gnu-utils/2006-02/msg00034.html
  に似たような質問が投稿されている。
  order-only prerequisites として登録しろという返答が為されている。
  A: | X
  # # でもこれだと X も要求しなければ X を生成するコマンド自体が実行されないのではないか。。
  # と思ったが、Makefile の解説を読んだ所 X が存在しなければちゃんと X 生成も行われる様だ。
  # 但し、X の生成が行われた後に A の更新は実行されない。。

  まとめ:

  A: | X の場合
  - Xが存在しない場合: X が生成される。Aの更新は要求しない。
  - Xが存在して A よりも新しい場合、A は更新されない。

  .SECONDARY: X
  A: | X の場合
  - Xが存在しない場合: Aが最新でない場合 X を更新してから A を更新する。
  - Xが存在して A よりも新しい場合、何も起きない。

  .SECONDARY: X
  X:
  A: | X の場合
  - Xが存在しない場合: 何もしない
  - Xが存在して A よりも新しい場合、A を更新する。

* Makefile: 複数のファイルを生成するコマンドの管理の方法

  複数のコマンドを生成する場合

  > [[GNU Makefile rule generating a few targets from a single source file - Stack Overflow>http://stackoverflow.com/questions/2973445/gnu-makefile-rule-generating-a-few-targets-from-a-single-source-file]]
  >
  > | B1 B2: A1
  > | 	command B1 B2 < A1
  >
  > 上記の様にするとコマンドが 2 回実行されて無駄である。
  > その上 -j4 などで並列化するとコマンドが同時に起動されて出力が変になる。
  > 以下のようにする解決方法が提示されている。
  >
  > | B1: A1
  > |   command B1 B2 < A1
  > | B2: B1 A1
  >
  > 上の様にしていると、B1 の方が後に生成された場合に毎回 B2 を更新しようとするのでは?
  > と思ったが、実際に試してみると Nothing to be done となる。
  > つまり、更新用のコマンドが設定されていない場合にはファイルが存在する事だけを確認する様だ。
  >
  > また、A1 が更新された時に B2 が更新されないのではないかという懸念がある。
  > →試してみたら更新されないではないか。。
  > というか B1 A1 が存在しているだけで B2 も完了している様に見受けられる。
  > つまりこの方法は B1 が最新版であれば必ず B2 も最新版である事が保証されている場合にのみ有効である。
  >

  もっと複雑な場合はどうするか?

  現在の状況は以下の様な物である。
  - B1 も B2 も同時に生成される。
  - B1 は環境変数依存のファイル名である。B2 は環境変数に依存しない。
  - 環境変数が変化した時に B2 は既に最新版だが、B1 は未だ生成されていない(or最新版でない)という状況がある。
  - B2 に依存するルールが大量にあるのでできるだけ B2 は更新したくない。

  更新が発生するのは以下の状況のどちらかである。
  +環境変数が変更された事により B1 の更新が必要になる。
  +A1 が変更された事により B1 と B2 の両方の更新が必要になる。

  何れにしても B1 は必ず更新されるのであるから、今回の場合には
  | B2: B1
  等としておけば良いのではないだろうか。そして B1 のルールの方では
  | B1: A1
  |   command B1 B2.tmp < A1
  |   [[ B2 -nt A1 ]] || mv B2.tmp B1.tmp
  等のようにする。

  # B1: A1
  #   command B1 /dev/null < A1
  # B2: A1
  #   command /dev/null B2 < A1
  #
  # B1: A1
  #   command B1.tmp B2.tmp < A1
  #   [[ B1 -nt A1 ]] || mv B1.tmp B1
  #   -rm -rf B1.tmp B2.tmp
  # B2: A1
  #   command B1.tmp B2.tmp < A1
  #   [[ B2 -nt A1 ]] || mv B2.tmp B2
  #   -rm -rf B1.tmp B2.tmp

