<?xml version="1.0" encoding="utf-8"?>
<html>
<head>
  <title>mwtfile implementation memo</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <style type="text/css">
  h1{background-color:gray;color:white;padding:.5ex;text-align:center;}
  h2{border-width:3px 0px;border-style:double;border-color:gray;padding:.2ex 1ex;}
  h3{border-left:2ex solid #e66;padding-left:.5ex;}
  p{text-indent:1em;}
  p.marked{text-indent:0px;}
  </style>
</head>
<body>
<h1>Mwtfile Format Exp2</h1>
<p>茗荷樹帳形式 (Myoga Tree file format) version Exp2 の実装についてのメモ</p>
<h2>過去の考察</h2>
<h3>ポインタ実体の記録位置</h3>
<p class="marked">※ 茲での「ポインタ」とは、ファイル内のデータの場所を示す {開始点,長さ} の構造体である。</p>
<p>現在の実装ではデータの書き換えに伴ってポインタも書き換えなければならない。
従って、データを開いている時にポインタの位置を変更する事が出来ない。</p>
<ul>
<li>つまりもし親ノードのデータに直接ポインタを記録すると、
  データを開いている時に、親ノードを変更する事が出来ないという事である。</li>
<li>或いは、ポインタはポインタ一覧表に書く事にして、
  親ノードなどからの参照は全て一覧表の中の番号で参照する事にする。
  また、ポインタは存命中は一覧表中での位置変更は一切行わない事にする。
  <ul>
  <li>× この様にすると、一旦大量にポインタを生成してからポインタを削除した後に、
    ポインタ一覧表の長さが長いままになってしまう可能性が残る。
    然し、それは仕様がない。一度でも沢山ポインタを作ったのであればそれ位のデータの余裕はある筈。</li>
  <li>→ 但し、それならば、再度ポインタを整理し直すデフラグ的な操作も実装すると良い。
    この操作は、mwt ファイル内のあらゆるポインタを全て列挙する事が出来れば簡単である。
    (或いは、内部構造を一旦別の .mwt にコピーするようにするだけでも良い。) ■TODO■</li>
  </ul>
</li>
</ul>
<h3>MiniFAT データ: fat256/dat256 stream に分けるべきかまとめるべきか</h3>
<p>纏めた場合の方が楽かも知れない。以下、纏める事の利点と欠点。</p>
<ul>
<li>○ block の時と同様の実装を使用する事が出来る。
  或いは、block の実装のブロックサイズを変更するだけで対応する事が出来る。</li>
<li>○ 空きブロック探索のための「plane 毎の現在使用ブロック数」を自然に保持出来る。
  (block の実装では、自ブロックの nextBid を現在使用ブロック数の為に使用している)</li>
<li>× 分けていた方が、cid と dat256 stream 内の offset が連続していて楽である</li>
<li>○ 然し、分けていると空きブロックを探す際には、全ての cid を触らなければならない。
  その分、一つに纏めて自身の nextCid に現在の使用ブロック数を記録するようにすれば、
  空きブロック数がない Plane では、先頭の現在使用ブロック数だけを確認すればスキップする事が可能になる。</li>
<li>○ また、纏めた場合の方が block と実装が同じなので、仕様を記述する時に楽である。</li>
<li><del>CellSize が小さい時には、制御用の cell が沢山あって、サイズが無駄になる。</del>
  →でも良く考えたら二つにストリームを分けた場合でも使用するデータの量は同じである。</li>
<li><del>ストリームを一つに纏めると指示子とデータの間のシークが頻繁に起こるような錯覚</del>
  →これも、仮想的にストリームを分けた所で同様にシークが起こるのだから関係ない。</li>
</ul>
<p>結論: MiniFAT 用のデータは一つのストリームに纏めて管理する事に決定した。</p>

<h3>同時編輯・同期</h3>
<h4>没案</h4>
<p>中のノード・ストリームに関しては排他的にしか tape を初期化出来ない様にする。
.mwt ファイル自体は同時に色々な所から開けるようにする。
次の物の同期をちゃんとやっていれば安全である。</p>
<ul>
<li>ブロックの確保・解放</li>
<li>ノードを現在開いているかどうかのフラグ
既に書込中の場合→他から開くのは拒否
既に読み取り中の場合→読み取りに限り許可</li>
</ul>
<p class="marked">× 然し、良く考えてみたら、上だけでは駄目である。
多くのデータは minifat サブストリームの中に入っているし、
また、ノード一覧表自体もサブストリームの中に記述する事になっている。
と言う事は、サブストリーム自体が複数の色々な所からアクセス出来ないと、
結局 .mwt ファイル全体を触れない事になってしまう。</p>
<p class="marked">→ サブストリーム自体を複数の場所から同時に触る事ができるように、
同期の仕組みを作成する必要がある。</p>
<p class="marked">註) 本物のファイルシステムの場合には、OS の制御下でリアルモードで読み書きする為、
実質同期などの事は考えなくて良い。元々、OS レベルでの実装に親和性の高いシステムと言える。</p>

<h3>celltape/autotape: DataPtr write back</h3>
<p>現在の celltape/autotape のポインタ取得について</p>
<p>現在は、celltape/autotape 内のデータポインタを取得したい場合、
ptrDesc が delete 時に書き戻す様になっている事を利用している。</p>
<p>然し、tape を switch する場合などに delete の順番などを変に工夫して
実装していて見通しが悪い。
他にも、処理の途中で外部から ptr のデータ内容を知りたい事は沢山ありそうである。</p>
<p>それならば、変に ptrDesc を利用して書き戻さなくても、
外部から ptr の内容を参照出来るようなインターフェイスを用意して置いて、
管理している側でちゃんと ptr の内容を保存しておくようにした方が良い。
</p>
<h4>これで改善すると思われる場面</h4>
<ul>
<li>autotape 内での子 tape の switching</li>
<li>属性値ストリームの新規作成・switch</li>
<li>etc</li>
</ul>
<p>色々な物が実装しやすくなる事は確かと思われる。</p>
<h4>実装 [完]</h4>
<ol>
<li>先ず ptr を取得する為のインターフェイスを定義する。</li>
<li>celltape/autotape で実装する。</li>
<li>autotape をそれに対応した実装に変更する</li>
<li>動作確認・デバグ</li>
</ol>
</body>
</html>
