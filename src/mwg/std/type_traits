// -*- mode:C++;coding:utf-8 -*-
#ifndef MWG_STDM_TYPE_TRAITS
#define MWG_STDM_TYPE_TRAITS
#include <mwg/defs.h>
/*?mconf
 *
 * # C++11, C++TR1
 * H type_traits || H tr1/type_traits
 *
 * # include <type_traits> / <tr1/type_traits>
 * StandardHeaders=
 * [[ $MWGCONF_HEADER_TR1_TYPE_TRAITS ]] && StandardHeaders="$StandardHeaders tr1/type_traits"
 * [[ $MWGCONF_HEADER_TYPE_TRAITS     ]] && StandardHeaders="$StandardHeaders type_traits"
 * if [[ $StandardHeaders ]]; then
 *   if X -t'"TR1 in namespace std?"' -o - "$StandardHeaders" 'int a=std::is_same<int,int>::value;'; then
 *     Namespace=std
 *   else
 *     Namespace=std::tr1
 *   fi
 * fi
 *
 * # valid is_const
 * if [[ $StandardHeaders ]]; then
 *   HeaderInvalid=
 *
 *   if X - '' 'int&& a=1;'; then
 *     if ! X -t"(vcbug) $Namespace::is_const<int&&>::value" -o - "$StandardHeaders" "int a=$Namespace::is_const<int&&>::value;"; then
 *       D MWGCONF_INVALID_STD_IS_CONST 1
 *       HeaderInvalid=1
 *     fi
 *   fi
 *
 *   D MWGCONF_INVALID_HEADER_TYPE_TRAITS "$HeaderInvalid"
 * fi
 *
 * # is_convertible
 * if [[ $StandardHeaders ]]; then
 *   X add_lvalue_reference "$StandardHeaders" "typedef std::add_lvalue_reference<int>::type a;"
 *   X tr1_add_reference    "$StandardHeaders" "typedef std::tr1::add_reference<int>::type a;"
 *
 *   # libstdc++ の特定の version で is_convertible<int,void> が true となる。
 *   X valid_is_convertible "$StandardHeaders" 'int arr[!std::is_convertible<int,void>::value?1:-1];'
 * fi
 *
 * # is_constructible
 * if [[ $MWGCONF_HEADER_TYPE_TRAITS ]]; then
 *   # type_traits
 *   X is_constructible                   "$StandardHeaders" "int a=std::is_constructible<int,int>::value;"
 *   X is_trivially_constructible         "$StandardHeaders" "int a=std::is_trivially_constructible<int,int>::value;"
 *   X is_nothrow_constructible           "$StandardHeaders" "int a=std::is_nothrow_constructible<int,int>::value;"
 *   X is_default_constructible           "$StandardHeaders" "int a=std::is_default_constructible<int>::value;"
 *   X is_trivially_default_constructible "$StandardHeaders" "int a=std::is_trivially_default_constructible<int>::value;"
 *   X is_nothrow_default_constructible   "$StandardHeaders" "int a=std::is_nothrow_default_constructible<int>::value;"
 *   X is_copy_constructible              "$StandardHeaders" "int a=std::is_copy_constructible<int>::value;"
 *   X is_trivially_copy_constructible    "$StandardHeaders" "int a=std::is_trivially_copy_constructible<int>::value;"
 *   X is_nothrow_copy_constructible      "$StandardHeaders" "int a=std::is_nothrow_copy_constructible<int>::value;"
 *
 *   X is_assignable                      "$StandardHeaders" "int a=std::is_assignable<int,int>::value;"
 *   X is_trivially_assignable            "$StandardHeaders" "int a=std::is_trivially_assignable<int,int>::value;"
 *   X is_nothrow_assignable              "$StandardHeaders" "int a=std::is_nothrow_assignable<int,int>::value;"
 *   X is_copy_assignable                 "$StandardHeaders" "int a=std::is_copy_assignable<int>::value;"
 *   X is_trivially_copy_assignable       "$StandardHeaders" "int a=std::is_trivially_copy_assignable<int>::value;"
 *   X is_nothrow_copy_assignable         "$StandardHeaders" "int a=std::is_nothrow_copy_assignable<int>::value;"
 *
 *   X is_trivially_destructible          "$StandardHeaders" "int a=std::is_trivially_destructible<int>::value;"
 *   X has_virtual_destructor             "$StandardHeaders" "int a=std::has_virtual_destructor<int>::value;"
 * fi
 *
 */
#if MWGCONF_HEADER_STD>=2011&&!defined(MWGCONF_INVALID_HEADER_TYPE_TRAITS)
# include <type_traits>
#else
//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
#pragma%[ArN=10]
#pragma%x begin_check
#include <mwg/except.h>
#include <mwg/std/cstdint>
#include <mwg/std/type_traits>

enum E {};
struct S {};
struct T : public S {};
struct U : public T {};

#pragma%x end_check

// load TR1 library
#if MWGCONF_HEADER_STD>=2005
# include <type_traits>
# define MWG_STDM_TYPE_TRAITS_WithTr1Header
#elif defined(MWGCONF_HEADER_TR1)
# include <tr1/type_traits>
# define MWG_STDM_TYPE_TRAITS_WithTr1Header
#endif

#include <cstddef>
#include <mwg/concept.h>
#ifdef __clang__
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wbitwise-op-parentheses"
# pragma clang diagnostic ignored "-Wlogical-op-parentheses"
#endif

namespace mwg{
namespace stdm{

  //
  //  integral_constant
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::integral_constant;
  using ::std::tr1::true_type;
  using ::std::tr1::false_type;
#else
  template<typename T,T Value>
  struct integral_constant{
    static const T value=Value;
    typedef T value_type;
    typedef integral_constant<T,Value> type;
    mwg_constexpr operator value_type() const{return value;}
  };
  typedef integral_constant<bool,true> true_type;
  typedef integral_constant<bool,false> false_type;
#endif

  //
  // is_same
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_same;
#else
  template<typename T,typename U>
  struct is_same:false_type{};
  template<typename T>
  struct is_same<T,T>:true_type{};
#endif

  //
  // conditional
  //
  template<bool V,typename T,typename F> struct conditional:mwg::identity<F>{};
  template<typename T,typename F> struct conditional<true,T,F>:mwg::identity<T>{};

  //
  // enable_if
  //
  template<bool C,typename T=void> struct enable_if{};
  template<typename T> struct enable_if<true,T>:mwg::identity<T>{};

  //
  // alignment_of
  //
  template<typename T>
  struct alignment_of_impl{T mem1;char split;T mem2;};
  template<typename T>
  struct alignment_of:integral_constant<std::size_t,sizeof(alignment_of_impl<T>)-2*sizeof(T)>{};

  //===========================================================================
  //  type categories
  //---------------------------------------------------------------------------
  // + is_void @f
  // + is_reference
  // +   is_lvalue_reference
  // +   is_rvalue_reference
  // + is_function
  // + is_object
  // +   is_scalar
  // +     is_arithmetic @f
  // +       is_integral
  // +         is_signed
  // +         is_unsigned
  // +       is_floating_point
  // +     is_pointer
  // +     is_member_pointer
  // +       is_member_object_pointer
  // +       is_member_function_pointer
  // +     is_null_pointer @f (C++14)
  // +     is_enum
  // +   is_array
  // +   is_class
  // +   is_union
  //
  // + @f = is_fundamental
  // + !@f = is_compound
  //
  //---------------------------------------------------------------------------

  //
  // is_reference
  //   is_lvalue_reference
  //   is_rvalue_reference
  //
  template<typename T> struct is_lvalue_reference:false_type{};
  template<typename T> struct is_lvalue_reference<T&>:true_type{};
  template<typename T> struct is_rvalue_reference:false_type{};
# ifdef MWGCONF_STD_RVALUE_REFERENCES
  template<typename T> struct is_rvalue_reference<T&&>:true_type{};
# endif
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_reference;
#else
  template<typename T> struct is_reference
    :integral_constant<bool,is_lvalue_reference<T>::value||is_rvalue_reference<T>::value>{};
#endif

  //
  //  cv qualifiers
  //
  //    requires is_reference
  //
#if defined(MWG_STDM_TYPE_TRAITS_WithTr1Header)&&!defined(MWGCONF_INVALID_STD_IS_CONST)
  using ::std::tr1::is_const;
  using ::std::tr1::is_volatile;
  using ::std::tr1::add_const;
  using ::std::tr1::add_volatile;
  using ::std::tr1::add_cv;
  using ::std::tr1::remove_const;
  using ::std::tr1::remove_volatile;
  using ::std::tr1::remove_cv;
#else
  template<typename T>       struct is_const            :false_type{};
  template<typename T>       struct is_const<const T>   :true_type{};
  template<typename T>       struct is_const<const T[]> :true_type{};
  template<typename T,int N> struct is_const<const T[N]>:true_type{};

  template<typename T>       struct is_volatile               :false_type{};
  template<typename T>       struct is_volatile<volatile T>   :true_type{};
  template<typename T>       struct is_volatile<volatile T[]> :true_type{};
  template<typename T,int N> struct is_volatile<volatile T[N]>:true_type{};

  template<typename T> struct add_const:conditional<is_reference<T>::value,T,const T>{};
  template<typename T> struct add_volatile:conditional<is_reference<T>::value,T,volatile T>{};
  template<typename T> struct add_cv:add_const<typename add_volatile<T>::type>{};

  template<typename T>        struct remove_const             :mwg::identity<T>{};
  template<typename T>        struct remove_const<const T>    :mwg::identity<T>{};
  template<typename T>        struct remove_const<const T[]>  :mwg::identity<T[]>{};
  template<typename T,int N>  struct remove_const<const T[N]> :mwg::identity<T[N]>{};
  template<typename T>        struct remove_volatile                :mwg::identity<T>{};
  template<typename T>        struct remove_volatile<volatile T>    :mwg::identity<T>{};
  template<typename T>        struct remove_volatile<volatile T[]>  :mwg::identity<T[]>{};
  template<typename T,int N>  struct remove_volatile<volatile T[N]> :mwg::identity<T[N]>{};
  template<typename T>        struct remove_cv:remove_const<typename remove_volatile<T>::type>{};
#endif
#pragma%x begin_check

  void check_is_volatile(){
    mwg_check(!(mwg::stdm::is_volatile<int>::value));
    mwg_check(!(mwg::stdm::is_volatile<int const>::value));
    mwg_check( (mwg::stdm::is_volatile<int volatile>::value));
    mwg_check( (mwg::stdm::is_volatile<int volatile const>::value));
    mwg_check(!(mwg::stdm::is_volatile<int&>::value));
    mwg_check(!(mwg::stdm::is_volatile<int volatile&>::value));
#ifdef MWGCONF_STD_RVALUE_REFERENCES
    mwg_check(!(mwg::stdm::is_volatile<int&&>::value));
    mwg_check(!(mwg::stdm::is_volatile<int volatile&&>::value));
#endif
  }
  void check_remove_cv(){
    mwg_check(( mwg::stdm::is_same<int,mwg::stdm::remove_cv<const int>::type>::value));
    mwg_check(( mwg::stdm::is_same<int,mwg::stdm::remove_cv<volatile int>::type>::value));
    mwg_check(( mwg::stdm::is_same<int,mwg::stdm::remove_cv<const volatile int>::type>::value));
  }

#pragma%x end_check

  //
  // is_void
  //
  //  requires: remove_cv
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_void;
#else
  template<typename T> struct is_void:is_same<typename remove_cv<T>::type,void>{};
#endif

  //
  // remove_reference
  // add_lvalue_reference
  // add_rvalue_reference
  //
  //   requires: is_reference, is_void
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::remove_reference;
#else
  template<typename T> struct remove_reference:mwg::identity<T>{};
  template<typename T> struct remove_reference<T&>:mwg::identity<T>{};
# ifdef MWGCONF_STD_RVALUE_REFERENCES
  template<typename T> struct remove_reference<T&&>:mwg::identity<T>{};
# endif
#endif
#if (defined(MWG_STDM_TYPE_TRAITS_WithTr1Header) \
  &&defined(MWGCONF_HAS_TR1_ADD_REFERENCE))

# if !defined(MWGCONF_HAS_ADD_LVALUE_REFERENCE)
  // std::add_lvalue_reference が既に定義されている場合がある(?)
  template<typename T> struct add_lvalue_reference:std::tr1::add_reference<T>{};
# endif
#else
  namespace detail{
    template<typename T,bool B> struct add_lvalue_reference__impl:mwg::identity<T>{};
    template<typename T>        struct add_lvalue_reference__impl<T,true>:mwg::identity<T&>{};
# ifdef MWGCONF_STD_RVALUE_REFERENCES
    template<typename T,bool B> struct add_rvalue_reference__impl:mwg::identity<T>{};
    template<typename T>        struct add_rvalue_reference__impl<T,true>:mwg::identity<T&&>{};
# endif
  }
  // type category           lvalue rvalue
  // ----------------------- ------ ------
  // is_void                 void   void
  // is_reference            U&     T
  // is_function, is_object  T&     T&&
  template<typename T> struct add_lvalue_reference
    :detail::add_lvalue_reference__impl<typename remove_reference<T>::type,!is_void<T>::value>{};

# ifdef MWGCONF_STD_RVALUE_REFERENCES
  template<typename T> struct add_rvalue_reference
    :detail::add_rvalue_reference__impl<T,!is_reference<T>::value&&!is_void<T>::value>{};
# endif
#endif
#pragma%x begin_check

  void check_add_lvalue_reference(){
    mwg_check((mwg::stdm::is_same<void,mwg::stdm::add_lvalue_reference<void>::type>::value));
    mwg_check((mwg::stdm::is_same<int&,mwg::stdm::add_lvalue_reference<int>::type>::value));
    mwg_check((mwg::stdm::is_same<int&,mwg::stdm::add_lvalue_reference<int&>::type>::value));
#ifdef MWGCONF_STD_RVALUE_REFERENCES
    mwg_check((mwg::stdm::is_same<int&,mwg::stdm::add_lvalue_reference<int&&>::type>::value));

    mwg_check((mwg::stdm::is_same<void ,mwg::stdm::add_rvalue_reference<void>::type>::value));
    mwg_check((mwg::stdm::is_same<int&&,mwg::stdm::add_rvalue_reference<int>::type>::value));
    mwg_check((mwg::stdm::is_same<int& ,mwg::stdm::add_rvalue_reference<int&>::type>::value));
    mwg_check((mwg::stdm::is_same<int&&,mwg::stdm::add_rvalue_reference<int&&>::type>::value));
#endif
  }

#pragma%x end_check

  //
  // is_function
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_function;
#else
  namespace detail{
    template<typename T> struct is_function_impl:false_type{};

    // TODO:
    //    variadic template を使用した実装?
    //    C++11 の variadic template に対応しているのであれば、
    //    <type_traits> も既に用意されているべき?

//%x
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_/," )>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_,/" ...)>:true_type{};
//%end.f/_AR_/0/ArN+1/.i
#ifdef MWG_STD_GccCvQualifiedFunctionType
    // ※上の宣言と重複 ?
    // CHECK: const メンバ関数でも正しく判定されるかどうかを確認
//%x
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_/," ) const>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_,/" ...) const>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_/," ) volatile>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_,/" ...) volatile>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_/," ) const volatile>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_,/" ...) const volatile>:true_type{};
//%end.f/_AR_/0/ArN+1/.i
#endif
    template<typename T> struct is_function
      :is_function_impl<typename remove_cv<T>::type>{};
  }
  using detail::is_function;
#endif

  //
  // is_null_pointer
  //
  template<typename T> struct is_null_pointer:is_same<nullptr_t,typename remove_cv<T>::type>{};

  //
  // is_arithmetic
  //   is_floating_point
  //   is_integral
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_arithmetic;
  using ::std::tr1::is_floating_point;
  using ::std::tr1::is_integral;
#else
  namespace detail{
    template<typename T> struct is_integral_impl:false_type{};
    template<> struct is_integral_impl<char>              :true_type{};
    template<> struct is_integral_impl<unsigned char>     :true_type{};
    template<> struct is_integral_impl<signed char>       :true_type{};
    template<> struct is_integral_impl<short>             :true_type{};
    template<> struct is_integral_impl<unsigned short>    :true_type{};
    template<> struct is_integral_impl<int>               :true_type{};
    template<> struct is_integral_impl<unsigned int>      :true_type{};
    template<> struct is_integral_impl<long>              :true_type{};
    template<> struct is_integral_impl<unsigned long>     :true_type{};
# ifdef MWGCONF_HAS_LONGLONG
    template<> struct is_integral_impl<long long>         :true_type{};
    template<> struct is_integral_impl<unsigned long long>:true_type{};
# endif
# ifdef MWGCONF_HAS_DISTINCT_INT64
    template<> struct is_integral_impl<__int64>           :true_type{};
    template<> struct is_integral_impl<unsigned __int64>  :true_type{};
# endif
    template<> struct is_integral_impl<bool>              :true_type{};
# if defined(MSC_VER)
    // /Zc:wchar_t- オプションが指定されていると、
    // wchar_t は unsigned short の typedef になっている。
    // defined(_NATIVE_WCHAR_T_DEFINED) ならば wchar_t は独立の型。
    template<> struct is_integral_impl<__wchar_t>         :true_type{};
# else
    template<> struct is_integral_impl<wchar_t>           :true_type{};
# endif
# ifdef MWGCONF_STD_CHAR16_T
    template<> struct is_integral_impl<char16_t>          :true_type{};
# endif
# ifdef MWGCONF_STD_CHAR16_T
    template<> struct is_integral_impl<char32_t>          :true_type{};
# endif
    template<typename T>
    struct is_integral:is_integral_impl<typename remove_cv<T>::type>{};

    template<typename T>
    struct is_floating_point_impl:false_type{};
    template<> struct is_floating_point_impl<float>:true_type{};
    template<> struct is_floating_point_impl<double>:true_type{};
    template<> struct is_floating_point_impl<long double>:true_type{};
    template<typename T>
    struct is_floating_point:is_floating_point_impl<typename remove_cv<T>::type>{};
  }
  using detail::is_integral;
  using detail::is_floating_point;

  template<typename T>
  struct is_arithmetic
    :integral_constant<bool,is_integral<T>::value||is_floating_point<T>::value>{};
#endif
#pragma%x begin_check
  void check_is_integral(){
    mwg_check(( mwg::stdm::is_integral<char>::value));
    mwg_check(( mwg::stdm::is_integral<signed char>::value));
    mwg_check(( mwg::stdm::is_integral<unsigned char>::value));
    mwg_check(( mwg::stdm::is_integral<short>::value));
    mwg_check(( mwg::stdm::is_integral<unsigned short>::value));
    mwg_check(( mwg::stdm::is_integral<int>::value));
    mwg_check(( mwg::stdm::is_integral<unsigned int>::value));
    mwg_check(( mwg::stdm::is_integral<long>::value));
    mwg_check(( mwg::stdm::is_integral<unsigned long>::value));
#ifdef MWGCONF_HAS_LONGLONG
    mwg_check(( mwg::stdm::is_integral<long long>::value));
    mwg_check(( mwg::stdm::is_integral<unsigned long long>::value));
#endif
#ifdef MWGCONF_HAS_INT64
    mwg_check(( mwg::stdm::is_integral<__int64>::value));
    mwg_check(( mwg::stdm::is_integral<unsigned __int64>::value));
#endif
    mwg_check(( mwg::stdm::is_integral<bool>::value));
    mwg_check(( mwg::stdm::is_integral<wchar_t>::value));
#ifdef MWGCONF_STD_CHAR16_T
    mwg_check(( mwg::stdm::is_integral<char16_t>::value));
#endif
#ifdef MWGCONF_STD_CHAR32_T
    mwg_check(( mwg::stdm::is_integral<char32_t>::value));
#endif

    mwg_check(( mwg::stdm::is_integral<int>::value));
    mwg_check(( mwg::stdm::is_integral<const int>::value));
    mwg_check(( mwg::stdm::is_integral<volatile int>::value));
    mwg_check(( mwg::stdm::is_integral<const volatile int>::value));

    mwg_check((!mwg::stdm::is_integral<int&>::value));
#ifdef MWGCONF_STD_RVALUE_REFERENCES
    mwg_check((!mwg::stdm::is_integral<int&&>::value));
#endif

    mwg_check((!mwg::stdm::is_integral<float>::value));
    mwg_check((!mwg::stdm::is_integral<double>::value));
    mwg_check((!mwg::stdm::is_integral<long double>::value));
  }

  void check_is_floating_point(){
    mwg_check(( mwg::stdm::is_floating_point<float>::value));
    mwg_check(( mwg::stdm::is_floating_point<double>::value));
    mwg_check(( mwg::stdm::is_floating_point<long double>::value));

    mwg_check((!mwg::stdm::is_floating_point<double&>::value));
#ifdef MWGCONF_STD_RVALUE_REFERENCES
    mwg_check((!mwg::stdm::is_floating_point<double&&>::value));
#endif
    mwg_check((!mwg::stdm::is_floating_point<double*>::value));
  }

  void check_is_arithmetic(){
    mwg_check(( mwg::stdm::is_arithmetic<int>::value));
    mwg_check(( mwg::stdm::is_arithmetic<double>::value));
    mwg_check(( mwg::stdm::is_arithmetic<long double>::value));

    mwg_check((!mwg::stdm::is_arithmetic<int*>::value));
    mwg_check((!mwg::stdm::is_arithmetic<int&>::value));
    mwg_check((!mwg::stdm::is_arithmetic<double*>::value));
    mwg_check((!mwg::stdm::is_arithmetic<double&>::value));
#ifdef MWGCONF_STD_RVALUE_REFERENCES
    mwg_check((!mwg::stdm::is_arithmetic<int&&>::value));
    mwg_check((!mwg::stdm::is_arithmetic<double&&>::value));
#endif

    mwg_check((!mwg::stdm::is_arithmetic<U>::value));
    mwg_check((!mwg::stdm::is_arithmetic<U*>::value));
  }
#pragma%x end_check

  //
  //  is_signed
  //  is_unsigned
  //
  //  Note: std::tr1::is_signed/is_unsigned は使わない。
  //    tr1 の is_signed/is_unsigned は
  //    signed/unsigned char/short/int/long/long long/__int64 のみに対して true となった。
  //    しかし C++11 では浮動小数点数は signed になり、bool は unsigned になった。
  //    更に、char, char16_t, char32_t は実際の振る舞いに応じて signed/unsigned になる。
  //
  namespace detail{
    template<typename T,bool B=is_integral<T>::value> struct is_signed_nocv:false_type{};
    template<typename T,bool B=is_integral<T>::value> struct is_unsigned_nocv:false_type{};

    template<typename T> struct is_signed_nocv  <T,true>:integral_constant<bool,(T(-1)<T(0))>{};
    template<typename T> struct is_unsigned_nocv<T,true>:integral_constant<bool,(T(0)<T(-1))>{};

    // floating point numbers are signed
    template<> struct is_signed_nocv<float      ,false>:true_type{};
    template<> struct is_signed_nocv<double     ,false>:true_type{};
    template<> struct is_signed_nocv<long double,false>:true_type{};

    // bool is always unsigned
    template<> struct is_unsigned_nocv<bool          ,true>:true_type{};

    // signed/unsigned integers
    template<> struct is_signed_nocv  <signed char   ,true>:true_type{};
    template<> struct is_signed_nocv  <signed short  ,true>:true_type{};
    template<> struct is_signed_nocv  <signed int    ,true>:true_type{};
    template<> struct is_signed_nocv  <signed long   ,true>:true_type{};
    template<> struct is_unsigned_nocv<unsigned char ,true>:true_type{};
    template<> struct is_unsigned_nocv<unsigned short,true>:true_type{};
    template<> struct is_unsigned_nocv<unsigned int  ,true>:true_type{};
    template<> struct is_unsigned_nocv<unsigned long ,true>:true_type{};
# ifdef MWGCONF_HAS_LONGLONG
    template<> struct is_signed_nocv  <signed long long  ,true>:true_type{};
    template<> struct is_unsigned_nocv<unsigned long long,true>:true_type{};
# endif
# ifdef MWGCONF_HAS_DISTINCT_INT64
    template<> struct is_signed_nocv  <signed __int64  ,true>:true_type{};
    template<> struct is_unsigned_nocv<unsigned __int64,true>:true_type{};
# endif
  }
  template<typename T> struct is_signed  :detail::is_signed_nocv  <typename remove_cv<T>::type>{};
  template<typename T> struct is_unsigned:detail::is_unsigned_nocv<typename remove_cv<T>::type>{};
#pragma%x begin_check
  template<typename T>
  void check_is_signed__for_type(){
    mwg_check( (mwg::stdm::is_signed<T>::value==(mwg::stdm::is_arithmetic<T>::value&&(T(-1)<T(0)))));
    mwg_check( (mwg::stdm::is_unsigned<T>::value==(mwg::stdm::is_arithmetic<T>::value&&(T(0)<T(-1)))));
  }
  void check_is_signed(){
    check_is_signed__for_type<bool>();
    check_is_signed__for_type<char>();
    check_is_signed__for_type<signed>();
    check_is_signed__for_type<unsigned>();

    check_is_signed__for_type<float>();
    check_is_signed__for_type<double>();
    check_is_signed__for_type<long double>();

    mwg_check(( mwg::stdm::is_signed<int>::value));
    mwg_check(( mwg::stdm::is_signed<float>::value));
    mwg_check(( mwg::stdm::is_signed<double>::value));
    mwg_check(( mwg::stdm::is_signed<long double>::value));

    mwg_check(( mwg::stdm::is_signed<const int>::value));
    mwg_check(( mwg::stdm::is_signed<volatile double>::value));
    mwg_check(( mwg::stdm::is_signed<const volatile long double>::value));

    mwg_check((!mwg::stdm::is_signed<unsigned>::value));
    mwg_check((!mwg::stdm::is_signed<S>::value));
    mwg_check((!mwg::stdm::is_signed<T*>::value));

    mwg_check((!mwg::stdm::is_signed<int&>::value));
#ifdef MWGCONF_STD_RVALUE_REFERENCES
    mwg_check((!mwg::stdm::is_signed<double&&>::value));
#endif

    mwg_check(( mwg::stdm::is_unsigned<unsigned>::value));
    mwg_check(( mwg::stdm::is_unsigned<unsigned short>::value));
    mwg_check(( mwg::stdm::is_unsigned<unsigned char>::value));

    mwg_check(( mwg::stdm::is_unsigned<const unsigned>::value));
    mwg_check(( mwg::stdm::is_unsigned<volatile unsigned char>::value));
    mwg_check(( mwg::stdm::is_unsigned<const volatile unsigned short>::value));

    mwg_check((!mwg::stdm::is_unsigned<int>::value));
    mwg_check((!mwg::stdm::is_unsigned<double>::value));
    mwg_check((!mwg::stdm::is_unsigned<long double>::value));
  }
#pragma%x end_check

  //
  //  make_signed
  //  make_unsigned
  //
  template<typename T> struct make_signed:mwg::identity<T>{};
  template<typename T> struct make_signed<const T>
    :add_const<typename make_signed<typename remove_const<T>::type>::type>{};
  template<typename T> struct make_signed<volatile T>
    :add_volatile<typename make_signed<typename remove_volatile<T>::type>::type>{};

  template<typename T> struct make_unsigned:mwg::identity<T>{};
  template<typename T> struct make_unsigned<const T>
    :add_const<typename make_unsigned<typename remove_const<T>::type>::type>{};
  template<typename T> struct make_unsigned<volatile T>
    :add_volatile<typename make_unsigned<typename remove_volatile<T>::type>::type>{};

  template<> struct make_signed<         char> :mwg::identity<  signed char>{};
  template<> struct make_signed<unsigned char> :mwg::identity<  signed char>{};
  template<> struct make_unsigned<       char> :mwg::identity<unsigned char>{};
  template<> struct make_unsigned<signed char> :mwg::identity<unsigned char>{};
  template<> struct make_signed<unsigned short>:mwg::identity<  signed short>{};
  template<> struct make_unsigned<signed short>:mwg::identity<unsigned short>{};
  template<> struct make_signed<unsigned int>  :mwg::identity<  signed int>{};
  template<> struct make_unsigned<signed int>  :mwg::identity<unsigned int>{};
  template<> struct make_signed<unsigned long> :mwg::identity<  signed long>{};
  template<> struct make_unsigned<signed long> :mwg::identity<unsigned long>{};
# ifdef MWGCONF_HAS_LONGLONG
  template<> struct make_signed<unsigned long long>:mwg::identity<  signed long long>{};
  template<> struct make_unsigned<signed long long>:mwg::identity<unsigned long long>{};
# endif
# ifdef MWGCONF_HAS_DISTINCT_INT64
  template<> struct make_signed<unsigned __int64>:mwg::identity<  signed __int64>{};
  template<> struct make_unsigned<signed __int64>:mwg::identity<unsigned __int64>{};
# endif

  //
  // is_pointer
  //   add_pointer
  //   remove_pointer
  // is_member_pointer
  //   is_member_function_pointer
  //   is_member_object_pointer
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_pointer;
  using ::std::tr1::is_member_function_pointer;
  using ::std::tr1::is_member_object_pointer;
  using ::std::tr1::is_member_pointer;
  using ::std::tr1::add_pointer;
  using ::std::tr1::remove_pointer;
#else
  namespace detail{
    // is_member_function_pointer
    template<typename T> struct is_member_function_pointer_impl:false_type{};
#ifdef MWG_STD_GccCvQualifiedFunctionType
    template<typename C,typename S>
    struct is_member_function_pointer_impl<S C::*>:is_function<S>{};
#else
# if (MWGCONF_GCC_VER>=40200)
    /* 条件についてちゃんと調べる */
    template<typename C,typename S>
    struct is_member_function_pointer_impl<S C::*>:is_function<S>{};
# else
//%expand (
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for/_/0/_AR_/A_/," )>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for_sep/_/0/_AR_/A_/,"...)>:true_type{};
//%).f/_AR_/0/ArN+1/.i
# endif
//%expand (
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for/_/0/_AR_/A_/,") const>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for_sep/_/0/_AR_/A_/,"...) const>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for/_/0/_AR_/A_/,") volatile>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for_sep/_/0/_AR_/A_/,"...) volatile>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for/_/0/_AR_/A_/,") const volatile>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for_sep/_/0/_AR_/A_/,"...) const volatile>:true_type{};
//%).f/_AR_/0/ArN+1/.i
#endif
    template<typename T> struct is_member_function_pointer
      :is_member_function_pointer_impl<typename remove_cv<T>::type>{};

    // is_member_pointer
    template<typename T> struct is_member_pointer_impl:false_type{};
    template<typename C,typename T> struct is_member_pointer_impl<T C::*>:true_type{};
    template<typename T> struct is_member_pointer
      :integral_constant<bool,is_member_pointer_impl<typename remove_cv<T>::type>::value||is_member_function_pointer<T>::value>{};

    // is_member_object_pointer
    template<typename T> struct is_member_object_pointer
      :integral_constant<bool,is_member_pointer<T>::value&&!is_member_function_pointer<T>::value>{};

    // is_pointer
    template<typename T> struct is_pointer_impl:false_type{};
    template<typename T> struct is_pointer_impl<T*>
      :integral_constant<bool,!is_member_pointer<T>::value>{};
    template<typename T> struct is_pointer
      :is_pointer_impl<typename remove_cv<T>::type>{};

    // add_pointer, remove_pointer
    template<typename T> struct remove_pointer_impl:mwg::identity<T>{};
    template<typename T> struct remove_pointer_impl<T*>:mwg::identity<T>{};
    template<typename T> struct remove_pointer
      :remove_pointer_impl<typename remove_cv<T>::type>{};
    template<typename T> struct add_pointer
      :mwg::identity<typename remove_reference<T>::type*>{};

  }
  using detail::is_member_pointer;
  using detail::is_member_function_pointer;
  using detail::is_member_object_pointer;
  using detail::is_pointer;
  using detail::add_pointer;
  using detail::remove_pointer;
#endif
#pragma%x begin_check
  void check_is_member_pointer(){
    mwg_check(( mwg::stdm::is_member_function_pointer<int (S::*)(int)>::value));
    mwg_check(( mwg::stdm::is_member_function_pointer<int (S::*)(int) const>::value));
    mwg_check(( mwg::stdm::is_member_function_pointer<int (S::*)(int) volatile>::value));
    mwg_check(( mwg::stdm::is_member_function_pointer<int (S::*)(int) const volatile>::value));
    mwg_check(( mwg::stdm::is_member_pointer<int (S::*)(int)>::value));
    mwg_check(( mwg::stdm::is_member_pointer<int (S::*)(int) const>::value));
    mwg_check(( mwg::stdm::is_member_pointer<int (S::*)(int) volatile>::value));
    mwg_check(( mwg::stdm::is_member_pointer<int (S::*)(int) const volatile>::value));
  }
#pragma%x end_check

  //
  // is_array
  //   remove_extent
  //   remove_all_extents
  //   extent
  //   rank
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_array;
  using ::std::tr1::remove_extent;
  using ::std::tr1::remove_all_extents;
  using ::std::tr1::extent;
  using ::std::tr1::rank;
#else
  namespace detail{
    template<typename T>
    struct rank_impl:integral_constant<std::size_t,0>{};
    template<typename T,std::size_t N>
    struct rank_impl<T[N]>:integral_constant<std::size_t,rank_impl<T>::value+1>{};
    template<typename T>
    struct rank_impl<T[]>:integral_constant<std::size_t,rank_impl<T>::value+1>{};

    template<typename T,unsigned N>
    struct extent_impl:integral_constant<std::size_t,0>{};
    template<typename T>
    struct extent_impl<T[ ],0>:integral_constant<std::size_t,0>{};
    template<typename T,std::size_t X>
    struct extent_impl<T[X],0>:integral_constant<std::size_t,X>{};
    template<typename T,unsigned N>
    struct extent_impl<T[ ],N>:extent_impl<T,N-1>{};
    template<typename T,std::size_t X,unsigned N>
    struct extent_impl<T[X],N>:extent_impl<T,N-1>{};

    template<typename T>
    struct remove_extent_impl      :mwg::identity<T>{};
    template<typename T>
    struct remove_extent_impl<T[ ]>:mwg::identity<T>{};
    template<typename T,std::size_t X>
    struct remove_extent_impl<T[X]>:mwg::identity<T>{};
  }
  template<typename T>
  struct rank:detail::rank_impl<T>{};
  template<typename T>
  struct is_array:integral_constant<bool,detail::rank_impl<T>::value!=0>{};
  template<typename T,unsigned N=0>
  struct extent:detail::extent_impl<T,N>{};
  template<typename T>
  struct remove_extent:detail::remove_extent_impl<T>{};
  template<typename T>
  struct remove_all_extents:conditional<
    is_array<T>::value,
    remove_all_extents<typename detail::remove_extent_impl<T>::type >,
    mwg::identity<T> >::type{};
#endif

  //
  // is_class
  // is_union
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_union;
  using ::std::tr1::is_class;
#else
  namespace detail{
    template<typename T>
    mwg_concept_sfinae_typeOverload(is_class_or_union_impl,T,X,(void(X::*)(void)),(0));

    template<typename T>
    struct is_class_or_union
      :integral_constant<bool,is_class_or_union_impl<typename remove_cv<T>::type>::value>{};

  //?mconf X 'intrinsic __is_union' '' "int a=__is_union(int);"
# ifdef MWGCONF_HAS_INTRINSIC___IS_UNION
    template<typename T> struct is_union_nocv:integral_constant<bool,__is_union(T)>{};
# else
    template<typename T> struct is_union_nocv:false_type{};
# endif
    template<typename T> struct is_union:is_union_nocv<typename remove_cv<T>::type>{};

    template<typename T> struct is_class:integral_constant<bool,is_class_or_union<T>::value&&!is_union<T>::value>{};
  }
  using detail::is_union;
  using detail::is_class;
#endif

  //
  // is_base_of
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_base_of;
#else
# if defined(_MSC_VER)&&_MSC_FULL_VER>=140050215||MWGCONF_GCC_VER>=40300
  template<typename Base,typename Derived>
  struct is_base_of:integral_constant<bool,__is_base_of(Base,Derived)>{};
# elif defined(mwg_concept_is_valid_expression)
  template<typename From,typename To>
  struct is_base_of{
    template<typename T> static T expr();
    typedef typename remove_cv<From>::type* DD;
    typedef typename remove_cv<To>::type* BB;
    mwg_concept_is_valid_expression(mwg_is_convertible_to,DD,F,BB(expr<F>()));
    mwg_concept_condition(!is_void<To>::value&&mwg_is_convertible_to::value);
  };
# else
  //---------------------------------------------------------------------------
  // from boost/type_traits/is_base_of.hpp
  namespace detail{
    template<typename B,typename D>
    struct is_base_and_derived{
      mwg_concept_sfinae_param{
#  if defined(_MSC_VER)&&_MSC_VER==1310
        static mwg::concept_detail::true_t  eval(D const volatile*       ,long);
        static mwg::concept_detail::false_t eval(B const volatile* const&,int);
#  else
        template<typename T>
        static mwg::concept_detail::true_t  eval(D const volatile*,T);
        static mwg::concept_detail::false_t eval(B const volatile*,int);
#  endif
      };
      struct Host{
#  if defined(_MSC_VER)&&_MSC_VER==1310
        operator D const volatile*       ();
        operator B const volatile* const&() const;
#  else
        operator D const volatile*();
        operator B const volatile*() const;
#  endif
      };
      mwg_concept_condition(mwg_concept_bool_eval(sfinae_checker::eval(Host(),0)));
    };
  }
  template<typename Base,typename Derived>
  struct is_base_of:integral_constant<bool,is_same<Base,Derived>::value||mwg::stdm::detail::is_base_and_derived<Base,Derived>::value >{};
# endif
#endif
#pragma%x begin_check

  void check_is_base_of(){
    mwg_check(( mwg::stdm::is_base_of<S,U>::value));
    mwg_check(( mwg::stdm::is_base_of<S,T>::value));
    mwg_check(( mwg::stdm::is_base_of<T,T>::value));
    mwg_check((!mwg::stdm::is_base_of<U,S>::value));
    mwg_check((!mwg::stdm::is_base_of<T,S>::value));
  }

#pragma%x end_check

  //
  // is_convertible
  //
#if (defined(MWG_STDM_TYPE_TRAITS_WithTr1Header)&& \
  defined(MWGCONF_HAS_VALID_IS_CONVERTIBLE))
  using ::std::tr1::is_convertible;
#else
}
}
# include "type_traits.is_convertible.inl"
// the above include requires
//   is_void, is_base_of, is_same,
//   is_const, is_volatile, remove_cv.
namespace mwg{
namespace stdm{
#endif
#pragma%x begin_check
  //
  // check is_convertible
  //

  // test is_convertible for the case from values to references
  //  see also test/chk_cpp/stdlib11-is_convertible-check_def.cpp
  //
  // struct is_convertible_toref__test
  //   正しく判定できているかの判定用クラス。
  //   コンパイラ毎に正しい結果が異なるので、コンパイラ毎にテストを定義。
  template<typename F,typename T> struct is_convertible_toref__test{};
#ifdef _MSC_VER
  template<typename F,typename T> struct is_convertible_toref__test<F,T&>
    :mwg::stdm::integral_constant<bool,mwg::stdm::is_convertible<F,T&>::value==(mwg::stdm::is_const<T>::value&&(mwg::stdm::is_volatile<T>::value||!mwg::stdm::is_volatile<F>::value))>{};
#elif __INTEL_COMPILER
  // version によって異なる?
  template<typename F,typename T> struct is_convertible_toref__test<F,T&>
    :mwg::stdm::integral_constant<bool,
      mwg::stdm::is_convertible<F,T&>::value==(mwg::stdm::is_const<T>::value&&(!mwg::stdm::is_volatile<T>::value))||
      mwg::stdm::is_convertible<F,T&>::value==(mwg::stdm::is_const<T>::value&&(!mwg::stdm::is_volatile<T>::value&&!mwg::stdm::is_volatile<F>::value))>{};
#else
  template<typename F,typename T> struct is_convertible_toref__test<F,T&>
    :mwg::stdm::integral_constant<bool,mwg::stdm::is_convertible<F,T&>::value==(mwg::stdm::is_const<T>::value&&(!mwg::stdm::is_volatile<T>::value&&!mwg::stdm::is_volatile<F>::value))>{};
#endif
  void check_is_convertible__toref(){
    mwg_check((is_convertible_toref__test<int,int&>::value));
    mwg_check((is_convertible_toref__test<int,const int&>::value));
    mwg_check((is_convertible_toref__test<int,volatile int&>::value));
    mwg_check((is_convertible_toref__test<int,const volatile int&>::value));
    mwg_check((is_convertible_toref__test<const int,int&>::value));
    mwg_check((is_convertible_toref__test<const int,const int&>::value));
    mwg_check((is_convertible_toref__test<const int,volatile int&>::value));
    mwg_check((is_convertible_toref__test<const int,const volatile int&>::value));
    mwg_check((is_convertible_toref__test<volatile int,int&>::value));
    mwg_check((is_convertible_toref__test<volatile int,const int&>::value));
    mwg_check((is_convertible_toref__test<volatile int,volatile int&>::value));
    mwg_check((is_convertible_toref__test<volatile int,const volatile int&>::value));
    mwg_check((is_convertible_toref__test<const volatile int,int&>::value));
    mwg_check((is_convertible_toref__test<const volatile int,const int&>::value));
    mwg_check((is_convertible_toref__test<const volatile int,volatile int&>::value));
    mwg_check((is_convertible_toref__test<const volatile int,const volatile int&>::value));
  }

  void check_is_convertible(){
    mwg_check(( mwg::stdm::is_convertible<void,void>::value));
    mwg_check((!mwg::stdm::is_convertible<void,int>::value));
    mwg_check((!mwg::stdm::is_convertible<void,float>::value));
    mwg_check((!mwg::stdm::is_convertible<void,int*>::value));
    mwg_check((!mwg::stdm::is_convertible<void,int&>::value));
    mwg_check((!mwg::stdm::is_convertible<void,E>::value));
    mwg_check((!mwg::stdm::is_convertible<void,S>::value));
    mwg_check((!mwg::stdm::is_convertible<void,int[1]>::value));
    mwg_check((!mwg::stdm::is_convertible<void,int(int)>::value));
    mwg_check((!mwg::stdm::is_convertible<void,int(*)(int)>::value));
    mwg_check((!mwg::stdm::is_convertible<void,int(&)(int)>::value));
    mwg_check((!mwg::stdm::is_convertible<void,int S::*>::value));

    mwg_check((!mwg::stdm::is_convertible<int,void>::value));
    mwg_check(( mwg::stdm::is_convertible<int,mwg::i1t>::value));
    mwg_check(( mwg::stdm::is_convertible<int,mwg::u1t>::value));
    mwg_check(( mwg::stdm::is_convertible<int,int>::value));
    mwg_check(( mwg::stdm::is_convertible<int,unsigned>::value));
    mwg_check(( mwg::stdm::is_convertible<int,mwg::i8t>::value));
    mwg_check(( mwg::stdm::is_convertible<int,mwg::u8t>::value));
    mwg_check(( mwg::stdm::is_convertible<int,double>::value));

    mwg_check((!mwg::stdm::is_convertible<double,void>::value));
    mwg_check(( mwg::stdm::is_convertible<double,int>::value));
    mwg_check(( mwg::stdm::is_convertible<double,float>::value));
    mwg_check(( mwg::stdm::is_convertible<float,double>::value));
    mwg_check((!mwg::stdm::is_convertible<double,int*>::value));
    mwg_check((!mwg::stdm::is_convertible<double,int&>::value));
    mwg_check(( mwg::stdm::is_convertible<double,const int&>::value));

    mwg_check((!mwg::stdm::is_convertible<int,int*>::value));
    mwg_check(( mwg::stdm::is_convertible<int*,void*>::value));
    mwg_check((!mwg::stdm::is_convertible<void*,int*>::value));
    mwg_check(( mwg::stdm::is_convertible<int*,int*>::value));
    mwg_check((!mwg::stdm::is_convertible<int*,char*>::value));
    mwg_check(( mwg::stdm::is_convertible<U*,S*>::value));
    mwg_check((!mwg::stdm::is_convertible<S*,U*>::value));
    mwg_check(( mwg::stdm::is_convertible<T*,S*>::value));
    mwg_check((!mwg::stdm::is_convertible<S*,T*>::value));
    mwg_check(( mwg::stdm::is_convertible<U*,U*>::value));
    mwg_check((!mwg::stdm::is_convertible<const U*,U*>::value));

    // cv qualifiers
    // - values to values
    mwg_check(( mwg::stdm::is_convertible<int,const int>::value));
    mwg_check(( mwg::stdm::is_convertible<const int,int>::value));
    mwg_check(( mwg::stdm::is_convertible<int,volatile int>::value));
    mwg_check(( mwg::stdm::is_convertible<volatile int,int>::value));
    mwg_check(( mwg::stdm::is_convertible<int,const volatile int>::value));
    mwg_check(( mwg::stdm::is_convertible<const volatile int,int>::value));

    // from values to references
    check_is_convertible__toref();

    // - pointers to pointers
    mwg_check(( mwg::stdm::is_convertible<int*,const int*>::value));
    mwg_check(( mwg::stdm::is_convertible<int*,volatile int*>::value));
    mwg_check(( mwg::stdm::is_convertible<int*,const volatile int*>::value));
    mwg_check((!mwg::stdm::is_convertible<const int*,int*>::value));
    mwg_check((!mwg::stdm::is_convertible<const int*,volatile int*>::value));
    mwg_check(( mwg::stdm::is_convertible<const int*,const int*>::value));
    mwg_check(( mwg::stdm::is_convertible<const int*,const volatile int*>::value));
    mwg_check((!mwg::stdm::is_convertible<volatile int*,int*>::value));
    mwg_check((!mwg::stdm::is_convertible<volatile int*,const int*>::value));
    mwg_check(( mwg::stdm::is_convertible<volatile int*,volatile int*>::value));
    mwg_check(( mwg::stdm::is_convertible<volatile int*,const volatile int*>::value));
    mwg_check((!mwg::stdm::is_convertible<const volatile int*,int*>::value));
    mwg_check((!mwg::stdm::is_convertible<const volatile int*,const int*>::value));
    mwg_check((!mwg::stdm::is_convertible<const volatile int*,volatile int*>::value));
    mwg_check(( mwg::stdm::is_convertible<const volatile int*,const volatile int*>::value));

    // from GNU ISO C++ Library is_convertible.cc (GPL)
    // // Positive tests.
    // mwg_check(( mwg::stdm::is_convertible<int, const int>::value));
    // mwg_check(( mwg::stdm::is_convertible<volatile int, const int>::value));
    // mwg_check(( mwg::stdm::is_convertible<int*, const int*>::value));
    // mwg_check(( mwg::stdm::is_convertible<int*, void*>::value));
    // mwg_check(( mwg::stdm::is_convertible<int[4], int*>::value));
    // mwg_check(( mwg::stdm::is_convertible<float&, int>::value));
    // mwg_check(( mwg::stdm::is_convertible<int, const int&>::value));
    // mwg_check(( mwg::stdm::is_convertible<const int&, int>::value));
    // mwg_check(( mwg::stdm::is_convertible<float, const int&>::value));
    // mwg_check(( mwg::stdm::is_convertible<float, volatile float&>::value));
    // mwg_check(( mwg::stdm::is_convertible<int(int), int(*)(int)>::value));
    // mwg_check(( mwg::stdm::is_convertible<int(int), int(&)(int)>::value));
    // mwg_check(( mwg::stdm::is_convertible<int(&)(int), int(*)(int)>::value));
    // mwg_check(( mwg::stdm::is_convertible<E, int>::value));
    // mwg_check(( mwg::stdm::is_convertible<S, ClassType>::value));
    // mwg_check(( mwg::stdm::is_convertible<T, S>::value));
    // mwg_check(( mwg::stdm::is_convertible<T*, S*>::value));
    // mwg_check(( mwg::stdm::is_convertible<T&, S&>::value));

    // // Negative tests.
    // mwg_check((!mwg::stdm::is_convertible<const int*, int*>::value));
    // mwg_check((!mwg::stdm::is_convertible<int*, float*>::value));
    // mwg_check((!mwg::stdm::is_convertible<const int[4], int*>::value));
    // mwg_check((!mwg::stdm::is_convertible<int[4], int[4]>::value));
    // mwg_check((!mwg::stdm::is_convertible<const int&, int&>::value));
    // mwg_check((!mwg::stdm::is_convertible<float&, int&>::value));
    // mwg_check((!mwg::stdm::is_convertible<float, volatile int&>::value));
    // mwg_check((!mwg::stdm::is_convertible<int(int), int(int)>::value));
    // mwg_check((!mwg::stdm::is_convertible<int(int), int(*)(void)>::value));
    // mwg_check((!mwg::stdm::is_convertible<int(*)(int), int(&)(int)>::value));
    // mwg_check((!mwg::stdm::is_convertible<S, T>::value));
    // mwg_check((!mwg::stdm::is_convertible<S*, T*>::value));
    // mwg_check((!mwg::stdm::is_convertible<S&, T&>::value));
  }
#pragma%x end_check

  //
  // is_object
  //   is_scalar
  //     is_enum
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_enum;
  using ::std::tr1::is_scalar;
  using ::std::tr1::is_object;
#else
  template<typename T>
  struct is_enum:integral_constant<
    bool,
    !is_arithmetic<T>::value&&
    !is_pointer<T>::value&&!is_member_pointer<T>::value&&!is_function<T>::value&&
    !detail::is_class_or_union<T>::value&&!is_array<T>::value&&
    !is_reference<T>::value&&is_convertible<typename remove_cv<T>::type,int>::value
    >{};

  template<typename T>
  struct is_scalar:integral_constant<
    bool,
    is_arithmetic<T>::value||
    is_enum<T>::value||
    is_pointer<T>::value||
    is_member_pointer<T>::value||
    is_null_pointer<T>::value
    >{};

  template<typename T>
  struct is_object:integral_constant<
    bool,
    is_scalar<T>::value||
    is_array<T>::value||
    is_class<T>::value||
    is_union<T>::value
    >{};
#endif

  //
  // is_fundamental
  // is_compound
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_fundamental;
  using ::std::tr1::is_compound;
#else
  template<typename T>
  struct is_fundamental:integral_constant<
    bool,
    is_arithmetic<T>::value||
    is_void<T>::value||
    is_same<nullptr_t,typename remove_cv<T>::type>::value
    >{};
  template<typename T>
  struct is_compound:integral_constant<bool,!is_fundamental<T>::value>{};
#endif
#pragma%x begin_check
  void check_is_fundamental(){
    mwg_check(( mwg::stdm::is_fundamental<int>::value));
    mwg_check(( mwg::stdm::is_fundamental<float>::value));
    mwg_check(( mwg::stdm::is_fundamental<long double>::value));
    mwg_check(( mwg::stdm::is_fundamental<const int>::value));
    mwg_check(( mwg::stdm::is_fundamental<volatile float>::value));
    mwg_check(( mwg::stdm::is_fundamental<const volatile long double>::value));

    mwg_check((!mwg::stdm::is_fundamental<U>::value));
    mwg_check((!mwg::stdm::is_fundamental<int&>::value));
    mwg_check((!mwg::stdm::is_fundamental<int*>::value));
    mwg_check((!mwg::stdm::is_fundamental<float&>::value));
    mwg_check((!mwg::stdm::is_fundamental<float*>::value));

    mwg_check((!mwg::stdm::is_compound<int>::value));
    mwg_check((!mwg::stdm::is_compound<float>::value));
    mwg_check((!mwg::stdm::is_compound<long double>::value));
    mwg_check((!mwg::stdm::is_compound<const int>::value));
    mwg_check((!mwg::stdm::is_compound<volatile float>::value));
    mwg_check((!mwg::stdm::is_compound<const volatile long double>::value));

    mwg_check(( mwg::stdm::is_compound<U>::value));
    mwg_check(( mwg::stdm::is_compound<int&>::value));
    mwg_check(( mwg::stdm::is_compound<int*>::value));
    mwg_check(( mwg::stdm::is_compound<float&>::value));
    mwg_check(( mwg::stdm::is_compound<float*>::value));
  }
#pragma%x end_check
  //===========================================================================
  //  type utilities
  //---------------------------------------------------------------------------

  //
  // decay
  //
  template<typename T>
  struct decay_impl:conditional<
    is_array<T>::value,typename remove_extent<T>::type*,
    typename conditional<
      is_function<T>::value,typename add_pointer<T>::type,
      typename remove_cv<T>::type
    >::type
  >{};
  template<typename T>
  struct decay
    :decay_impl<typename remove_reference<T>::type>{};

  //
  // common_type
  //
//%[ArN=10]
# define MWG_STD_COMMON_TYPE__EMULATED
# if defined(MWGCONF_STD_VARIADIC_TEMPLATES)
  template<typename... Ts>
  struct common_type{};
# else
//%x
  template<$".for/K/0/ArN/typename TK=void/,">
  struct common_type
    :common_type<typename common_type<T0,T1>::type,$".for/K/2/ArN/TK/,">{};
//%end.i
# endif
  //---------------------------------------------------------------------------
  //  common_type<>
  template<> struct common_type<>{};
  //---------------------------------------------------------------------------
  //  common_type<T0>
  template<typename T0> struct common_type<T0>:mwg::identity<T0>{};
  //---------------------------------------------------------------------------
  //  common_type<T0,T1>
# if defined(MWGCONF_STD_DECLTYPE)
  template<typename T0,typename T1>
  struct common_type<T0,T1>:mwg::identity<decltype(true?mwg::declval<T0>():mwg::declval<T1>())>{};
# else
  // TODO: [cond.expr] 基本クラスの判定?
  template<typename T0,typename T1>
  struct common_type<T0,T1>:stdm::conditional<
    stdm::is_same<T1,T0>::value,mwg::identity<T1>,
    typename stdm::conditional<
      stdm::is_same<T1,void>::value||stdm::is_same<T0,void>::value,
      void, // typename stdm::conditional<stdm::is_same<T1,void>::value,mwg::identity<T0>,mwg::identity<T0> >::type, /* T0 or T1 = throw-expression */
      typename stdm::conditional<
        stdm::is_convertible<T1,T0>::value!=stdm::is_convertible<T0,T1>::value,
        stdm::conditional<stdm::is_convertible<T1,T0>::value,T0,T1>,
        void
        >::type
      >::type
    >::type{};
# endif
  //---------------------------------------------------------------------------
  //  common_type<T0,T1,T2,...>::type
# if defined(MWGCONF_STD_VARIADIC_TEMPLATES)
  template<typename T0,typename T1,typename T2,typename... Ts>
  struct common_type<T0,T1,T2,Ts...>
    :common_type<typename common_type<T0,T1>::type,T2,Ts...>{};
# else
//%x
  template<$".for/K/0/_AR_/typename TK/,">
  struct common_type<$".for/K/0/_AR_/TK/,">
    :common_type<typename common_type<T0,T1>::type,$".for/K/2/_AR_/TK/,">{};
//%end.f/_AR_/3/ArN/.i
# endif

  //===========================================================================
  //  class_traits
  //---------------------------------------------------------------------------

  //
  // is_empty
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_empty;
#else
# if defined(_MSC_VER)||MWGCONF_GCC_VER>=40300
  template<typename T> struct is_empty:integral_constant<bool,__is_empty(T)>{};
# else
  /* ■取り敢えず false■ */
  // ライブラリによる実装手段はない。
  template<typename T> struct is_empty:false_type{};
# endif
#endif

  //
  // is_pod
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_pod;
#else
  namespace detail{
    template<typename T>
    struct is_pod_impl2:integral_constant<bool,
# if (MWGCONF_MSC_VER>=140050215)
      (__is_pod(T)&&__has_trivial_constructor(T))
# elif (MWGCONF_GCC_VER>=40300&&!defined(__GCCXML__))
      (__is_pod(T))
# else
#  define mwg_stdm_is_pod__incomplete
      false
# endif
      >{};

    template<typename T,bool isArray>
    struct is_pod_impl1:integral_constant<bool,(is_scalar<T>::value||is_void<T>::value||is_pod_impl2<T>::value)>{};
    template<typename T>
    struct is_pod_impl1<T,true>:integral_constant<bool,extent<T>::value!=0&&is_pod_impl1<typename remove_all_extents<T>::type,false>::value>{};
    template<typename T>
    struct is_pod:is_pod_impl1<T,is_array<T>::value>{};
  }

  using detail::is_pod;
#endif

}
}

#ifdef __clang__
# pragma clang diagnostic pop
#endif

#endif
//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
// mwg::stdx : mwg extension
//-----------------------------------------------------------------------------
namespace mwg{
namespace stdx{
  using namespace mwg::stdm;

  //
  // struct copy_const    <T,From>
  // struct copy_volatile <T,From>
  // struct copy_cv       <T,From>
  //
  //   From についている cv を T に適用する。元から T についている cv はそのままにする。
  //   クラスに cv がついている時に、そのメンバ T が実質的にどの型になるかを得るのに使う。
  //
  template<typename To,typename From> struct copy_const
    :conditional<is_const<From>::value,typename add_const<To>::type,To>{};
  template<typename To,typename From> struct copy_volatile
    :conditional<is_volatile<From>::value,typename add_volatile<To>::type,To>{};
  template<typename To,typename From> struct copy_cv
    :copy_const<typename copy_volatile<To,From>::type,From>{};

  // add_const_reference<T>
  template<typename T> struct add_const_reference:add_lvalue_reference<typename add_const<T>::type>{};

  // parameter_pack<Ts...>
#if defined(MWGCONF_STD_VARIADIC_TEMPLATES)
  template<typename... Ts>
  struct parameter_pack{static const std::size_t size=sizeof...(Ts);};
#else
//%expand (
  template<$".for/K/0/ArN/typename AK=void/,">
  struct parameter_pack{static const std::size_t size=$".eval:ArN";};
//%expand (
  template<$".for/K/0/_AR_/typename AK/,">
  struct parameter_pack<$".for/K/0/_AR_/AK/,">{static const std::size_t size=_AR_;};
//%).f/_AR_/0/ArN/
//%).i
#endif

  //
  // ice_and
  // ice_or
  // is_convertible_pack<Ts...>
  //
  //   To avoid internal compiler errors in some compilers.
  //   They can also be used with ... expansion as ice_and<expr...>::value.
#if defined(MWGCONF_STD_VARIADIC_TEMPLATES)
  template<bool... Bs> struct ice_and;
  template<bool... Bs> struct ice_and<false,Bs...>:stdm::false_type{};
  template<bool... Bs> struct ice_and<true,Bs...>:ice_and<Bs...>{};
  template<> struct ice_and<>:stdm::true_type{};
  template<bool... Bs> struct ice_or;
  template<bool... Bs> struct ice_or<true,Bs...>:stdm::true_type{};
  template<bool... Bs> struct ice_or<false,Bs...>:ice_or<Bs...>{};
  template<> struct ice_or<>:stdm::false_type{};

  namespace detail{
    template<typename TT1,typename TT2,bool S>
    struct is_convertible_pack_impl:stdm::false_type{};
    template<typename... As,typename... Bs>
    struct is_convertible_pack_impl<parameter_pack<As...>,parameter_pack<Bs...>,true>
      :stdm::integral_constant<bool,ice_and<stdm::is_convertible<As,Bs>::value...>::value>{};
  }

  template<typename TT1,typename TT2>
  struct is_convertible_pack:stdm::false_type{};
  template<typename... As,typename... Bs>
  struct is_convertible_pack<parameter_pack<As...>,parameter_pack<Bs...>>
    :detail::is_convertible_pack_impl<parameter_pack<As...>,parameter_pack<Bs...>,sizeof...(As)==sizeof...(Bs)>{};
#else
//%expand (
  template<$".for/K/0/ArN/bool CK=true/,"> struct ice_and:false_type{};
  template<> struct ice_and<>:true_type{};
  template<$".for/K/0/ArN/bool CK=false/,"> struct ice_or:true_type{};
  template<> struct ice_or<>:false_type{};

  namespace detail{
    template<typename TT1,typename TT2,bool S> struct is_convertible_pack_impl:false_type{};
    template<> struct is_convertible_pack_impl<parameter_pack<>,parameter_pack<>,true>:true_type{};
    template<$".for/K/0/ArN/typename AK/,",$".for/K/0/ArN/typename BK/,">
    struct is_convertible_pack_impl<parameter_pack<$".for/K/0/ArN/AK/,">,parameter_pack<$".for/K/0/ArN/BK/,">,true>
      :stdm::integral_constant<bool,
        stdm::is_convertible<A0,B0>::value
        &&is_convertible_pack_impl<parameter_pack<$".for/K/1/ArN/AK/,">,parameter_pack<$".for/K/1/ArN/BK/,">,true>::value
      >{};
  }
  template<typename TT1,typename TT2>
  struct is_convertible_pack
    :detail::is_convertible_pack_impl<TT1,TT2,TT1::size==TT2::size>{};
//%).i
#endif
}
}
#include "type_traits.is_constructible.h"
#pragma%x begin_check
struct Test0{};
struct Test1{Test1();};
struct Test2{Test2(int);};
class  Test3{Test3();};
void check_is_default_constructible(){
  mwg_check(( mwg::stdm::is_default_constructible<int>::value));
  mwg_check(( mwg::stdm::is_default_constructible<int[2]>::value));
  mwg_check((!mwg::stdm::is_default_constructible<int&>::value));
  mwg_check(( mwg::stdm::is_default_constructible<int Test0::*>::value));
  mwg_check(( mwg::stdm::is_default_constructible<int (Test0::*)(int)>::value));
  mwg_check_nothrow(( mwg::stdm::is_default_constructible<Test0>::value));
  mwg_check_nothrow(( mwg::stdm::is_default_constructible<Test1>::value));
  mwg_check_nothrow((!mwg::stdm::is_default_constructible<Test2>::value));
  mwg_check_nothrow((!mwg::stdm::is_default_constructible<Test3>::value));
  mwg_check_nothrow(( mwg::stdm::is_default_constructible<Test0[2]>::value));
  mwg_check_nothrow(( mwg::stdm::is_default_constructible<Test1[2]>::value));
  mwg_check_nothrow((!mwg::stdm::is_default_constructible<Test2[2]>::value));
  mwg_check_nothrow((!mwg::stdm::is_default_constructible<Test3[2]>::value));
}
#pragma%x end_check

#endif /* MWG_STDM_TYPE_TRAITS */
#pragma%x begin_check

int main(){
  check_is_volatile();
  check_remove_cv();
  check_add_lvalue_reference();
  check_is_integral();
  check_is_floating_point();
  check_is_arithmetic();
  check_is_signed();
  check_is_member_pointer();
  check_is_base_of();
  check_is_convertible();
  check_is_fundamental();
  check_is_default_constructible();
  return 0;
}
#pragma%x end_check
