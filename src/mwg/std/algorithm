// -*- mode: c++; coding: utf-8 -*-
#ifndef MWG_STDM_ALGORITHM
#define MWG_STDM_ALGORITHM
#include <algorithm>
#include <mwg/defs.h>
#pragma%include "../impl/ManagedTest.pp"
#pragma%x begin_check
#include <mwg/except.h>
#include <mwg/std/algorithm>
#include <mwg/std/iterator>
#pragma%x end_check

// C++03
namespace mwg {
namespace stdm {
  // Note: mwg::stdm での多重定義で隠蔽されない様に using する必要がある。
  using ::std::for_each;
  using ::std::count;
  using ::std::count_if;
  using ::std::mismatch;
  using ::std::equal;
  using ::std::find;
  using ::std::find_if;
  using ::std::find_end;
  using ::std::adjacent_find;
  using ::std::search;
  using ::std::search_n;
  using ::std::copy;
  using ::std::fill;
  using ::std::transform;
  using ::std::generate;
  using ::std::remove;
  using ::std::remove_if;
  using ::std::remove_copy;
  using ::std::remove_copy_if;
  using ::std::replace;
  using ::std::replace_if;
  using ::std::replace_copy;
  using ::std::replace_copy_if;
  using ::std::swap_ranges;
  using ::std::reverse;
  using ::std::reverse_copy;
  using ::std::rotate_copy;
  using ::std::unique;
  using ::std::unique_copy;
  using ::std::stable_partition;
  using ::std::sort;
  using ::std::partial_sort;
  using ::std::partial_sort_copy;
  using ::std::stable_sort;
  using ::std::nth_element;
  using ::std::merge;
  using ::std::inplace_merge;
  using ::std::includes;
  using ::std::set_difference;
  using ::std::set_intersection;
  using ::std::set_symmetric_difference;
  using ::std::set_union;
  using ::std::lexicographical_compare;

  // Note: 以下は constexpr 版が C++14/C++17 で導入されたが、
  //   constexpr に対応していない場合に C++03 のものを使用する為に using する。
  using ::std::min;
  using ::std::max;
  using ::std::min_element;
  using ::std::max_element;

  // Note: 以下は (今のところ) 上書きされないので using は不要だが念のため。
  using ::std::copy_backward;
  using ::std::iter_swap;
  using ::std::lower_bound;
  using ::std::upper_bound;
  using ::std::binary_search;
  using ::std::equal_range;
  using ::std::make_heap;
  using ::std::push_heap;
  using ::std::pop_heap;
  using ::std::sort_heap;
  using ::std::next_permutation;
  using ::std::prev_permutation;
}
}

#ifdef MWG_STD_CXX11
namespace mwg {
namespace stdm {
  using ::std::all_of;
  using ::std::any_of;
  using ::std::none_of;
  using ::std::find_if_not;
  using ::std::find_first_of;
  using ::std::copy_n;
  using ::std::move;
  using ::std::move_backward; //
  using ::std::fill_n;
  using ::std::generate_n;
  using ::std::rotate;
  using ::std::shuffle;
  using ::std::is_partitioned;
  using ::std::partition;
  using ::std::partition_copy;
  using ::std::partition_point;
  using ::std::is_sorted;
  using ::std::is_sorted_until;
  using ::std::is_heap;
  using ::std::is_heap_until;
  using ::std::is_permutation;

  // Note: 以下は constexpr 版が C++14/C++17 で導入されたが、
  //   constexpr に対応していない場合に C++03 のものを使用する為に using する。
  using ::std::minmax;
  using ::std::minmax_element;
}
}
#else
# include <iterator>
# include <functional>
# include <mwg/defs.h>
# include <mwg/std/utility>

//todo: find_first_of
//todo: is_permutation

// C++11
namespace mwg {
namespace stdm {
  template<typename InputIterator, typename Predicate>
  bool any_of(InputIterator first, InputIterator last, Predicate pred) {
    for (; first != last; ++first) if (pred(*first)) return true;
    return false;
  }

  template<typename InputIterator, typename Predicate>
  bool none_of(InputIterator first, InputIterator last, Predicate pred) {
    return !any_of(first, last, pred);
  }

  template<typename InputIterator, typename Predicate>
  bool all_of(InputIterator first, InputIterator last, Predicate pred) {
    for (; first != last; ++first) if (!pred(*first)) return false;
    return true;
  }

  template<typename InputIterator, typename UnaryPredicate>
  InputIterator find_if_not(InputIterator first, InputIterator last, UnaryPredicate pred) {
    for (; first != last; ++first) if (!pred(*first)) break;
    return first;
  }

#pragma%x begin_test
  struct is_one {bool operator()(int a) const {return a == 1;}};
  void test() {
    int arr1[] = {1, 1, 1, 1, 1, 1, 1, 1};
    int arr2[] = {0, 0, 0, 0, 0, 0, 0, 1};
    int arr3[] = {1, 0, 0, 0, 0, 0, 0, 0};
    int arr4[] = {0};
    int arr5[] = {1};
    int arr6[] = {0, 0, 0, 0, 0, 0, 0, 0};
    int arr7[] = {0, 1, 0, 0, 0, 0, 0, 0};

    namespace ns = mwg::stdm;

    mwg_check( ns::any_of(ns::begin(arr1), ns::end(arr1), is_one()));
    mwg_check( ns::any_of(ns::begin(arr2), ns::end(arr2), is_one()));
    mwg_check( ns::any_of(ns::begin(arr3), ns::end(arr3), is_one()));
    mwg_check(!ns::any_of(ns::begin(arr4), ns::end(arr4), is_one()));
    mwg_check( ns::any_of(ns::begin(arr5), ns::end(arr5), is_one()));
    mwg_check(!ns::any_of(ns::begin(arr6), ns::end(arr6), is_one()));
    mwg_check( ns::any_of(ns::begin(arr7), ns::end(arr7), is_one()));
    mwg_check(!ns::any_of(ns::begin(arr1), ns::begin(arr1), is_one()));

    mwg_check(!ns::none_of(ns::begin(arr1), ns::end(arr1), is_one()));
    mwg_check(!ns::none_of(ns::begin(arr2), ns::end(arr2), is_one()));
    mwg_check(!ns::none_of(ns::begin(arr3), ns::end(arr3), is_one()));
    mwg_check( ns::none_of(ns::begin(arr4), ns::end(arr4), is_one()));
    mwg_check(!ns::none_of(ns::begin(arr5), ns::end(arr5), is_one()));
    mwg_check( ns::none_of(ns::begin(arr6), ns::end(arr6), is_one()));
    mwg_check(!ns::none_of(ns::begin(arr7), ns::end(arr7), is_one()));
    mwg_check( ns::none_of(ns::begin(arr1), ns::begin(arr1), is_one()));

    mwg_check( ns::all_of(ns::begin(arr1), ns::end(arr1), is_one()));
    mwg_check(!ns::all_of(ns::begin(arr2), ns::end(arr2), is_one()));
    mwg_check(!ns::all_of(ns::begin(arr3), ns::end(arr3), is_one()));
    mwg_check(!ns::all_of(ns::begin(arr4), ns::end(arr4), is_one()));
    mwg_check( ns::all_of(ns::begin(arr5), ns::end(arr5), is_one()));
    mwg_check(!ns::all_of(ns::begin(arr6), ns::end(arr6), is_one()));
    mwg_check(!ns::all_of(ns::begin(arr7), ns::end(arr7), is_one()));
    mwg_check( ns::all_of(ns::begin(arr1), ns::begin(arr1), is_one()));

    mwg_check(ns::find_if_not(ns::begin(arr1), ns::end(arr1), is_one()) == ns::end(arr1));
    mwg_check(ns::find_if_not(ns::begin(arr2), ns::end(arr2), is_one()) == ns::begin(arr2));
    mwg_check(ns::find_if_not(ns::begin(arr3), ns::end(arr3), is_one()) == ns::begin(arr3) + 1);
    mwg_check(ns::find_if_not(ns::begin(arr4), ns::end(arr4), is_one()) == ns::begin(arr4));
    mwg_check(ns::find_if_not(ns::begin(arr5), ns::end(arr5), is_one()) == ns::begin(arr5) + 1);
    mwg_check(ns::find_if_not(ns::begin(arr6), ns::end(arr6), is_one()) == ns::begin(arr6));
    mwg_check(ns::find_if_not(ns::begin(arr7), ns::end(arr7), is_one()) == ns::begin(arr7));
    mwg_check(ns::find_if_not(ns::begin(arr1), ns::begin(arr1), is_one()) == ns::begin(arr1));
  }
#pragma%x end_test

  template<typename InputIterator, typename OutputIterator, typename UnaryPredicate>
  OutputIterator copy_if(InputIterator src, InputIterator src_end, OutputIterator dst, UnaryPredicate pred) {
    for (; src != src_end; ++src) if (pred(*src)) *dst++ = *src;
    return dst;
  }

  template<typename InputIterator, typename Size, typename OutputIterator>
  OutputIterator copy_n(InputIterator src, Size n, OutputIterator dst) {
    while (n--) *dst++ = *src++;
    return dst;
  }

#pragma%x begin_test
  struct is_odd {bool operator()(int a) const {return a % 2 == 1;}};
  void test_copy_if_1(const char* name, int (&arr)[8], int const (&src)[8], int const (&ans)[8]) {
    namespace ns = mwg::stdm;
    std::fill(ns::begin(arr), ns::end(arr), 0);
    ns::copy_if(ns::begin(src), ns::end(src), ns::begin(arr), is_odd());
    mwg_check(ns::equal(ns::begin(arr), ns::end(arr), ns::begin(ans)), "test of copy_if %s", name);
  }
  void test() {
    int arr[8];

    namespace ns = mwg::stdm;

    {
      int src1[] = {1, 3, 1, 5, 1, 7, 1, 9};
      int ans1[] = {1, 3, 1, 5, 1, 7, 1, 9};
      test_copy_if_1("#1", arr, src1, ans1);
      int src2[] = {2, 2, 2, 2, 2, 2, 2, 2};
      int ans2[] = {0, 0, 0, 0, 0, 0, 0, 0};
      test_copy_if_1("#2", arr, src2, ans2);
      int src3[] = {1, 2, 3, 2, 5, 2, 7, 2};
      int ans3[] = {1, 3, 5, 7, 0, 0, 0, 0};
      test_copy_if_1("#3", arr, src3, ans3);
      int src4[] = {2, 3, 2, 5, 2, 7, 2, 9};
      int ans4[] = {3, 5, 7, 9, 0, 0, 0, 0};
      test_copy_if_1("#4", arr, src4, ans4);
    }

    {
      int src[] = {1, 2, 3, 4, 5, 6, 7, 8};
      int ans1[] = {0, 0, 0, 0, 0, 0, 0, 0};
      int ans2[] = {1, 2, 3, 4, 5, 6, 7, 8};
      int ans3[] = {1, 0, 0, 0, 0, 0, 0, 0};
      int ans4[] = {1, 2, 3, 4, 0, 0, 0, 0};
      int ans5[] = {1, 2, 3, 4, 5, 6, 7, 0};
      std::fill(ns::begin(arr), ns::end(arr), 0);
      ns::copy_n(ns::begin(src), 0, ns::begin(arr));
      mwg_check(ns::equal(ns::begin(arr), ns::end(arr), ns::begin(ans1)));
      std::fill(ns::begin(arr), ns::end(arr), 0);
      ns::copy_n(ns::begin(src), 8, ns::begin(arr));
      mwg_check(ns::equal(ns::begin(arr), ns::end(arr), ns::begin(ans2)));
      std::fill(ns::begin(arr), ns::end(arr), 0);
      ns::copy_n(ns::begin(src), 1, ns::begin(arr));
      mwg_check(ns::equal(ns::begin(arr), ns::end(arr), ns::begin(ans3)));
      std::fill(ns::begin(arr), ns::end(arr), 0);
      ns::copy_n(ns::begin(src), 4, ns::begin(arr));
      mwg_check(ns::equal(ns::begin(arr), ns::end(arr), ns::begin(ans4)));
      std::fill(ns::begin(arr), ns::end(arr), 0);
      ns::copy_n(ns::begin(src), 7, ns::begin(arr));
      mwg_check(ns::equal(ns::begin(arr), ns::end(arr), ns::begin(ans5)));
    }
  }
#pragma%x end_test

  template<typename InputIterator, typename OutputIterator>
  OutputIterator move(InputIterator src, InputIterator src_last, OutputIterator dst) {
    while (src != src_last) *dst++ = stdm::move(*src++);
    return dst;
  }

  template<typename BidirectionalIterator1, typename BidirectionalIterator2>
  BidirectionalIterator2 move_backward(BidirectionalIterator1 src_first, BidirectionalIterator1 src_last, BidirectionalIterator2 dst_last) {
    while (src_first != src_last) *--dst_last = stdm::move(*--src_last);
    return dst_last;
  }

  template<typename OutputIterator, typename Size, typename T>
  OutputIterator fill_n(OutputIterator first, Size n, const T& value) {
    while (n--) *first++ = value;
    return first;
  }

  template<typename OutputIterator, typename Size, typename Generator>
  OutputIterator generate_n(OutputIterator first, Size n, Generator generator) {
    while (n--) *first++ = generator();
    return first;
  }

  template<typename ForwardIterator>
  ForwardIterator rotate(ForwardIterator first, ForwardIterator mid, ForwardIterator last) {
    if (first == last || mid == last) return first;
    if (mid == first) return last;
    ForwardIterator mid0 = mid;
    do {
      std::iter_swap(first++, mid++);
      if (first == mid0) mid0 = mid;
    } while (mid != last);

    // We now know the return value, so use
    // C++03 `std::rotate` to perform the remaining rotation.
    ::std::rotate(first, mid0, last);
    return first;
  }

  template<typename RandomIterator, typename UniformRandomBitGenerator>
  void shuffle(RandomIterator first, RandomIterator last, UniformRandomBitGenerator mwg_forward_rvalue g) {
    // call C++03 `std::random_shuffle` which is deprecated in C++14
    ::std::random_shuffle(first, last, stdm::forward<URBG>(g));
  }

  template<typename InputIterator, typename UnaryPredicate>
  bool is_partitioned(InputIterator first, InputIterator last, UnaryPredicate pred) {
    while (first != last)
      if (!pred(*first++))
        return none_of(first, last, pred);
    return true;
  }

  // Note: partition は C++11 で BidirectionalIterator でなくて ForwardIterator でも実行できるようになった。

  namespace algorithm_detail {
    template<typename InputIterator, typename OutputIterator, typename UnaryPredicate>
    OutputIterator swap_if(InputIterator src, InputIterator src_end, OutputIterator dst, UnaryPredicate pred) {
      for (; src != src_end; ++src) if (pred(*src)) std::iter_swap(dst++, src);
      return dst;
    }
  }

  template<typename ForwardIterator, typename UnaryPredicate>
  typename stdm::enable_if<
    stdm::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<ForwardIterator>::iterator_category>::value,
    ForwardIterator>::type
  partition(ForwardIterator first, ForwardIterator last, UnaryPredicate pred) {
    return ::std::partition(first, last, pred);
  }

  template<typename ForwardIterator, typename UnaryPredicate>
  typename stdm::enable_if<
    !stdm::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<ForwardIterator>::iterator_category>::value,
    ForwardIterator>::type
  partition(ForwardIterator first, ForwardIterator last, UnaryPredicate pred) {
    for (; first != last; ++first) {
      if (!pred(*first)) {
        ForwardIterator dst = first++;
        return algorithm_detail::swap_if(first, last, dst, pred);
      }
    }
    return first;
  }

  template<typename InputIterator, typename OutputIterator1, typename OutputIterator2, typename UnaryPredicate>
  std::pair<OutputIterator1, OutputIterator2>
  partition_copy(InputIterator first, InputIterator last, OutputIterator1 dst_true, OutputIterator2 dst_false, UnaryPredicate pred) {
    for (; first != last; ++first) (pred(*first)? dst_true++: dst_false++) = *first;
    return std::make_pair(dst_true, dst_false);
  }

  template<typename ForwardIterator, typename UnaryPredicate>
  typename stdm::enable_if<
    stdm::is_base_of<std::random_access_iterator_tag, typename std::iterator_traits<ForwardIterator>::iterator_category>::value,
    ForwardIterator>::type
  partition_point(ForwardIterator first, ForwardIterator last, UnaryPredicate pred) {
    std::ptrdiff_t l = 0, u = last - first;
    while (l < u) {
      std::ptrdiff_t m = (l + u) / 2;
      if (pred(first[m]))
        l = m + 1;
      else
        u = m;
    }
    return first + l;
  }

  template<typename ForwardIterator, typename UnaryPredicate>
  typename stdm::enable_if<
    !stdm::is_base_of<std::random_access_iterator_tag, typename std::iterator_traits<ForwardIterator>::iterator_category>::value,
    ForwardIterator>::type
  partition_point(ForwardIterator first, ForwardIterator last, UnaryPredicate pred) {
    return find_if_not(first, last, pred);
  }

  template<typename ForwardIterator, typename Compare>
  ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last, Compare compare) {
    if (first == last) return first;
    for (;;) {
      ForwardIterator prev = first++;
      if (first == last || compare(*first, *prev)) return first;
    }
  }

  template<typename ForwardIterator>
  ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last) {
    return is_sorted_until(first, last, std::less<typename std::iterator_traits<ForwardIterator>::value_type>());
  }

  template<typename ForwardIterator, typename Compare>
  bool is_sorted(ForwardIterator first, ForwardIterator last, Compare compare) {
    return last == is_sorted_until(first, last, compare);
  }

  template<typename ForwardIterator>
  bool is_sorted(ForwardIterator first, ForwardIterator last) {
    return last == is_sorted_until(first, last);
  }

  template<typename RandomAccessIterator, typename Compare>
  RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last, Compare compare) {
    if (first == last) return first;
    RandomAccessIterator parent = first++;
    for (std::size_t i = 1; first != last && !compare(*parent, *first); ++first, ++i % 2 && ++parent);
    return first;
  }

  template<typename RandomAccessIterator>
  RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last) {
    return is_heap_until(first, last, std::less<typename std::iterator_traits<ForwardIterator>::value_type>());
  }

  template<typename RandomAccessIterator, typename Compare>
  bool is_heap(RandomAccessIterator first, RandomAccessIterator last, Compare compare) {
    return last == is_heap_until(first, last, compare);
  }

  template<typename RandomAccessIterator>
  bool is_heap(RandomAccessIterator first, RandomAccessIterator last) {
    return last == is_heap_until(first, last);
  }

  // Note: C++11 minmax, min(std::initializer_list<T>), max(std::initializer_list<T>) are replaced by C++14
}
}
#endif /* end of MWG_STD_CXX11 */

#ifndef MWG_STD_CXX14
# include <mwg/defs.h>
# include <mwg/std/utility>
# include <mwg/std/initializer_list>
# include <mwg/std/functional>

// C++14
namespace mwg {
namespace stdm {
  template<typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
  std::pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1, InputIterator2 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred) {
    while (first1 != last1 && first2 != last2 && pred(*first1, *first2)) ++first1, ++first2;
    return stdm::make_pair(first1, first2);
  }

  template<typename InputIterator1, typename InputIterator2>
  std::pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1, InputIterator2 last1, InputIterator2 first2, InputIterator2 last2) {
    return mismatch(first1, last1, first2, last2, stdm::equal_to<>());
  }

  template<typename InputIterator1, typename InputIterator2, typename BinaryPredicate>
  bool equal(InputIterator1 first1, InputIterator2 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred) {
    for (; first1 != last1 && first2 != last2; ++first1, ++first2)
      if (!pred(*first1, *first2)) return false;
  }

  template<typename InputIterator1, typename InputIterator2>
  bool equal(InputIterator1 first1, InputIterator2 last1, InputIterator2 first2, InputIterator2 last2) {
    return equal(first1, last1, first2, last2, stdm::equal_to<>());
  }

#ifdef MWGCONF_STD_CONSTEXPR
  template<typename T>
  constexpr T const& max(T const& lhs, T const& rhs) {return lhs < rhs? rhs: lhs;}
  template<typename T>
  constexpr T const& min(T const& lhs, T const& rhs) {return rhs < lhs? rhs: lhs;}
  template<typename T, typename Compare>
  constexpr T const& max(T const& lhs, T const& rhs, Compare compare) {return compare(lhs, rhs)? rhs: lhs;}
  template<typename T>
  constexpr T const& min(T const& lhs, T const& rhs, Compare compare) {return compare(rhs, lhs)? rhs: lhs;}
#endif
  template<typename T, typename Compare>
  mwg_constexpr std::pair<T const&,T const&> minmax(T const& lhs, T const& rhs, Compare compare) {
    typedef std::pair<T const &, T const&> return_type;
    return compare(rhs, lhs)? return_type(rhs, lhs): return_type(lhs, rhs);
  }
  template<typename T>
  mwg_constexpr std::pair<T const&,T const&> minmax(T const& lhs, T const& rhs) {
    return minmax(lhs, rhs, std::less<T>());
  }

  template<typename T, typename Compare>
  mwg_constexpr14 T max(stdm::initializer_list<T> list, Compare compare) {
    typedef typename stdm::initializer_list<T>::const_iterator const_iterator;
    const_iterator i = list.begin();
    mwg_check(i != list.end());
    const_iterator iret = i++;
    for (; i != list.end(); ++i)
      if (compare(*iret, *i)) iret = i;
    return *iret;
  }
  template<typename T, typename Compare>
  mwg_constexpr14 T min(stdm::initializer_list<T> list, Compare compare) {
    typedef typename stdm::initializer_list<T>::const_iterator const_iterator;
    const_iterator i = list.begin();
    mwg_check(i != list.end());
    const_iterator iret = i++;
    for (; i != list.end(); ++i)
      if (compare(*i, *iret)) iret = i;
    return *iret;
  }
  template<typename T, typename Compare>
  mwg_constexpr14 std::pair<T, T> minmax(stdm::initializer_list<T> list, Compare compare) {
    typedef typename stdm::initializer_list<T>::const_iterator const_iterator;
    using std::swap;
    const_iterator i = list.begin();
    mwg_check(i != list.end());
    const_iterator imin = i;
    const_iterator imax = i;
    for (++i; i != list.end(); ) {
      const_iterator i1 = i++;
      if (i == list.end()) {
        if (compare(*i, *imin)) imin = i;
        if (!compare(*i, *imax)) imax = i; // right most is chosen
        break;
      }
      const_iterator i2 = i++;
      if (compare(*i2, *i1)) swap(i1, i2);
      if (compare(*i1, *imin)) imin = i1;
      if (!compare(*i2, *imax)) imax = i2; // right most is chosen
    }
    return std::make_pair(*imin, *imax);
  }

  template<typename T>
  mwg_constexpr14 T max(stdm::initializer_list<T> list) {return max(list, std::less<T>());}
  template<typename T>
  mwg_constexpr14 T min(stdm::initializer_list<T> list) {return min(list, std::less<T>());}
  template<typename T>
  mwg_constexpr14 std::pair<T, T> minmax(stdm::initializer_list<T> list) {return minmax(list, std::less<T>());}

}
}
#endif /* end of MWG_STD_CXX14 */

#ifndef MWG_STD_CXX17
# include <iterator>
# include <functional>

// todo: <execution>


// C++17
namespace mwg {
namespace stdm {
  template<typename InputIterator, typename Size, typename UnaryFunction>
  InputIterator for_each_n(InputIterator first, Size n, UnaryFunction f) {
    while (n--) f(*first++);
  }

  template<typename ForwardIterator, typename Searcher>
  ForwardIterator search(ForwardIterator first, ForwardIterator last, const Searcher& searcher) {
    return searcher(first, last).first;
  }

  template<typename T, typename Compare>
  T clamp(T const& value, T const& lower, T const& upper, Compare compare) {
    return compare(value, lower)? lower: compare(upper, value)? upper: value;
  }

  template<typename T>
  T clamp(T const& value, T const& lower, T const& upper) {
    return value < lower? lower: value > upper? upper: value;
  }

#ifdef MWGCONF_STD_CONSTEXPR14
  template<typename ForwardIterator, typename Compare>
  constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare compare) {
    if (first == last) return first;
    ForwardIterator ret = first++;
    for (; first != last; ++first) if (compare(*ret, *first)) ret = first;
    return ret;
  }
  template<typename ForwardIterator, typename Compare>
  constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last, Compare compare) {
    if (first == last) return first;
    ForwardIterator ret = first++;
    for (; first != last; ++first) if (compare(*first, *ret)) ret = first;
    return ret;
  }
  template<typename ForwardIterator>
  constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last) {
    return max_element(first, last, std::less<typename std::iterator_traits<ForwardIterator>::value_type>());
  }
  template<typename ForwardIterator>
  constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last) {
    return min_element(first, last, std::less<typename std::iterator_traits<ForwardIterator>::value_type>());
  }
#endif

// C++17 <execution>
//
// template<typename InputIterator, typename Predicate>
// bool all_of(ExecutionPolicy&& policy, InputIterator first, InputIterator last, Predicate pred);
// template<typename InputIterator, typename Predicate>
// bool any_of(ExecutionPolicy&& policy, InputIterator first, InputIterator last, Predicate pred);
// template<typename InputIterator, typename Predicate>
// bool none_of(ExecutionPolicy&& policy, InputIterator first, InputIterator last, Predicate pred);
// template< class ExecutionPolicy, class ForwardIt, class UnaryFunction2 >
// void for_each( ExecutionPolicy&& policy, ForwardIt first, ForwardIt last, UnaryFunction2 f );
// template< class ExecutionPolicy, class ForwardIt, class Size, class UnaryFunction2 >
// ForwardIt for_each_n( ExecutionPolicy&& policy, ForwardIt first, Size n, UnaryFunction2 f );
// template< class ExecutionPolicy, class ForwardIt, class T >
// typename iterator_traits<ForwardIt>::difference_type
// count( ExecutionPolicy&& policy, ForwardIt first, ForwardIt last, const T &value );
// template< class ExecutionPolicy, class ForwardIt, class UnaryPredicate >
// typename iterator_traits<ForwardIt>::difference_type
// count_if( ExecutionPolicy&& policy, ForwardIt first, ForwardIt last, UnaryPredicate p );
//
// ... many

}
}

#endif /* end of MWG_STD_CXX17 */


#endif /* end of MWG_STDM_ALGORITHM */
#pragma%x begin_check

int test(){
  namespace ns = mwg::stdm;
  return 0;
}

int main(){
  managed_test::run_tests();
  return test();
}
#pragma%x end_check
