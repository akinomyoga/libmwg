// -*- mode:C++;coding:utf-8 -*-
#ifndef MWG_STDM_TYPE_TRAITS
#define MWG_STDM_TYPE_TRAITS
#include <mwg/defs.h>
#if MWGCONF_HEADER_STD>=2011
# include <type_traits>
#else
//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
/*?mconf
 *
 * # C++11, C++TR1
 * H type_traits || H tr1/type_traits
 *
 * # include <type_traits> / <tr1/type_traits>
 * headers=
 * [[ $MWGCONF_HEADER_TR1_TYPE_TRAITS ]] && headers="$headers tr1/type_traits"
 * [[ $MWGCONF_HEADER_TYPE_TRAITS     ]] && headers="$headers type_traits"
 * if [[ $headers ]]; then
 *   X add_lvalue_reference "$headers" "typedef std::add_lvalue_reference<int>::type a;"
 *   X tr1_add_reference    "$headers" "typedef std::tr1::add_reference<int>::type a;"
 *
 *   # libstdc++ の特定の version で is_convertible<int,void> が true となる。
 *   X valid_is_convertible "$headers" 'int arr[!std::is_convertible<int,void>::value?1:-1];'
 * fi
 *
 * if test -n "$MWGCONF_HEADER_TYPE_TRAITS"; then
 *
 *   # type_traits
 *   X is_constructible                   "$headers" "int a=std::is_constructible<int,int>::value;"
 *   X is_trivially_constructible         "$headers" "int a=std::is_trivially_constructible<int,int>::value;"
 *   X is_nothrow_constructible           "$headers" "int a=std::is_nothrow_constructible<int,int>::value;"
 *   X is_default_constructible           "$headers" "int a=std::is_default_constructible<int>::value;"
 *   X is_trivially_default_constructible "$headers" "int a=std::is_trivially_default_constructible<int>::value;"
 *   X is_nothrow_default_constructible   "$headers" "int a=std::is_nothrow_default_constructible<int>::value;"
 *   X is_copy_constructible              "$headers" "int a=std::is_copy_constructible<int>::value;"
 *   X is_trivially_copy_constructible    "$headers" "int a=std::is_trivially_copy_constructible<int>::value;"
 *   X is_nothrow_copy_constructible      "$headers" "int a=std::is_nothrow_copy_constructible<int>::value;"
 *
 *   X is_assignable                      "$headers" "int a=std::is_assignable<int,int>::value;"
 *   X is_trivially_assignable            "$headers" "int a=std::is_trivially_assignable<int,int>::value;"
 *   X is_nothrow_assignable              "$headers" "int a=std::is_nothrow_assignable<int,int>::value;"
 *   X is_copy_assignable                 "$headers" "int a=std::is_copy_assignable<int>::value;"
 *   X is_trivially_copy_assignable       "$headers" "int a=std::is_trivially_copy_assignable<int>::value;"
 *   X is_nothrow_copy_assignable         "$headers" "int a=std::is_nothrow_copy_assignable<int>::value;"
 *
 *   X is_trivially_destructible          "$headers" "int a=std::is_trivially_destructible<int>::value;"
 *   X has_virtual_destructor             "$headers" "int a=std::has_virtual_destructor<int>::value;"
 * fi
 *
 */

// load TR1 library
#if MWGCONF_HEADER_STD>=2005
# include <type_traits>
# define MWG_STDM_TYPE_TRAITS_WithTr1Header
#elif defined(MWGCONF_HEADER_TR1)
# include <tr1/type_traits>
# define MWG_STDM_TYPE_TRAITS_WithTr1Header
#endif

#include <cstddef>
#include <mwg/concept.h>
#ifdef __clang__
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wbitwise-op-parentheses"
# pragma clang diagnostic ignored "-Wlogical-op-parentheses"
#endif

namespace mwg{
namespace stdm{

  //
  //  integral_constant
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::integral_constant;
  using ::std::tr1::true_type;
  using ::std::tr1::false_type;
#else
  template<typename T,T Value>
  struct integral_constant{
    static const T value=Value;
    typedef T value_type;
    typedef integral_constant<T,Value> type;
    mwg_constexpr operator value_type() const{return value;}
  };
  typedef integral_constant<bool,true> true_type;
  typedef integral_constant<bool,false> false_type;
#endif

  //
  // is_same
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_same;
#else
  template<typename T,typename U>
  struct is_same:false_type{};
  template<typename T>
  struct is_same<T,T>:true_type{};
#endif

  //
  // conditional
  //
  template<bool V,typename T,typename F> struct conditional:mwg::identity<F>{};
  template<typename T,typename F> struct conditional<true,T,F>:mwg::identity<T>{};

  //
  // enable_if
  //
  template<bool C,typename T=void> struct enable_if{};
  template<typename T> struct enable_if<true,T>:mwg::identity<T>{};

  //
  // alignment_of
  //
  template<typename T>
  struct alignment_of_impl{T mem1;char split;T mem2;};
  template<typename T>
  struct alignment_of:integral_constant<std::size_t,sizeof(alignment_of_impl<T>)-2*sizeof(T)>{};

  //===========================================================================
  //  type categories
  //---------------------------------------------------------------------------
  // + is_void @f
  // + is_reference
  // +   is_lvalue_reference
  // +   is_rvalue_reference
  // + is_function
  // + is_object
  // +   is_scalar
  // +     is_arithmetic @f
  // +       is_integral
  // +         is_signed
  // +         is_unsigned
  // +       is_floating_point
  // +     is_pointer
  // +     is_member_pointer
  // +       is_member_object_pointer
  // +       is_member_function_pointer
  // +     is_null_pointer @f (C++14)
  // +     is_enum
  // +   is_array
  // +   is_class
  // +   is_union
  // 
  // + @f = is_fundamental
  // + !@f = is_compound
  //
  //---------------------------------------------------------------------------

  //
  // is_reference
  //   is_lvalue_reference
  //   is_rvalue_reference
  //   remove_reference
  //
  template<typename T> struct is_lvalue_reference:false_type{};
  template<typename T> struct is_lvalue_reference<T&>:true_type{};
  template<typename T> struct is_rvalue_reference:false_type{};
# ifdef MWGCONF_STD_RVALUE_REFERENCES
  template<typename T> struct is_rvalue_reference<T&&>:true_type{};
# endif
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_reference;
  using ::std::tr1::remove_reference;
#else
  template<typename T> struct is_reference
    :integral_constant<bool,is_lvalue_reference<T>::value||is_rvalue_reference<T>::value>{};

  template<typename T> struct remove_reference:mwg::identity<T>{};
  template<typename T> struct remove_reference<T&>:mwg::identity<T>{};
# ifdef MWGCONF_STD_RVALUE_REFERENCES
  template<typename T> struct remove_reference<T&&>:mwg::identity<T>{};
# endif
#endif

  //
  // add_reference (TR1)
  // add_lvalue_reference
  // add_rvalue_reference
  //
#if (defined(MWG_STDM_TYPE_TRAITS_WithTr1Header) \
  &&defined(MWGCONF_HAS_TR1_ADD_REFERENCE))

  using ::std::tr1::add_reference;
# if !defined(MWGCONF_HAS_ADD_LVALUE_REFERENCE)
  // std::add_lvalue_reference が既に定義されている場合がある(?)
  template<typename T> struct add_lvalue_reference:add_reference<T>{};
# endif
#else
  namespace detail{
    template<typename T,bool B> struct add_lvalue_reference__impl:mwg::identity<T>{};
    template<typename T>        struct add_lvalue_reference__impl<T,true>:mwg::identity<T&>{};
# ifdef MWGCONF_STD_RVALUE_REFERENCES
    template<typename T,bool B> struct add_rvalue_reference__impl:mwg::identity<T>{};
    template<typename T>        struct add_rvalue_reference__impl<T,true>:mwg::identity<T&&>{};
# endif
  }
  // type category           lvalue rvalue
  // ----------------------- ------ ------
  // is_void                 void   void
  // is_reference            U&     T
  // is_function, is_object  T&     T&&
  template<typename T> struct add_lvalue_reference
    :detail::add_lvalue_reference__impl<typename remove_reference<T>::type,!is_void<T>::value>{};

  template<typename T> struct add_reference:add_lvalue_reference<T>{};
# ifdef MWGCONF_STD_RVALUE_REFERENCES
  template<typename T> struct add_rvalue_reference
    :detail::add_rvalue_reference__impl<T,!is_reference<T>::value&&!is_void<T>::value>{};
# endif
#endif

  //
  //  cv qualifiers
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_const;
  using ::std::tr1::is_volatile;
  using ::std::tr1::add_const;
  using ::std::tr1::add_volatile;
  using ::std::tr1::add_cv;
  using ::std::tr1::remove_const;
  using ::std::tr1::remove_volatile;
  using ::std::tr1::remove_cv;
#else
  template<typename T>       struct is_const            :false_type{};
  template<typename T>       struct is_const<const T>   :true_type{};
  template<typename T>       struct is_const<const T[]> :true_type{};
  template<typename T,int N> struct is_const<const T[N]>:true_type{};

  template<typename T>       struct is_volatile               :false_type{};
  template<typename T>       struct is_volatile<volatile T>   :true_type{};
  template<typename T>       struct is_volatile<volatile T[]> :true_type{};
  template<typename T,int N> struct is_volatile<volatile T[N]>:true_type{};

  template<typename T> struct add_const:conditional<is_reference<T>::value,T,const T>{};
  template<typename T> struct add_volatile:conditional<is_reference<T>::value,T,volatile T>{};
  template<typename T> struct add_cv:add_const<typename add_volatile<T>::type>{};

  template<typename T>        struct remove_const             :mwg::identity<T>{};
  template<typename T>        struct remove_const<const T>    :mwg::identity<T>{};
  template<typename T>        struct remove_const<const T[]>  :mwg::identity<T[]>{};
  template<typename T,int N>  struct remove_const<const T[N]> :mwg::identity<T[N]>{};
  template<typename T>        struct remove_volatile                :mwg::identity<T>{};
  template<typename T>        struct remove_volatile<volatile T>    :mwg::identity<T>{};
  template<typename T>        struct remove_volatile<volatile T[]>  :mwg::identity<T[]>{};
  template<typename T,int N>  struct remove_volatile<volatile T[N]> :mwg::identity<T[N]>{};
  template<typename T>        struct remove_cv:remove_const<typename remove_volatile<T>::type>{};
#endif

  //
  // is_void
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_void;
#else
  template<typename T> struct is_void:is_same<typename remove_cv<T>::type,void>{};
#endif

  //
  // is_function
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_function;
#else
  namespace detail{
    template<typename T> struct is_function_impl:false_type{};

    // TODO:
    //    variadic template を使用した実装?
    //    C++11 の variadic template に対応しているのであれば、
    //    <type_traits> も既に用意されているべき?

//%x
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_/," )>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_,/" ...)>:true_type{};
//%end.f/_AR_/0/ArN+1/.i
#ifdef MWG_STD_GccCvQualifiedFunctionType
    // ※上の宣言と重複 ?
    // CHECK: const メンバ関数でも正しく判定されるかどうかを確認
//%x
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_/," ) const>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_,/" ...) const>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_/," ) volatile>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_,/" ...) volatile>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_/," ) const volatile>:true_type{};
    template<typename R $".for/_/0/_AR_/,typename A_/">
    struct is_function_impl<R( $".for/_/0/_AR_/A_,/" ...) const volatile>:true_type{};
//%end.f/_AR_/0/ArN+1/.i
#endif
    template<typename T> struct is_function
      :is_function_impl<typename remove_cv<T>::type>{};
  }
  using detail::is_function;
#endif

  //
  // is_null_pointer
  //
  template<typename T> struct is_null_pointer:is_same<nullptr_t,typename remove_cv<T>::type>{};

  //
  // is_arithmetic
  //   is_floating_point
  //   is_integral
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_arithmetic;
  using ::std::tr1::is_floating_point;
  using ::std::tr1::is_integral;
#else
  namespace detail{
    template<typename T> struct is_integral_impl:false_type{};
    template<> struct is_integral_impl<char>              :true_type{};
    template<> struct is_integral_impl<unsigned char>     :true_type{};
    template<> struct is_integral_impl<signed char>       :true_type{};
    template<> struct is_integral_impl<short>             :true_type{};
    template<> struct is_integral_impl<unsigned short>    :true_type{};
    template<> struct is_integral_impl<int>               :true_type{};
    template<> struct is_integral_impl<unsigned int>      :true_type{};
    template<> struct is_integral_impl<long>              :true_type{};
    template<> struct is_integral_impl<unsigned long>     :true_type{};
# ifdef MWGCONF_HAS_LONGLONG
    template<> struct is_integral_impl<long long>         :true_type{};
    template<> struct is_integral_impl<unsigned long long>:true_type{};
# endif
# ifdef MWGCONF_HAS_DISTINCT_INT64
    template<> struct is_integral_impl<__int64>           :true_type{};
    template<> struct is_integral_impl<unsigned __int64>  :true_type{};
# endif
    template<> struct is_integral_impl<bool>              :true_type{};
# if defined(MSC_VER)
    // /Zc:wchar_t- オプションが指定されていると、
    // wchar_t は unsigned short の typedef になっている。
    // defined(_NATIVE_WCHAR_T_DEFINED) ならば wchar_t は独立の型。
    template<> struct is_integral_impl<__wchar_t>         :true_type{};
# else
    template<> struct is_integral_impl<wchar_t>           :true_type{};
# endif
# ifdef MWGCONF_STD_CHAR16_T
    template<> struct is_integral_impl<char16_t>          :true_type{};
# endif
# ifdef MWGCONF_STD_CHAR16_T
    template<> struct is_integral_impl<char32_t>          :true_type{};
# endif
    template<typename T>
    struct is_integral:is_integral_impl<typename remove_cv<T>::type>{};

    template<typename T>
    struct is_floating_point_impl:false_type{};
    template<> struct is_floating_point_impl<float>:true_type{};
    template<> struct is_floating_point_impl<double>:true_type{};
    template<> struct is_floating_point_impl<long double>:true_type{};
    template<typename T>
    struct is_floating_point:is_floating_point_impl<typename remove_cv<T>::type>{};
  }
  using detail::is_integral;
  using detail::is_floating_point;

  template<typename T>
  struct is_arithmetic
    :integral_constant<bool,is_integral<T>::value||is_floating_point<T>::value>{};
#endif

  //
  //  is_signed
  //  is_unsigned
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  // modify is_signed
  template<typename T> struct is_signed:integral_constant<
    bool,::std::tr1::is_signed<T>::value||::std::tr1::is_floating_point<T>::value>{};

  using ::std::tr1::is_unsigned;
#else
  namespace detail{
    template<typename T> struct is_signed_nocv:is_floating_point<T>{};
    template<> struct is_signed_nocv<signed char>     :true_type{};
    template<> struct is_signed_nocv<signed short>    :true_type{};
    template<> struct is_signed_nocv<signed int>      :true_type{};
    template<> struct is_signed_nocv<signed long>     :true_type{};
# ifdef MWGCONF_HAS_LONGLONG
    template<> struct is_signed_nocv<signed long long>:true_type{};
# endif
# ifdef MWGCONF_HAS_DISTINCT_INT64
    template<> struct is_signed_nocv<signed __int64>  :true_type{};
# endif

    template<typename T> struct is_unsigned_nocv:false_type{};
    template<> struct is_unsigned_nocv<unsigned char>     :true_type{};
    template<> struct is_unsigned_nocv<unsigned short>    :true_type{};
    template<> struct is_unsigned_nocv<unsigned int>      :true_type{};
    template<> struct is_unsigned_nocv<unsigned long>     :true_type{};
# ifdef MWGCONF_HAS_LONGLONG
    template<> struct is_unsigned_nocv<unsigned long long>:true_type{};
# endif
# ifdef MWGCONF_HAS_DISTINCT_INT64
    template<> struct is_unsigned_nocv<unsigned __int64>  :true_type{};
# endif

    template<typename T> struct is_signed
      :is_signed_nocv<typename remove_cv<T>::type>{};
    template<typename T> struct is_unsigned
      :is_unsigned_nocv<typename remove_cv<T>::type>{};
  }
  using detail::is_signed;
  using detail::is_unsigned;
#endif

  //
  //  make_signed
  //  make_unsigned
  //
  template<typename T> struct make_signed:mwg::identity<T>{};
  template<typename T> struct make_signed<const T>
    :add_const<typename make_signed<typename remove_const<T>::type>::type>{};
  template<typename T> struct make_signed<volatile T>
    :add_volatile<typename make_signed<typename remove_volatile<T>::type>::type>{};

  template<typename T> struct make_unsigned:mwg::identity<T>{};
  template<typename T> struct make_unsigned<const T>
    :add_const<typename make_unsigned<typename remove_const<T>::type>::type>{};
  template<typename T> struct make_unsigned<volatile T>
    :add_volatile<typename make_unsigned<typename remove_volatile<T>::type>::type>{};

  template<> struct make_signed<         char> :mwg::identity<  signed char>{};
  template<> struct make_signed<unsigned char> :mwg::identity<  signed char>{};
  template<> struct make_unsigned<       char> :mwg::identity<unsigned char>{};
  template<> struct make_unsigned<signed char> :mwg::identity<unsigned char>{};
  template<> struct make_signed<unsigned short>:mwg::identity<  signed short>{};
  template<> struct make_unsigned<signed short>:mwg::identity<unsigned short>{};
  template<> struct make_signed<unsigned int>  :mwg::identity<  signed int>{};
  template<> struct make_unsigned<signed int>  :mwg::identity<unsigned int>{};
  template<> struct make_signed<unsigned long> :mwg::identity<  signed long>{};
  template<> struct make_unsigned<signed long> :mwg::identity<unsigned long>{};
# ifdef MWGCONF_HAS_LONGLONG
  template<> struct make_signed<unsigned long long>:mwg::identity<  signed long long>{};
  template<> struct make_unsigned<signed long long>:mwg::identity<unsigned long long>{};
# endif
# ifdef MWGCONF_HAS_DISTINCT_INT64
  template<> struct make_signed<unsigned __int64>:mwg::identity<  signed __int64>{};
  template<> struct make_unsigned<signed __int64>:mwg::identity<unsigned __int64>{};
# endif

  //
  // is_pointer
  //   add_pointer
  //   remove_pointer
  // is_member_pointer
  //   is_member_function_pointer
  //   is_member_object_pointer
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_pointer;
  using ::std::tr1::is_member_function_pointer;
  using ::std::tr1::is_member_object_pointer;
  using ::std::tr1::is_member_pointer;
  using ::std::tr1::add_pointer;
  using ::std::tr1::remove_pointer;
#else
  namespace detail{
    // is_member_function_pointer
    template<typename T> struct is_member_function_pointer_impl:false_type{};
#ifdef MWG_STD_GccCvQualifiedFunctionType
    template<typename C,typename S>
    struct is_member_function_pointer_impl<S C::*>:is_function<S>{};
#else
# if (MWGCONF_GCC_VER>=40200)
    /* 条件についてちゃんと調べる */
    template<typename C,typename S>
    struct is_member_function_pointer_impl<S C::*>:is_function<S>{};
# else
//%expand (
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for/_/0/_AR_/A_/," )>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for_sep/_/0/_AR_/A_/,"...)>:true_type{};
//%).f/_AR_/0/ArN+1/.i
# endif
//%expand (
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for/_/0/_AR_/A_/,") const>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for_sep/_/0/_AR_/A_/,"...) const>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for/_/0/_AR_/A_/,") volatile>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for_sep/_/0/_AR_/A_/,"...) volatile>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for/_/0/_AR_/A_/,") const volatile>:true_type{};
    template<typename C,typename R$".sep_for/_/0/_AR_/typename A_/,">
    struct is_member_function_pointer_impl<R(C::*)($".for_sep/_/0/_AR_/A_/,"...) const volatile>:true_type{};
//%).f/_AR_/0/ArN+1/.i
#endif
    template<typename T> struct is_member_function_pointer
      :is_member_function_pointer_impl<typename remove_cv<T>::type>{};

    // is_member_pointer
    template<typename T> struct is_member_pointer_impl:false_type{};
    template<typename C,typename T> struct is_member_pointer_impl<T C::*>:true_type{};
    template<typename T> struct is_member_pointer
      :integral_constant<bool,is_member_pointer_impl<typename remove_cv<T>::type>::value||is_member_function_pointer<T>::value>{};

    // is_member_object_pointer
    template<typename T> struct is_member_object_pointer
      :integral_constant<bool,is_member_pointer<T>::value&&!is_member_function_pointer<T>::value>{};

    // is_pointer
    template<typename T> struct is_pointer_impl:false_type{};
    template<typename T> struct is_pointer_impl<T*>
      :integral_constant<bool,!is_member_pointer<T>::value>{};
    template<typename T> struct is_pointer
      :is_pointer_impl<typename remove_cv<T>::type>{};

    // add_pointer, remove_pointer
    template<typename T> struct remove_pointer_impl:mwg::identity<T>{};
    template<typename T> struct remove_pointer_impl<T*>:mwg::identity<T>{};
    template<typename T> struct remove_pointer
      :remove_pointer_impl<typename remove_cv<T>::type>{};
    template<typename T> struct add_pointer
      :mwg::identity<typename remove_reference<T>::type*>{};

  }
  using detail::is_member_pointer;
  using detail::is_member_function_pointer;
  using detail::is_member_object_pointer;
  using detail::is_pointer;
  using detail::add_pointer;
  using detail::remove_pointer;
#endif

  //
  // is_array
  //   remove_extent
  //   remove_all_extents
  //   extent
  //   rank
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_array;
  using ::std::tr1::remove_extent;
  using ::std::tr1::remove_all_extents;
  using ::std::tr1::extent;
  using ::std::tr1::rank;
#else
  namespace detail{
    template<typename T>
    struct rank_impl:integral_constant<std::size_t,0>{};
    template<typename T,std::size_t N>
    struct rank_impl<T[N]>:integral_constant<std::size_t,rank_impl<T>::value+1>{};
    template<typename T>
    struct rank_impl<T[]>:integral_constant<std::size_t,rank_impl<T>::value+1>{};

    template<typename T,unsigned N>
    struct extent_impl:integral_constant<std::size_t,0>{};
    template<typename T>
    struct extent_impl<T[ ],0>:integral_constant<std::size_t,0>{};
    template<typename T,std::size_t X>
    struct extent_impl<T[X],0>:integral_constant<std::size_t,X>{};
    template<typename T,unsigned N>
    struct extent_impl<T[ ],N>:extent_impl<T,N-1>{};
    template<typename T,std::size_t X,unsigned N>
    struct extent_impl<T[X],N>:extent_impl<T,N-1>{};

    template<typename T>
    struct remove_extent_impl      :mwg::identity<T>{};
    template<typename T>
    struct remove_extent_impl<T[ ]>:mwg::identity<T>{};
    template<typename T,std::size_t X>
    struct remove_extent_impl<T[X]>:mwg::identity<T>{};
  }
  template<typename T>
  struct rank:detail::rank_impl<T>{};
  template<typename T>
  struct is_array:integral_constant<bool,detail::rank_impl<T>::value!=0>{};
  template<typename T,unsigned N=0>
  struct extent:detail::extent_impl<T,N>{};
  template<typename T>
  struct remove_extent:detail::remove_extent_impl<T>{};
  template<typename T>
  struct remove_all_extents:conditional<
    is_array<T>::value,
    remove_all_extents<typename detail::remove_extent_impl<T>::type >,
    mwg::identity<T> >::type{};
#endif

  //
  // is_class
  // is_union
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_union;
  using ::std::tr1::is_class;
#else
  namespace detail{
    template<typename T>
    mwg_concept_sfinae_typeOverload(is_class_or_union_impl,T,X,(void(X::*)(void)),(0));

    template<typename T>
    struct is_class_or_union
      :integral_constant<bool,is_class_or_union_impl<typename remove_cv<T>::type>::value>{};

  //?mconf X 'intrinsic __is_union' '' "int a=__is_union(int);"
# ifdef MWGCONF_HAS_INTRINSIC___IS_UNION
    template<typename T> struct is_union_nocv:integral_constant<bool,__is_union(T)>{};
# else
    template<typename T> struct is_union_nocv:false_type{};
# endif
    template<typename T> struct is_union:is_union_nocv<typename remove_cv<T>::type>{};

    template<typename T> struct is_class:integral_constant<bool,is_class_or_union<T>::value&&!is_union<T>::value>{};
  }
  using detail::is_union;
  using detail::is_class;
#endif

  //
  // is_base_of
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_base_of;
#else
# if defined(_MSC_VER)&&_MSC_FULL_VER>=140050215||MWGCONF_GCC_VER>=40300
  template<typename Base,typename Derived>
  struct is_base_of:integral_constant<bool,__is_base_of(Base,Derived)>{};
# elif defined(mwg_concept_is_valid_expression)
  template<typename From,typename To>
  struct is_base_of{
    template<typename T> static T expr();
    typedef typename remove_cv<From>::type* DD;
    typedef typename remove_cv<To>::type* BB;
    mwg_concept_is_valid_expression(mwg_is_convertible_to,DD,F,BB(expr<F>()));
    mwg_concept_condition(!is_void<To>::value&&mwg_is_convertible_to::value);
  };
# else
  //---------------------------------------------------------------------------
  // from boost/type_traits/is_base_of.hpp
  namespace detail{
    template<typename B,typename D>
    struct is_base_and_derived{
      mwg_concept_sfinae_param{
#  if defined(_MSC_VER)&&_MSC_VER==1310
        static mwg::concept_detail::true_t  eval(D const volatile*       ,long);
        static mwg::concept_detail::false_t eval(B const volatile* const&,int);
#  else
        template<typename T>
        static mwg::concept_detail::true_t  eval(D const volatile*,T);
        static mwg::concept_detail::false_t eval(B const volatile*,int);
#  endif
      };
      struct Host{
#  if defined(_MSC_VER)&&_MSC_VER==1310
        operator D const volatile*       ();
        operator B const volatile* const&() const;
#  else
        operator D const volatile*();
        operator B const volatile*() const;
#  endif
      };
      mwg_concept_condition(mwg_concept_bool_eval(sfinae_checker::eval(Host(),0)));
    };
  }
  template<typename Base,typename Derived>
  struct is_base_of:integral_constant<bool,is_same<Base,Derived>::value||mwg::stdm::detail::is_base_and_derived<Base,Derived>::value >{};
# endif
#endif

  //
  // is_convertible
  //
#if (defined(MWG_STDM_TYPE_TRAITS_WithTr1Header)&& \
  defined(MWGCONF_HAS_VALID_IS_CONVERTIBLE))
  using ::std::tr1::is_convertible;
#else
}
}
# include "type_traits.is_convertible.inl"
// the above include requires
//   is_void, is_base_of, is_same,
//   is_const, is_volatile, remove_cv.
namespace mwg{
namespace stdm{
#endif

  //
  // is_object
  //   is_scalar
  //     is_enum
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_enum;
  using ::std::tr1::is_scalar;
  using ::std::tr1::is_object;
#else
  template<typename T>
  struct is_enum:integral_constant<
    bool,
    !is_arithmetic<T>::value&&
    !is_pointer<T>::value&&!is_member_pointer<T>::value&&!is_function<T>::value&&
    !detail::is_class_or_union<T>::value&&!is_array<T>::value&&
    !is_reference<T>::value&&is_convertible<typename remove_cv<T>::type,int>::value
    >{};

  template<typename T>
  struct is_scalar:integral_constant<
    bool,
    is_arithmetic<T>::value||
    is_enum<T>::value||
    is_pointer<T>::value||
    is_member_pointer<T>::value||
    is_null_pointer<T>::value
    >{};

  template<typename T>
  struct is_object:integral_constant<
    bool,
    is_scalar<T>::value||
    is_array<T>::value||
    is_class<T>::value||
    is_union<T>::value
    >{};
#endif

  //
  // is_fundamental
  // is_compound
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_fundamental;
  using ::std::tr1::is_compound;
#else
  template<typename T>
  struct is_fundamental:integral_constant<
    bool,
    is_arithmetic<T>::value||
    is_void<T>::value||
    is_same<nullptr_t,typename remove_cv<T>::type>::value
    >{};
  template<typename T>
  struct is_compound:integral_constant<bool,!is_fundamental<T>::value>{};
#endif

  //===========================================================================
  //  type utilities
  //---------------------------------------------------------------------------

  //
  // decay
  //
  template<typename T>
  struct decay_impl:conditional<
    is_array<T>::value,typename remove_extent<T>::type*,
    typename conditional<
      is_function<T>::value,typename add_pointer<T>::type,
      typename remove_cv<T>::type
    >::type
  >{};
  template<typename T>
  struct decay
    :decay_impl<typename remove_reference<T>::type>{};

  //
  // common_type
  //
//%[ArN=10]
# define MWG_STD_COMMON_TYPE__EMULATED
# if defined(MWGCONF_STD_VARIADIC_TEMPLATES)
  template<typename... Ts>
  struct common_type{};
# else
//%x
  template<$".for/K/0/ArN/typename TK=void/,">
  struct common_type
    :common_type<typename common_type<T0,T1>::type,$".for/K/2/ArN/TK/,">{};
//%end.i
# endif
  //---------------------------------------------------------------------------
  //  common_type<>
  template<> struct common_type<>{};
  //---------------------------------------------------------------------------
  //  common_type<T0>
  template<typename T0> struct common_type<T0>:mwg::identity<T0>{};
  //---------------------------------------------------------------------------
  //  common_type<T0,T1>
# if defined(MWGCONF_STD_DECLTYPE)
  template<typename T0,typename T1>
  struct common_type<T0,T1>:mwg::identity<decltype(true?mwg::declval<T0>():mwg::declval<T1>())>{};
# else
  // TODO: [cond.expr] 基本クラスの判定?
  template<typename T0,typename T1>
  struct common_type<T0,T1>:stdm::conditional<
    stdm::is_same<T1,T0>::value,mwg::identity<T1>,
    typename stdm::conditional<
      stdm::is_same<T1,void>::value||stdm::is_same<T0,void>::value,
      void, // typename stdm::conditional<stdm::is_same<T1,void>::value,mwg::identity<T0>,mwg::identity<T0> >::type, /* T0 or T1 = throw-expression */
      typename stdm::conditional<
        stdm::is_convertible<T1,T0>::value!=stdm::is_convertible<T0,T1>::value,
        stdm::conditional<stdm::is_convertible<T1,T0>::value,T0,T1>,
        void
        >::type
      >::type
    >::type{};
# endif
  //---------------------------------------------------------------------------
  //  common_type<T0,T1,T2,...>::type
# if defined(MWGCONF_STD_VARIADIC_TEMPLATES)
  template<typename T0,typename T1,typename T2,typename... Ts>
  struct common_type<T0,T1,T2,Ts...>
    :common_type<typename common_type<T0,T1>::type,T2,Ts...>{};
# else
//%x
  template<$".for/K/0/_AR_/typename TK/,">
  struct common_type<$".for/K/0/_AR_/TK/,">
    :common_type<typename common_type<T0,T1>::type,$".for/K/2/_AR_/TK/,">{};
//%end.f/_AR_/3/ArN/.i
# endif

  //===========================================================================
  //  class_traits
  //---------------------------------------------------------------------------

  //
  // is_empty
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_empty;
#else
# if defined(_MSC_VER)||MWGCONF_GCC_VER>=40300
  template<typename T> struct is_empty:integral_constant<bool,__is_empty(T)>{};
# else
  /* ■取り敢えず false■ */
  // ライブラリによる実装手段はない。
  template<typename T> struct is_empty:false_type{};
# endif
#endif

  //
  // is_pod
  //
#ifdef MWG_STDM_TYPE_TRAITS_WithTr1Header
  using ::std::tr1::is_pod;
#else
  namespace detail{
    template<typename T>
    struct is_pod_impl2:integral_constant<bool,
# if (MWGCONF_MSC_VER>=140050215)
      (__is_pod(T)&&__has_trivial_constructor(T))
# elif (MWGCONF_GCC_VER>=40300&&!defined(__GCCXML__))
      (__is_pod(T))
# else
#  define mwg_stdm_is_pod__incomplete
      false
# endif
      >{};

    template<typename T,bool isArray>
    struct is_pod_impl1:integral_constant<bool,(is_scalar<T>::value||is_void<T>::value||is_pod_impl2<T>::value)>{};
    template<typename T>
    struct is_pod_impl1<T,true>:integral_constant<bool,extent<T>::value!=0&&is_pod_impl1<typename remove_all_extents<T>::type,false>::value>{};
    template<typename T>
    struct is_pod:is_pod_impl1<T,is_array<T>::value>{};
  }

  using detail::is_pod;
#endif

}
}

#ifdef __clang__
# pragma clang diagnostic pop
#endif

#endif
//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
// mwg::stdx : mwg extension
//-----------------------------------------------------------------------------
namespace mwg{
namespace stdx{
  using namespace mwg::stdm;

  // add_cref<T>
  template<typename T> struct add_cref:add_lvalue_reference<typename add_const<T>::type>{};

  // parameter_pack<Ts...>
#if defined(MWGCONF_STD_VARIADIC_TEMPLATES)
  template<typename... Ts>
  struct parameter_pack{static const std::size_t size=sizeof...(Ts);};
#else
//%expand (
  template<$".for/K/0/ArN/typename AK=void/,">
  struct parameter_pack{static const std::size_t size=$".eval:ArN";};
//%expand (
  template<$".for/K/0/_AR_/typename AK/,">
  struct parameter_pack<$".for/K/0/_AR_/AK/,">{static const std::size_t size=_AR_;};
//%).f/_AR_/0/ArN/
//%).i
#endif

  // ice_and
  // ice_or
  // is_convertible_pack<Ts...>
#if defined(MWGCONF_STD_VARIADIC_TEMPLATES)
  template<bool... Bs> struct ice_and;
  template<bool... Bs> struct ice_and<false,Bs...>:stdm::false_type{};
  template<bool... Bs> struct ice_and<true,Bs...>:ice_and<Bs...>{};
  template<> struct ice_and<>:stdm::true_type{};
  template<bool... Bs> struct ice_or;
  template<bool... Bs> struct ice_or<true,Bs...>:stdm::true_type{};
  template<bool... Bs> struct ice_or<false,Bs...>:ice_or<Bs...>{};
  template<> struct ice_or<>:stdm::false_type{};

  namespace detail{
    template<typename TT1,typename TT2,bool S>
    struct is_convertible_pack_impl:stdm::false_type{};
    template<typename... As,typename... Bs>
    struct is_convertible_pack_impl<parameter_pack<As...>,parameter_pack<Bs...>,true>
      :stdm::integral_constant<bool,ice_and<stdm::is_convertible<As,Bs>::value...>::value>{};
  }

  template<typename TT1,typename TT2>
  struct is_convertible_pack:stdm::false_type{};
  template<typename... As,typename... Bs>
  struct is_convertible_pack<parameter_pack<As...>,parameter_pack<Bs...>>
    :detail::is_convertible_pack_impl<parameter_pack<As...>,parameter_pack<Bs...>,sizeof...(As)==sizeof...(Bs)>{};
#else
//%expand (
  template<$".for/K/0/ArN/bool CK=true/,"> struct ice_and:false_type{};
  template<> struct ice_and<>:true_type{};
  template<$".for/K/0/ArN/bool CK=false/,"> struct ice_or:true_type{};
  template<> struct ice_or<>:false_type{};

  namespace detail{
    template<typename TT1,typename TT2,bool S> struct is_convertible_pack_impl:false_type{};
    template<> struct is_convertible_pack_impl<parameter_pack<>,parameter_pack<>,true>:true_type{};
    template<$".for/K/0/ArN/typename AK/,",$".for/K/0/ArN/typename BK/,">
    struct is_convertible_pack_impl<parameter_pack<$".for/K/0/ArN/AK/,">,parameter_pack<$".for/K/0/ArN/BK/,">,true>
      :stdm::integral_constant<bool,
        stdm::is_convertible<A0,B0>::value
        &&is_convertible_pack_impl<parameter_pack<$".for/K/1/ArN/AK/,">,parameter_pack<$".for/K/1/ArN/BK/,">,true>::value
      >{};
  }
  template<typename TT1,typename TT2>
  struct is_convertible_pack
    :detail::is_convertible_pack_impl<TT1,TT2,TT1::size==TT2::size>{};
//%).i
#endif
}
}
#include "type_traits.is_constructible.h"
#endif /* MWG_STDM_TYPE_TRAITS */
